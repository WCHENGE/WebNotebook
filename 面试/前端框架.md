## Vue 组件使用

### 1. props 和 $emit

### 2. 组件间通讯-自定义事件

### 3. 组件生命周期

![vue Lifecycle](https://tva1.sinaimg.cn/large/008eGmZEgy1gnacneg4xej30u023zt9s.jpg)

## Vue 高级特性

### 1. 自定义 v-model

```vue
<template>
	<input type="text" :value="text1" @input="$emit('change1', $event.target.value)" />
<!-- 
  1. 上面的 input 使用了 :value 而不是 v-model
  2. 上面的 change1 和 model.event1 要对应起来
  3. text1 属性对应起来
-->
</template>
<script>
export default {
  model: {
    prop: 'text1',
    event: 'change1'
  },
  props: {
    text1: String,
    default: () => ''
  }
}
</script>
```

### 2. $nextTick

* Vue 是异步渲染（原理部分会详细讲解）；
* data 改变之后，DOM 不会立刻渲染；
* $nextTick 会在 DOM 渲染之后被触发，以获取最新 DOM 节点；

```vue
<template>
  <div id="app">
    <ul ref="uli">
      <li v-for="(item, index) in list" :key="index">
        {{item}}
  		</li>
  	</ul>
    <button>添加一项</button>
  </div>
</template>
<script>
export defualt {
	name: 'app',
  data: () => ({
    list: ['a', 'b', 'c']
  }),
  methods: {
    addItem() {
      this.list.push(`${Date.now()}`)
      this.list.push(`${Date.now()}`)
      this.list.push(`${Date.now()}`)
      
      // 1. 异步渲染，$nextTick 待 DOM 渲染完再回调
      // 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次
      this.$nextTick(() => {
        const ulElem = this.$refs.uli
        console.log(ulElem.childNodes.length)
      })
    }
  }
}
</script>
```

### 3. slot

* 基本使用

* 作用域插槽

* 具名插槽

  ```vue
  <!-- NamedSolt 组件 -->
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  
  <!-- parent 组件 -->
  <NamedSlot>
    <template v-slot:header>
      <h1>将插入到 header slot 中</h1>
    </template>
    <p>将插入到 main slot 中，即为命名的 slot</p>
    <template v-slot:footer>
    <p>将插入到 footer slot 中</p>
    </template>
  </NameSlot>
  ```
  

### 4. 动态组件

* 用法：`<component :is="component-name" />`
* 需要根据数据，动态渲染的场景。即组件类型不确定。

### 5. 异步组件

* `import()`函数
* 按需加载，异步加载大组件

```vue
<srcipt>
  components: {
    FormDemo: () => import('../Baseuse/FormDemo.vue')
  }
</script>
```

### 6. Keep-alive

* 缓存组件
* 频繁切换，不需要重复渲染
* Vue 常见性能优化

```vue
<template>
  <div>
    <button @click="changeState('A')">A</button>
    <button @click="changeState('B')">B</button>
    <button @click="changeState('C')">C</button>
    <keep-alive>
      <KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
    </keep-alive>
  </div>
</template>
```

### 7. mixin

* 多个组件有相同的逻辑，抽离出来；
* mixin 并不是完美的解决方案，会有一些问题；
* Vue 3 提出的 Composition API 旨在解决这些问题；

```vue
<template>
  <div>
    <p>{{name}}{{major}}{{city}}</p>
    <button @click="showName">显示姓名</button>
  </div>
</template>

<script>
import myMixin from './mixin'
export default {
  mixins: [myMixin],	// 可以添加多个，会自动合并起来
  data: () => ({
    name: 'shuangyue',
    major: 'web 前端'
  }),
  mounted() {
    console.log('component mounted', this.name)
  },
  methods: {},
}
</script>
```

```vue
<!-- mixin -->
<script>
export default {
  data: () => ({
    city: 'beijing'
  }),
  mounted() {
    console.log('mixin mounted', this.name)
  },
  methods: {
    showName() {
      console.log(this.name)
    }
  }
}
</script>
```

**mixin 的问题：**

* 变量来源不明确，不利于阅读；
* 多 mixin 可能会造成命名冲突；
* mixin 和组件可能出现多对多的关系，复杂度较高；



## Vuex 使用

![vuex](https://tva1.sinaimg.cn/large/008eGmZEgy1gnb9wfuqvcj30jh0fbwef.jpg)


### 1. Vuex 基本概念

#### 1.1 state

#### 1.2 getters

#### 1.3 mutation

#### 1.4 action

### 2. 用于 Vue 组件

#### 2.1 dispatch

#### 2.2 commit

#### 2.3 mapState

#### 2.4 mapGetters

#### 2.5 mapMutations

#### 2.6 mapActions

## Vue-router 使用

### 1. 路由模式（hash、H5 history）

* hash 模式（默认），如 `http://abc.com/#/user/10`
* H5 history 模式，如`http://abc.com/user/20`
* 后者需要 server 端支持，因此无特殊需求可选择前者

### 2. 路由配置（动态路由、懒加载）

```javascript
const router = new VueRouter({
  mode: 'history',	// 使用 H5 history 模式
  routes: [...]
})
```

**动态路由配置：**

```javascript
const user = {
  // 获取参数如 10 20
  template: '<div>User {{ $route.params.id }}</div>'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头，能命中 `/user/10`、`/user/20` 等格式的路由
    { path: '/user/:id', component: User }
  ]
})
```

**路由-懒加载：**

```javascript
export default new VueRouter({
  routes: [
    {
      path: '/',
      component: () => import('../components/Navigator')
    },
    {
      path: '/feedback',
      component: () => import('../components/FeedBack')
    }
  ]
})
```

## Vue 原理

### 1. 组件化和 MVVM

#### 1.1 组件化基础

* “很久以前”就有组件化

  * asp、jsp、php 已经有组件化了
  * nodejs 中也有类似的组件化

  ![CC2977CB-DF53-427A-A217-15B1B2F388FB_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjvkdv6ej31n80hz42g.jpg)

  ![E13C2DB3-C978-4AAA-BC63-31DA5EC0D908_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjvouc1vj31m80t50x4.jpg)

* 数据驱动视图（MVVM，setState）

  * 传统组件，只是静态渲染，更新还要依赖与操作 DOM；

  * 数据驱动视图 - Vue MVVM

    ![Vue MVVM](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk1zls4pj318g0nmwfe.jpg)

  * 数据驱动视图 - React setState

### 2. 响应式原理

* 组件 data 的数据一旦变化，立刻触发视图的更新；
* 实现数据驱动视图的第一步；

![E2A1FE7C-4AD9-4750-BA02-32EB9FB15FA4_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk88omg5j31o30pbq6h.jpg)

实现响应式：

* 核心 API - Object.defineProperty
* 如何实现响应式，代码演示
* Object.defineProperty 的一些缺点（Vue3.0 启用 Proxy）

Proxy 有兼容性问题：

* Proxy 兼容性不好，且无法 polyfill
* Vue2.x 还会存在一段时间，所以都得学

**Object.defineProperty 基本用法：**

```javascript
const data = {}
const name = 'zhangsan'
Object.defineProperty(data, 'name', {
  get: function() {
    console.log('get')
    return name
  },
  set: function(newVal) {
    console.log('set')
    name = newVal
  }
})

// 测试
console.log(data.name)	// get zhangsan
data.name = 'list'	// set
```

* 监听对象，监听数组
* 复杂对象，深度监听
* Object.defineProperty 几个缺点
  * 深度监听，需要递归到底，一次性计算量大；
  * 无法监听新增属性/删除属性（Vue.set / Vue.delete）
  * 无法原声监听数组，需要特殊处理

```javascript

```

### 3. 虚拟 DOM （Virtual DOM）和 diff 算法

* vdom 是实现 vue 和 React 的重要基石；
* diff 算法是 vdom 中最核心、最关键的部分；

> * DOM 操作非常耗费性能
> * 以前用 jQuery，可以自行控制 DOM 操作的时机，手动调整
> * Vue 和 React 是数据驱动视图，如何有效控制 DOM 操作？
>   * 有了一定复杂度，想减少计算次数比较难
>   * 能不能把计算，更多的转移为 JS 计算？因为 JS 执行速度很快
>   * vdom - 用 JS 模拟 DOM 结构，计算出最小的变更，操作 DOM

![IMG_2100](https://tva1.sinaimg.cn/large/008eGmZEgy1gnch5440hbj31dt0u0wp7.jpg)

**通过 snabbdom 学习 vdom**

* 简洁强大的 vdom 库，易学易用
* Vue 参考它实现的 vdim 和 diff
* [https://github.com/snabbdom/snabbdom](snabbdom)

**diff 算法**

* diff 算法是 vdom 中最核心、最关键的部分；
* diff 算法能在日常使用 Vue、React 中体现出来（如 key）

**diff 算法概述**

* diff 即对比，是一个广泛的概念，如 Linux diff 命令、git diff 等
* 两个 js 对象也可以做 diff，如 [https://github.com/cujojs/jiff]()
* 两颗树做 diff，如这里的 vdom diff

![IMG_2101](https://tva1.sinaimg.cn/large/008eGmZEgy1gnchp36djej31fc0oytn3.jpg)

**树 diff 的时间复杂度 O(n^3)**

* 第一，遍历 tree1
* 第二，遍历 tree2
* 第三，排序

如 1000 个节点，要计算 1 亿次，算法不可用。

**优化时间复杂度到 O(n)**

* 只比较同一层级，不跨级比较；
* tag 不相同，则直接删掉重建，不再深度比较；
* tag 和 key，两者都相同，则认为是相同节点，不再深度比较；

![86A6566A-4876-4E51-839C-AF0924368D37_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gnchz98sg6j30ya0hp76m.jpg)

![A8084E13-3FAC-4632-AD4E-57746605006D_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gnci01x27kj310i0gmjte.jpg)

**vdom 和 diff 总结：**

* 细节不重要，updateChildren 的过程也不重要，不要讲究；
* vdom 核心概念很重要：h、vnode、patch、diff、key 等；
* vdom 存在的价值更加重要：数据驱动视图，控制 DOM 操作；

### 4. 模版编译

* 模版是 Vue 开发中最常用的部分，即与使用相关联的原理
* 它不是 html，有指令、插值、JS 表达式，到底是什么？
* 面试不会直接问，但会通过“组件渲染和更新过程”考察

#### 4.1 前置知识：JS 的 with 语法

* 改变`{}`内自由变量的查找规则，当做 obj 属性来查找；
* 如果找不到匹配的 obj 属性，就会报错；
* with 要慎用，它打破了作用域的规则，易读性变差；

![image-20210206190727267](https://tva1.sinaimg.cn/large/008eGmZEgy1gne0ui5fi3j31js0ia4d9.jpg)

#### 4.2 `vue-template-complier` 将模版编译为 render 函数

* 模版不是 html ，有指令、插值、JS 表达式，能实验判断、循环♻️；
* html 是标签语言，只有 JS 才能实现判断、循环（图灵完备）
* 因此，模版一定是转换为某种 JS 代码，即编译模版；

#### 4.3 执行 render 函数生成 vnode

* 模版编译为 render 函数，执行 render 函数返回 vnode；
* 基于 vnode 再执行 patch 和 diff （后面会讲）；
* 使用 webpack vue-loader ，会在开发环境下编译模版（重要）；

![image-20210206193309521](https://tva1.sinaimg.cn/large/008eGmZEgy1gne1l76ov1j31as0tok59.jpg)

> * 讲完模板编译，再讲这个 render，就比较好理解了；
> * 在有些复杂情况中，不能用 template，可以考虑用 render；
> * React 一直都用 render（没有模板），和这里一样；

### 5. 组件渲染过程

#### 5.1 初次渲染过程

* 解析模板为 render 函数（或在开发环境已完成，vue-loader）
* 触发响应式，监听 data 属性 getter、setter
* 执行 render 函数，生成 vnode，patch(elem, vnode)

![image-20210206195107914](https://tva1.sinaimg.cn/large/008eGmZEgy1gne23wos8xj31ka0s8dup.jpg)

#### 5.2 更新过程

* 修改 data，触发 setter（此前在 getter 中已被监听）；
* 重新执行 render 函数，生成 newVnode；
* patch(vnode, newVnode)

![image-20210206195405733](https://tva1.sinaimg.cn/large/008eGmZEgy1gne26z65gxj311k0ru7en.jpg)

#### 5.3 异步渲染

* 回顾 `$nextTick`；
* 汇总 data 的修改，一次性更新视图；
* 减少 DOM 操作次数，提高性能；

![image-20210206200139144](https://tva1.sinaimg.cn/large/008eGmZEgy1gne2eus8ufj30ng0e044t.jpg)

### 6. 前端路由

![image-20210206211021450](https://tva1.sinaimg.cn/large/008eGmZEgy1gne4ecq3dgj31jq0o0e0f.jpg)

#### 6.1 hash 的特点

* hash 变化会触发网页跳转，即浏览器的前进、后退；
* hash 变化不会刷新页面，SPA 必需的特点；
* hash 永远不会提交到 server 端（前端自生自灭）；

```javascript
window.onhashchange = (event) => {
  console.log('old url', event.oldURL)
  console.log('new url', event.newURL)
  console.log('hash', location.hash)
}

// 页面初次加载、获取 hash
document.addEventListener('DOMContentLoaded', () => {
  console.log('hash:', location.hash)
})

// JS 修改 URL
document.getElementById('btn1').addEventListener('click', {
  location.hash = '#/user'
})
```

#### 6.2 H5 history

* 用 URL 规范的路由，但跳转时不刷新页面；
* `history.pushState`
* `window.onpopstate`

## Vue 真题

### 1. `v-show` 和 `v-if` 的区别？

* v-show 通过 CSS display 控制显示和隐藏；
* v-if 组件是真正的渲染和销毁，而不是显示和隐藏；
* 频繁切换显示状态用 v-show，否则用 v-if ；

### 2. 为何在 v-for 中使用 key 属性

* 必须用 key ，且不能是 index 和 random ；
* diff 算法中通过 tag 和 key 来判断，是否是 sameNode ；
* 减少渲染次数，提升渲染性能；

### 3. 描述一下 Vue 组件生命周期（父子组件）？

* 单组件生命周期图；
* 父子组件生命周期关系；

### 4. Vue 组件如何通讯（常见）？

* 父子组件 `props` 和 `this.$emit`
* 自定义事件 `event.$no`、`event.$off`、`event.$emit`
* `Vuex`

### 5. 描述组件渲染和更新的过程？

![image-20210206215548161](https://tva1.sinaimg.cn/large/008eGmZEgy1gne5pm53spj311c0l4dni.jpg)

### 6. 双向数据绑定 v-model 的实现原理

* input 元素的 value = this.name
* 绑定 input 事件 this.name = $event.target.value
* Data 更新触发 re-render

### 7. 对 MVVM 的理解

![Vue MVVM](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk1zls4pj318g0nmwfe.jpg)

### 8. computed 有何特点

* 缓存，data 不变不会重新计算；
* 提高性能

### 9. 为何组件 data 必须是一个函数？

```javascript
export default {
  name: 'app',
  data() {
    return {
      name: 'vue'.,
      list: ['a', 'b', 'c']
    }
  },
  methods: {
    changeName() {
      this.name = 'shuangyue'
    },
    
  }
}
```

* 组件是对 Vue class 实例化；
* 组件 data 在函数作用域内可以避免变量对全局实例化属性的污染；

### 10. ajax 请求应该放在哪个生命周期

* `mounted`
* JS 是单线程的，ajax 异步获取数据；
* 放在 mounted 之前没有用，只会让逻辑更加混乱；

### 11. 如何将组件所有 props 传递给子组件？

* `$props`
* `<User v-bind="$props">`

### 12. 如何自己实现 v-model

```vue
<template>
  <input type="text" :value="text" @input="$emit('change', $event.target.value)" />
  <!-- 
    注意：
    第一，上面使用 :value 而没用 v-model
    第二，上面的 change 和 model.event 对应起来即可，名字自己该
  -->
</template>
<script>
export default {
  model: {
    prop: 'text',	// 对应到 props text
    event: 'change'
  },
  props: {
    text: String
  }
}  
</script>
```

### 13. 多个组件有相同的逻辑，如何抽离？

* `mixin`
* 以及 mixing 的一些缺点

### 14. 何时要使用异步组件？

* 加载大组件；
* 路由异步加载；

### 15. 何时需要使用 keep-alive ？

* 缓存组件，不需要重复渲染；
* 如多个静态 tab 页的切换；
* 优化性能；

### 16. 何时需要使用 beforeDestory

* 解绑自定义事件 `event.$off`；
* 清除定时器；
* 解绑自定义的 DOM 事件，如 window scroll 等；

### 17. 什么是作用域插槽？

```vue
// 子组件
<template>
  <a :href="url">
    <slot :website="website">
      {{website.subTitle}}
    </slot>
  </a>
</template>
<script>
export default {
  name: 'ScopedSlotDemo',
  props: ['url'],
  data() {
    return {
      website: {
        url: 'http://wangEditor.com/',
        title: 'wangEditor',
        subTitle: '轻量级富文本编辑器'
      }
    }
  }
}
</script>

// 父组件
<ScopedSlotDemo :url="website.url">
  <template v-slot="slotProps">
    {{ /* slotProps 名字可自定义 */ }}
    {{slotProps.website.title}}
  </template>
</ScopedSlotDemo>
```

### 18. Vuex 中 action 和 mutation 有和区别？

* `action` 中可以处理异步，`mutation`不可以；
* `mutation`做原子操作；
* `action` 可以整合多个 `mutation`；

### 19. Vue-router 常用的路由模式

* hash 默认；
* H5 history（需要服务端支持）；
* 两者比较

### 20. 如何配置 Vue-router 异步加载

```javascript
export default new VueRouter({
  routes: [
    {
      path: '/',
      component: () => import('../components/Navigator')
    },
    {
      path: '/feedback',
      component: () => import('../components/FeedBack')
    }
  ]
})
```

### 21. 请用 vnode 描述一个 DOM 结构？

```html
<div id="div1" class="container">
  <p>vdom</p>
  <ul style="font-size: 20px">
    <li>a</li>
  </ul>
</div>
```

```json
{
  tag: 'div',
  props: {
    className: 'container',
    id: 'div1'
  },
  children: [
    {
      tag: 'p',
      children: 'vdom'
    },
    {
      tag: 'ul',
      props: { style: 'font-size: 200px' },
      children: [
        {
          tag: 'li',
          children: 'a',
        }
      ]
    }
  ]
}
```

### 22. 监听 data 变化的核心 API 是什么？

* `Object.defineProperty`
* 以及深度监听、监听数组
* 有何缺点

### 23. Vue 如何监听数组变化？

* `Object.defineProperty` 不能监听数组变化；
* 重新定义原型，重写 push、pop 等方法，实现监听；
* Proxy 可以原生支持监听数组变化；

### 24. 请描述响应式原理

* 监听 data 变化；
* 组件渲染和更新的流程；

### 25. diff 算法的事件复杂度

* O(n)
* 在 O(n^3) 基础上做了一些调整

### 26. 简述 diff 算法过程

* patch(elem, vnode) 和 patch(vnode, newVnode)
* patchVnode 和 addVnodes 和 removeVnodes
* updateChildren （key 的重要性）

### 27. Vue 为何是异步渲染，$nextTick 何用？

* 异步渲染（以及合并 data 修改），以提高渲染性能；
* $nextTick 在 DOM 更新完之后，触发回调；

### 28. Vue 常用性能优化方式

* 合理使用 v-show 和 v-if ；
* 合理使用 computed ；
* v-for 时加 key，以及避免和 v-if 同时使用；
* 自定义事件、DOM 事件及时销毁；
* 合理使用异步组件；
* 合理使用 keep-alive ；
* data 层级不要太深；
* 使用 vue-loader 在开发环境做模版编译（预编译）；
* webpack 层面的优化；
* 前端通用的性能优化，如图片懒加载；
* 使用 SSR ；

## Vue3 

**Vue 3 升级内容：**

* 全部用 ts 重写（响应式、vdom、模版编译等）
* 性能提升，代码量减少
* 会调整部分 API

Vue 2.x 马上就要过时了吗？

* Vue 3 从正式发布到推广开来，还需要一段时间；
* Vue 2.x 应用范围非常广，有大量项目需要维护、升级；
* Proxy 存在浏览器兼容性问题，且不能 polyfill ；

### 1. Proxy 实现响应式

**Object.defineProperty 的缺点：**

* 深度监听需要一次性递归；
* 无法监听新增属性、删除属性（Vue.set、Vue.delete）；
* 无法原生监听数组，需要特殊处理

#### 1.1 基本使用

```javascript
const data = {
  name: 'zhangsan',
  age: 20,
}

const proxyData = new Proxy(data, {
  get(target, key, receiver) {
    const result = Reflect.get(target, key, receiver)
    console.log('get', key)
    return result	// 返回结果
  }
  set(target, key, val, receiver) {
    const result = Reflect.set(target, key, val, receiver)
    console.log('set', key, val)
    return result	// 是否设置成功
  }
  deleteProperty(target, key) {
    const result = Reflect.deleteProperty(target, key)
    console.log('delete property', key)
    return result	// 是否删除成功
  }
})
```

#### 1.2 Reflect

* 和 Proxy 能力一一对应
* 规范化、标准化、函数式
* 替代掉 Object 上的工具函数

#### 1.3 实现响应式

```javascript
// 创建响应式
function reactive(target = {}) {
  if (typeof target !== 'object' || target == null) {
    // 不是对象或数组，则返回
    return target
  }
  
  // 代理配置
  const proxyConf = {
    get(target, key, receiver) {
      const ownKeys = Reflect.ownKeys(target)
      if (ownKeys.includes(key)) {
        console.log('get', key)	// 监听
      }
      const result = Reflect.get(target, key, receiver)
      // 深度监听
      return reactive(result)
    }
    
    set(target, key, val, receiver) {
      // 重复的数据，不处理
      if (val === target[key]) {
        return true
      }
      const ownKeys = Reflect.ownKeys(target)
      if (ownKeys.includes(key)) {
        console.log('已有的 key', key)
      } else {
        console.log('新增的 key', key)
      }
      const result = Reflect.set(target, key, val, receiver)
      console.log('set', key, val)
      return result	// 是否设置成功
    }
    
    deleteProperty(target, key) {
      const result = Reflect.deleteProperty(target, key)
      console.log('delete property', key)
      return result	// 是否删除成功
    }
  }
  
  // 生成代理对象
  return new Proxy(target, proxyConf)
}

// 测试数据
const data = {
  name: 'zhangsan',
  age: 20,
  info: {
    city: 'beijing'
  }
}

const proxyData = reactive(data)
```

**proxy 实现响应式：** 

* 深度监听，性能更好；
* 可监听新增、删除属性；
* 可监听数组变化；

## React 基本用法

函数式编程：

* 一种编程范式，概念比较多
* 纯函数
* 不可变值

### 1. JSX 基本使用

#### 1.1 变量、表达式

#### 1.2 class、style

#### 1.3 子元素和组件

### 2. 条件判断

#### 2.1 if else

#### 2.2 三元表达式

#### 2.3 逻辑运算符 &&  ||

### 3. 列表渲染

#### 3.1 map

#### 3.2 key

### 4. 事件

#### 4.1 bind this

```react
constructor() {
  this.state = {
    name: 'zhangsan'
  }
  this.clickHandler1 = this.clickHandler1.bind(this)
}

clickHandler1() {
  // this 默认指向 undefined
  this.setState({
    name: 'lisi'
  })
}

// 静态方法，this 指向当前实例
clickHnadler2 = () => {
  this.setState({
    name: 'lisi'
  })
}

render() {
  // this - 使用 bind
  return <p onClick={this.clickHandler1}>
    {this.state.name}
  </p>
  
  // this - 静态方法
  return <p onClick={this.clickHandler2}>
    {this.state.name}
  </p>
}
```

#### 4.2 关于 event 参数

```react
clickHandle3 = (event) => {
  event.preventDefault()	// 阻止默认行为
  event.stopPropagation()	// 阻止冒泡
  console.log('target', event.target)	// 指向当前元素，即当前元素触发
  console.log('curret target', event.currentTarget)	// 指向当前元素，假象！！！
  
  // 注意，event 其实是 React 封装的，可以看 __proto__.constructor 是 SyntheticEvent
  console.log('event', event)	// 不是原生的 Event，原生的 MouseEvent
  console.log('event.__proto__.constructor', event.__proto__.constructor)
  
  // 原生 event 如下。其__proto__.constructor 是 MouseEvent
  console.log('nativeEvent', event.nativeEvent)
  console.log('nativeEvent target', event.nativeEvent.target)	// 指向当前元素
  console.log('nativeEvent current target', event.nativeEvent.currentTarget)	// 指向 document ！！！
  
  // 1. event 是 SyntheticEvent ，模拟出来 DOM 事件所有能力
  // 2. event.nativeEvent 是原生事件对象
  // 3. 所有的事件，都被挂载到 document 上
  // 4. 和 DOM 事件不一样，和 Vue 事件也不一样
}
```

#### 4.3 传递自定义参数

```javascript
clickHandle4 = (id, title, event) => {
  console.log(id, title)
  console.log('event', event)	// 最后追加一个参数，即可接受 Event
}
```

### 5. 表单

#### 5.1 受控组件

```react
return (
  <div>
    <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for 属性*/}
    <input id="inputName" value={this.state.name} onChange={(e) => {
        this.setState({
          name: e.target.value
        })
      }} />
  </div>
)
```

#### 5.2 input、textarea、select 用 value

```react
<textarea value={this.state.info} onChange={(e) => {
    this.setState({
      info: e.target.value
    })
  }}>
</textarea>
```

```react
<select value={this.state.city} onChange={(e) => {
    this.setState({
      city: e.target.value
    })
  }}>
  <option value="beijing">北京</option>
  <option value="shanghai">上海</option>
  <option value="shenzhen">深圳</option>
</select>
```

#### 5.3 checkbox、radio 用 checked

```react
<input type="checkbox" checked={this.state.flag} onChange={(e) => {
  this.setState({
    flag: e.target.value
  })
 }} />
```

```react
<imput 
  type="radio"
  name="gender"
  value="male"
  checked={this.state.gender === 'male'}
  onChange((e) => {
    this.setState({
      gender: e.target.value
    })
  })
/>
<imput 
  type="radio"
  name="gender"
  value="female"
  checked={this.state.gender === 'female'}
  onChange((e) => {
    this.setState({
      gender: e.target.value
    })
  })
/>
```

### 6. 组件使用

#### 6.1 props 传递数据

#### 6.2 props 传递函数

#### 6.3 props 类型检查

### 7. setState

#### 7.1 不可变值

```javascript
// 不要直接修改 state，使用不可变值
this.state.count++	// 错误
this.setState({
  count: this.state.count + 1
})
```

```javascript
// 不可变值（函数式编程，纯函数）- 数组
const list5Copy = this.state.list5.slice()
list5Copy.splice(2, 0, 'a')	// 中间插入/删除
this.setState({
  list1: this.state.list1.concat(100),	// 追加
  list2: [...this.state.list2, 100],	// 追加
  list3: this.state.list3.slice(0, 3),	// 截取
  list4: this.state.list4.filter(item => item > 100), 	// 筛选
  list5: list5Copy	// 其他操作
})
// 注意，不能直接对 this.state.list 进行 push、pop、splice 等，这样违反不可变值
```

```javascript
// 不可变值 - 对象
this.setState({
  obj1: Object.assign({}, this.state.obj1, {a: 100}),
  obj2: {...this.state.obj2, a: 100}
})
// 注意：不能直接对 this.state.obj 进行属性设置，这样违反不可变值
```

#### 7.2 可能是异步更新

```javascript
// 作为普通函数调用
this.setState({
  count: this.state.count + 1
}, () => {
  console.log('', this.state.count)	// 回调函数内，可以拿到最新值
})
console.log('count', this.state.count)	// 异步，拿不到最新值
```

```javascript
// setTimeout 中 setState 是同步的
setTimeout(() => {
  this.setState({
    count: this.state.count + 1
  })
  console.log('count in setTimeout', this.state.count)
}, 0)
```

```javascript
// 自定义的 DOM 事件，setState 是同步的
bodyClickHandler = () => {
  this.setState({
    count: this.state.count + 1
  })
  console.log('count in body event', this.state.count)
}
componentDidMount() {
  // 自定义的 DOM 事件
  document.boby.addEventListener('click', this.bodyClickHandler)
}
componnetWillUnmount() {
  // 及时销毁自定义 DOM 事件
  document.body.removeEventListener('click', this.bodyClickHandler)
}
```

#### 7.3 可能会被合并

```javascript
// state 异步更新的话，更新前会被合并
// 传入对象，会被合并（ 类似 Object.assign ）
this.setState({
  count: this.state.count + 1
})
this.setState({
  count: this.state.count + 1
})
this.setState({
  count: this.state.count + 1
})
// 执行结果只一次 +1
```

```javascript
// 传入函数，不会被合并，执行结果 +3
this.setState((prevState, props) => {
  return {
    count: prevState.count + 1
  }
})
this.setState((prevState, props) => {
  return {
    count: prevState.count + 1
  }
})
this.setState((prevState, props) => {
  return {
    count: prevState.count + 1
  }
})
```

### 8. React 生命周期

[https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/]()

**React version 16.3：**

![image-20210207165515515](https://tva1.sinaimg.cn/large/008eGmZEgy1gnf2n9fsi3j31al0u0jxy.jpg)

**React version >= 16.4：**

![image-20210207165700448](https://tva1.sinaimg.cn/large/008eGmZEgy1gnf2p173s6j31ag0u0dme.jpg)

### 8.1 单组件生命周期

### 8.2 父子组件生命周期（和 Vue 的一样）

## React 高级特性

### 1. 函数组件

* 纯函数，输入 props ，输出 JSX ；
* 没有实例，没有生命周期，没有 state ；
* 不能扩展其他方法；

```react
// class 组件
class List extends React.Component {
  constructor(props) {
    super(props)
  }
  
  render() {
    const { list } = this.props
    
    return (
      <ul>
        {list.map(item) => (
          <li key={item.id}>
            <span>{item.title}</span>
          </li>
        )}
      </ul>
    )
  }
}
```

```react
// 函数组件
function List(props) {
  const { list } = this.props
  
  return (
    <ul>
      {list.map(item) => (
        <li key={item.id}>
          <span>{item.title}</span>
        </li>
      )}
    </ul>
  )
}
```

### 2. 非受控组件

* `ref`
* `defaultValue`、`defaultChecked`
* 手动操作 DOM 元素

```react
class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      name: 'shuangyue',
      flag: true,
    }
    this.nameInputRef = React.createRef()
    this.fileInputRef = React.createRef()
  }
  
  render() {
    return (
      <>
        {/* 使用 defaultValue 而不是 value，使用 ref */}
        <input defaultValue={this.state.name} ref={this.nameInputRef} />
        {/* state 并不会随着改变 */}
        <span>state.name: {this.state.name}</span>
        <button onClick={this.alertName}>alert name</button>
        <hr />
        <input type="file" ref={this.fileInputRef} />
        <button onClick={this.alertFile}>alert file</button>
      </>
    )
  }
  
  alertName = () => {
    const elem = this.nameInputRef.current
    alert(elem.value)
  }
  alertFile = () => {
    const elem = this.fileInputRef.current
    alert(elem.files[0].name)
  }
}
```

**使用场景：**

* 必须手动操作 DOM 元素，setState 实现不了；
* 文件上传 `<input type='file' />`；
* 某些富文本编辑器，需要传入 DOM 元素；

**受控组件 VS 非受控组件：**

* 优先使用受控组件，符合 React 设计原则；
* 必须操作 DOM 时，再使用非受控组件；

### 3. Portals

* 组件默认会按照既定层次嵌套渲染
* 如何让组件渲染到父组件以外？

```react
render() {
  // 使用 Portal 渲染到 body 上。
  // fixed 元素要放在 body 上，有更好的浏览器兼容性
  return ReactDom.creatPortal(
    <div className="modal">{this.props.children}</div>,
    document.body	// DOM 节点
  )
}
```

**Portals 使用场景：**

* `overflow:hidden`
* 父组件 `z-index` 值太小
* fixed 需要放在 body 第一层级

### 4. context

* 公共信息（语言、主题）如何传递给每个组件？
* 用 props 太繁琐
* 用 redux 小题大做

```react
// 创建 Context 填入默认值（任何一个 js 变量）
const ThemeContext = React.createContext('light')

class App extends React.Componnet {
  constructor(props) {
    super(props)
    this.state = {
      theme: 'light'
    }
  }
  
  render() {
    return (
      <ThemeContext.Provider value={this.state.theme}>
        <ThemeButton />
        <ThemeLink />
        <button onClick={this.changeTheme}>change theme</button>
      </ThemeContext.Provider>
    )
  }
  
  changeTheme = () => {
    this.setState({
      theme: this.state.theme === 'light' ? 'dark' : 'light'
    })
  }
}
```

```react
// 底层组件 - class 组件
class ThemedButton extends React.Component {
  /* static contextType = ThemeContext	// 也可以用此方式代替 ThemedButton.contextType = ThemeContext */
  
  render() {
    const theme = this.context	// React 会往上找到最近的 theme context
    return (
      <div>
        <p>button's theme is {theme}</p>
      </div>
    )
  }
}
ThemedButton.contextType = ThemeContext	// 指定 contextType 读取当前 ThemeContext 值
```

```react
// 底层组件 - 函数组件
function ThemeLink(props) {
  // 函数式组件可以使用 Consumer
  return (
    <ThemeContext.Consumer>
      {value => <p>link's theme is {value}</p>}
    </ThemeContext.Consumer>
  )
}
```

### 5. 异步组件

* import()
* React.lazy
* React.Suspense

```react
import React from 'react'
const ContextDemo = React.lazy(() => import('./ContextDemo'))

class App extends React.Component {
  constructor(props) {
    super(props)
  }
  
  render() {
    return (
      <div>
        <p>引入一个动态组件</p>
        <React.Suspense fallback={<div>loading...</div>}>
          <ContextDemo />
        </React.Suspense>
      </div>
    )
  }
}

export default App
```

### 6. 性能优化

#### 6.1 shouldComponentUpdate（简称 SCU）

```react
shouleComponentUpdate(nextProps, nextState) {
  if (nextState.count !== this.state.count) {
    return true	// 可以渲染
  }
  return false	// 不重复渲染
}
// React 默认：父组件有更新，子组件则无条件也更新！！！
// SCU 一定要每次都用吗？
// * 需要的时候才优化（框架不考虑具体实现细节）
// * 对 state 值处理时，要遵循不可变值
// * 对 nextState 要做前后对比
```

```react
shouldComponentUpdate(nextProps, nextState) {
  // _.isEqual 做对象或者数组的深度比较（一次性递归到底）
  if(_.isEqual(nextProps.list, this.props.list)) {
    return false	// 相等，则不重复渲染
  }
  return true	//不相等，则渲染
}
// 必须配合“不可变值”一起使用
```

**SCU 使用总结：**

* SCU 默认返回 true ，即 React 默认重新渲染所有子组件；
* 必须配合“不可变值”一起使用；
* 可先不用 SCU ，有性能问题时考虑使用；

#### 6.2 PureComponent 和 React.memo

* `PureComponent`，SCU 中实现了浅比较
* memo，函数组件中的 PureComponent
* 浅比较已使用大部分情况（尽量不要做深度比较）

```react
// PureComponent class表示方法
class List extends React.PureComponent {
  constructor(props) {
    super(props)
  }
  
  render() {
    ...
  }
}
```

```react
// React.memo 函数表示方法
function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, next) {
  /*
    如果把 nextProps 传入 render 方法的返回结果与 
    将 pervProps 传入 render 方法的返回结果一致则返回 true,
    否则返回 false
  */
}
export default React.memo(MyComponent, areEqual)
```

#### 6.3 不可变值 immutable.js

* 彻底拥抱“不可变值”；
* 基于共享数据（不是深拷贝），速度好；
* 有一定学习和迁移成本，按需使用；

```javascript
const map1 = Immutable.Map({ a: 1, b: 2, c: 3 })
const map2 = map1.set('b', 50)
map1.get('b')	// 2
map2.get('b')	// 50
```

### 7. 高阶组件 HOC

**关于组件公共逻辑的抽离：**

* mixin ，已被 React 弃用
* 高阶组件 HOC
* Render Props

**高阶组件-基本使用：**

```react
// 高阶组件不是一种功能，而是一种模式
const HOCFactory = (Component) => {
  class HOC extends React.Component {
    render() {
      return <Component {...this.props} />	// 返回拼装的结果
    }
  }
  return HOC
}
const EnhancedComponent1 = HOCFactory(WrappedComponent1)
const EnhancedComponent2 = HOCFactory(WrappedComponent2)
```

**高阶组件实例：**

```react
const withMouse = (Component) => {
  class withMouseComponent extends React.Component {
    constructor(props) {
      super(props)
      this.state = { x: 0, y: 0 }
    }
    
    handleMouseMove = (event) => {
      this.setState({
        x: event.clientX,
        y: event.clientY
      })
    }
    
    render() {
      return (
        <div onMouseMove={this.handleMouseMove}>
          {/* 1. 透传所有 props； 2. 增加 mouse 属性 */}
          <Component {...this.props} mouse={this.state} />
        </div>
      )
    }
  }
  return withMouseComponent
}

const App = (props) => {
  const { x, y } = props.mouse	// 接受 mouse 属性
  return (
    <div style={{ height: '500px'}}>
      <h1>The mouse position is ({x}, {y})</h1>
    </div>
  )
}

export default withMouse(App)	// 返回高阶函数
```



**redux connect 是高阶组件：**

```react
import { connect } from 'react-redux'

// connect 是高阶组件
const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)
```

**connect 源码：**

```react
export const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => {
  class Connect extends Component {
    constructor() {
      super()
      this.state = {
        allProps: {}
      }
    }
    /* 中间省略 N 行代码 */
    render() {
      return <WrappedComponent {...this.state.allProps} />
    }
  }
  return Connect
}
```

### 8. Render Props

```react
/**
* Render Props 的核心思想：
* 通过一个函数将 class 组件的 state 作为 props 传递给纯函数组件
*/
class Factory extends React.Component {
  constructor() {
    this.state = {
    	/* state 即多个组件的公共逻辑的数据 */
    }
  }
  
  /* 修改 state */
  
  render() {
    return (
      <div>{this.props.render(this.state)}</div>
    )
  }
}


const App = () => {
  <Factory render={
      /* render 是一个函数组件 */
    (props) => <p>{props.a} {props.b} ...</p>
  } />
}
```

**HOC vs Render Props：**

* HOC：模式简单，但会增加组件层级；
* Render Props：代码简洁，，学习成本较高；
* 按需使用；



## Redux 使用

### 1. 基本概念

* store state
* action
* reducer

### 2. 单项数据流

* dispatch(action)
* reducer -> newState
* subscribe 触发通知

### 3. react-redux

* `<Provider>` connect
* connect
* mapStateToProps、mapDispatchToProps

### 4. 异步 action

* redux-thunk
* redux-promise
* redux-saga

```javascript
// 同步 action
export const addTodo = text => {
  // 返回 action 对象
  return {
    type: 'ADD_TODO',
    id: nextTodoId++,
    text
  }
}
```

```javascript
// 异步 action
export const addTodoAsync = text => {
  // 返回函数，其中有 dispatch 参数
  return () => {
    // ajax 异步获取数据
    fetch(url).then(res => {
      // 执行异步 action
      dispatch(addTodo(res.text))
    })
  }
}
```

### 5. 中间件

![image-20210208141938360](https://tva1.sinaimg.cn/large/008eGmZEgy1gng3rm51x3j31jm0nyh3k.jpg)



![image-20210208142644988](https://tva1.sinaimg.cn/large/008eGmZEgy1gng3z02pojj30po0r0jzm.jpg)



## React-router 

### 1. 路由模式

* hash 模式（默认），如 http://abc/#/user/10
* H5 history 模式，如 http://abc.com/user/20
* 后者需要 server 端支持，因此无特殊需求可选择前者

![image-20210208144134236](https://tva1.sinaimg.cn/large/008eGmZEgy1gng4efgnljj314c0m87hj.jpg)

### 2. 路由配置

![image-20210208144214847](https://tva1.sinaimg.cn/large/008eGmZEgy1gng4f4lj8bj318e0lq4dm.jpg)

![image-20210208144240726](https://tva1.sinaimg.cn/large/008eGmZEgy1gng4fkeuvaj310c0m8tmy.jpg)

## React 原理

### 1. 回顾 vdom 和 diff

#### 1.1 vdom

![image-20210208151430725](https://tva1.sinaimg.cn/large/008eGmZEgy1gng5cp2ar2j318m0rk46r.jpg)

#### 1.2 diff

* 只比较同一层级，不跨级比较；
* tag 不相同，则直接删掉重建，不再深度比较；
* tag 和 key ，两者都相同，则认为是相同节点，不再深度比较；

### 2. JSX 本质

* React.createElement 即 h函数，返回 vnode
* 第一个参数，可能是组件，也可能是 html tag
* 组件名，首字母必须大写（React 规定）

![image-20210208152039815](https://tva1.sinaimg.cn/large/008eGmZEgy1gng5j3go9mj30oa0ic7cn.jpg)

### 3. 合成事件

* 所有事件挂载到 document 上；
* event 不是原生的，是 SyntheticEvent 合成事件对象；
* 和 Vue 事件不同，和 DOM 事件也不同；

![image-20210208155946815](https://tva1.sinaimg.cn/large/008eGmZEgy1gng6nu975pj30pm0dgdkm.jpg)

**合成事件 - 图示：**

* 更好的兼容性和跨平台；
* 载到 document ，减少内存消耗，避免频繁解绑；
* 方便事件的统一管理（如事务机制）；

### 4. setState 和 batchUpdate

* 有时异步（普通使用），有时同步（setTimeout、DOM 事件）
* 有时合并（对象形式），有时不合并（函数形式）

#### 4.1 setState 主流程

![noname](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7f0z9e2j30jy0f6whj.jpg)

![image-20210208162610281](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7f9c45zj30q60cmn51.jpg)

#### 4.2 batchUpdate 机制

**setState 异步还是同步？**

* setState 无所谓异步还是同步
* 看是否能命中 batchUpdate 机制
* 判断 isBatchingUpdates

![image-20210208163840818](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7sa41a2j30py0ci7bw.jpg)

![image-20210208162921043](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7ikdxlaj30zu0iiqfs.jpg)

![image-20210208162937572](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7iuuoc3j30us0j8n6y.jpg)

**哪些能命中 batchUpdate 机制：**

* 生命周期（和它调用的函数）
* React 中注册的事件（和它调用的函数）
* React 可以“管理”的入口

**哪些不能命中 batchUpdate 机制：**

* setTimeOut、setInterval 等（和它调用的函数）
* 自定义的 DOM 事件（和它调用的函数）
* React “管不到” 的入口

#### 4.3 React 事务机制

![image-20210208164749616](https://tva1.sinaimg.cn/large/008eGmZEgy1gng81sdcilj30e00feq74.jpg)

![image-20210208164759847](https://tva1.sinaimg.cn/large/008eGmZEgy1gng81yth1pj30l60fo0y0.jpg)

![image-20210208164903652](https://tva1.sinaimg.cn/large/008eGmZEgy1gng832m5fzj30ou0c8wiv.jpg)

### 5. React 组件渲染和更新的过程

* JSX 如何渲染为页面
*  setState 之后如何更新页面

#### 5.1 JSX 本质和 vdom

* JSX 即 createElement 函数
* 执行生成 vnode
* patch(elem, vnode) 和 patch(vnode, newVnode)

#### 5.2 组件渲染过程

* props state
* render() 生成 vnode
* patch(elem, vnode)

#### 5.3 组件更新过程

* setState(newState)  --> dirtyComponents（可能有子组件）
* render() 生成 newVnode
* patch(vnode, newVnode)

#### 5.4 更新的两个阶段

上述的 patch 被拆分为两个阶段：

* reconciliation  阶段 - 执行 diff 算法，纯 JS 计算
* commit 阶段 - 将 diff 结果渲染 DOM

**可能会有性能问题：**

* JS 是单线程，且和 DOM 渲染共用一个线程；
* 当组件足够复杂，组件更新时计算和渲染的压力都很大；
* 同时再有 DOM 操作需求（动画，鼠标拖拽等），就有可能造成页面卡顿；
* 解决方案 - fiber

### 6. React-fiber 如何优化性能

* 将 reconciliation 阶段进行任务拆分（commit 无法拆分）
* DOM 需要渲染时暂停，空闲时恢复
* window.requestIdleCallback（监听 DOM 需要渲染时的 API）





















