## Vue 组件使用

### 1. props 和 $emit

### 2. 组件间通讯-自定义事件

### 3. 组件生命周期

![vue Lifecycle](https://tva1.sinaimg.cn/large/008eGmZEgy1gnacneg4xej30u023zt9s.jpg)

## Vue 高级特性

### 1. 自定义 v-model

```vue
<template>
	<input type="text" :value="text1" @input="$emit('change1', $event.target.value)" />
<!-- 
  1. 上面的 input 使用了 :value 而不是 v-model
  2. 上面的 change1 和 model.event1 要对应起来
  3. text1 属性对应起来
-->
</template>
<script>
export default {
  model: {
    prop: 'text1',
    event: 'change1'
  },
  props: {
    text1: String,
    default: () => ''
  }
}
</script>
```

### 2. $nextTick

* Vue 是异步渲染（原理部分会详细讲解）；
* data 改变之后，DOM 不会立刻渲染；
* $nextTick 会在 DOM 渲染之后被触发，以获取最新 DOM 节点；

```vue
<template>
  <div id="app">
    <ul ref="uli">
      <li v-for="(item, index) in list" :key="index">
        {{item}}
  		</li>
  	</ul>
    <button>添加一项</button>
  </div>
</template>
<script>
export defualt {
	name: 'app',
  data: () => ({
    list: ['a', 'b', 'c']
  }),
  methods: {
    addItem() {
      this.list.push(`${Date.now()}`)
      this.list.push(`${Date.now()}`)
      this.list.push(`${Date.now()}`)
      
      // 1. 异步渲染，$nextTick 待 DOM 渲染完再回调
      // 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次
      this.$nextTick(() => {
        const ulElem = this.$refs.uli
        console.log(ulElem.childNodes.length)
      })
    }
  }
}
</script>
```

### 3. slot

* 基本使用

* 作用域插槽

* 具名插槽

  ```vue
  <!-- NamedSolt 组件 -->
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  
  <!-- parent 组件 -->
  <NamedSlot>
    <template v-slot:header>
      <h1>将插入到 header slot 中</h1>
    </template>
    <p>将插入到 main slot 中，即为命名的 slot</p>
    <template v-slot:footer>
    <p>将插入到 footer slot 中</p>
    </template>
  </NameSlot>
  ```
  

### 4. 动态组件

* 用法：`<component :is="component-name" />`
* 需要根据数据，动态渲染的场景。即组件类型不确定。

### 5. 异步组件

* `import()`函数
* 按需加载，异步加载大组件

```vue
<srcipt>
  components: {
    FormDemo: () => import('../Baseuse/FormDemo.vue')
  }
</script>
```

### 6. Keep-alive

* 缓存组件
* 频繁切换，不需要重复渲染
* Vue 常见性能优化

```vue
<template>
  <div>
    <button @click="changeState('A')">A</button>
    <button @click="changeState('B')">B</button>
    <button @click="changeState('C')">C</button>
    <keep-alive>
      <KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
    </keep-alive>
  </div>
</template>
```

### 7. mixin

* 多个组件有相同的逻辑，抽离出来；
* mixin 并不是完美的解决方案，会有一些问题；
* Vue 3 提出的 Composition API 旨在解决这些问题；

```vue
<template>
  <div>
    <p>{{name}}{{major}}{{city}}</p>
    <button @click="showName">显示姓名</button>
  </div>
</template>

<script>
import myMixin from './mixin'
export default {
  mixins: [myMixin],	// 可以添加多个，会自动合并起来
  data: () => ({
    name: 'shuangyue',
    major: 'web 前端'
  }),
  mounted() {
    console.log('component mounted', this.name)
  },
  methods: {},
}
</script>
```

```vue
<!-- mixin -->
<script>
export default {
  data: () => ({
    city: 'beijing'
  }),
  mounted() {
    console.log('mixin mounted', this.name)
  },
  methods: {
    showName() {
      console.log(this.name)
    }
  }
}
</script>
```

**mixin 的问题：**

* 变量来源不明确，不利于阅读；
* 多 mixin 可能会造成命名冲突；
* mixin 和组件可能出现多对多的关系，复杂度较高；



## Vuex 使用

![vuex](https://tva1.sinaimg.cn/large/008eGmZEgy1gnb9wfuqvcj30jh0fbwef.jpg)


### 1. Vuex 基本概念

#### 1.1 state

#### 1.2 getters

#### 1.3 mutation

#### 1.4 action

### 2. 用于 Vue 组件

#### 2.1 dispatch

#### 2.2 commit

#### 2.3 mapState

#### 2.4 mapGetters

#### 2.5 mapMutations

#### 2.6 mapActions

## Vue-router 使用

### 1. 路由模式（hash、H5 history）

* hash 模式（默认），如 `http://abc.com/#/user/10`
* H5 history 模式，如`http://abc.com/user/20`
* 后者需要 server 端支持，因此无特殊需求可选择前者

### 2. 路由配置（动态路由、懒加载）

```javascript
const router = new VueRouter({
  mode: 'history',	// 使用 H5 history 模式
  routes: [...]
})
```

**动态路由配置：**

```javascript
const user = {
  // 获取参数如 10 20
  template: '<div>User {{ $route.params.id }}</div>'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头，能命中 `/user/10`、`/user/20` 等格式的路由
    { path: '/user/:id', component: User }
  ]
})
```

**路由-懒加载：**

```javascript
export default new VueRouter({
  routes: [
    {
      path: '/',
      component: () => import('../components/Navigator')
    },
    {
      path: '/feedback',
      component: () => import('../components/FeedBack')
    }
  ]
})
```

## Vue 原理

### 1. 组件化和 MVVM

#### 1.1 组件化基础

* “很久以前”就有组件化

  * asp、jsp、php 已经有组件化了
  * nodejs 中也有类似的组件化

  ![CC2977CB-DF53-427A-A217-15B1B2F388FB_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjvkdv6ej31n80hz42g.jpg)

  ![E13C2DB3-C978-4AAA-BC63-31DA5EC0D908_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjvouc1vj31m80t50x4.jpg)

* 数据驱动视图（MVVM，setState）

  * 传统组件，只是静态渲染，更新还要依赖与操作 DOM；

  * 数据驱动视图 - Vue MVVM

    ![Vue MVVM](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk1zls4pj318g0nmwfe.jpg)

  * 数据驱动视图 - React setState

### 2. 响应式原理

* 组件 data 的数据一旦变化，立刻触发视图的更新；
* 实现数据驱动视图的第一步；

![E2A1FE7C-4AD9-4750-BA02-32EB9FB15FA4_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk88omg5j31o30pbq6h.jpg)

实现响应式：

* 核心 API - Object.defineProperty
* 如何实现响应式，代码演示
* Object.defineProperty 的一些缺点（Vue3.0 启用 Proxy）

Proxy 有兼容性问题：

* Proxy 兼容性不好，且无法 polyfill
* Vue2.x 还会存在一段时间，所以都得学

**Object.defineProperty 基本用法：**

```javascript
const data = {}
const name = 'zhangsan'
Object.defineProperty(data, 'name', {
  get: function() {
    console.log('get')
    return name
  },
  set: function(newVal) {
    console.log('set')
    name = newVal
  }
})

// 测试
console.log(data.name)	// get zhangsan
data.name = 'list'	// set
```

* 监听对象，监听数组
* 复杂对象，深度监听
* Object.defineProperty 几个缺点
  * 深度监听，需要递归到底，一次性计算量大；
  * 无法监听新增属性/删除属性（Vue.set / Vue.delete）
  * 无法原声监听数组，需要特殊处理

```javascript

```

### 3. 虚拟 DOM （Virtual DOM）和 diff 算法

* vdom 是实现 vue 和 React 的重要基石；
* diff 算法是 vdom 中最核心、最关键的部分；

> * DOM 操作非常耗费性能
> * 以前用 jQuery，可以自行控制 DOM 操作的时机，手动调整
> * Vue 和 React 是数据驱动视图，如何有效控制 DOM 操作？
>   * 有了一定复杂度，想减少计算次数比较难
>   * 能不能把计算，更多的转移为 JS 计算？因为 JS 执行速度很快
>   * vdom - 用 JS 模拟 DOM 结构，计算出最小的变更，操作 DOM

![IMG_2100](https://tva1.sinaimg.cn/large/008eGmZEgy1gnch5440hbj31dt0u0wp7.jpg)

**通过 snabbdom 学习 vdom**

* 简洁强大的 vdom 库，易学易用
* Vue 参考它实现的 vdim 和 diff
* [https://github.com/snabbdom/snabbdom](snabbdom)

**diff 算法**

* diff 算法是 vdom 中最核心、最关键的部分；
* diff 算法能在日常使用 Vue、React 中体现出来（如 key）

**diff 算法概述**

* diff 即对比，是一个广泛的概念，如 Linux diff 命令、git diff 等
* 两个 js 对象也可以做 diff，如 [https://github.com/cujojs/jiff]()
* 两颗树做 diff，如这里的 vdom diff

![IMG_2101](https://tva1.sinaimg.cn/large/008eGmZEgy1gnchp36djej31fc0oytn3.jpg)

**树 diff 的时间复杂度 O(n^3)**

* 第一，遍历 tree1
* 第二，遍历 tree2
* 第三，排序

如 1000 个节点，要计算 1 亿次，算法不可用。

**优化时间复杂度到 O(n)**

* 只比较同一层级，不跨级比较；
* tag 不相同，则直接删掉重建，不再深度比较；
* tag 和 key，两者都相同，则认为是相同节点，不再深度比较；

![86A6566A-4876-4E51-839C-AF0924368D37_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gnchz98sg6j30ya0hp76m.jpg)

![A8084E13-3FAC-4632-AD4E-57746605006D_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gnci01x27kj310i0gmjte.jpg)

**vdom 和 diff 总结：**

* 细节不重要，updateChildren 的过程也不重要，不要讲究；
* vdom 核心概念很重要：h、vnode、patch、diff、key 等；
* vdom 存在的价值更加重要：数据驱动视图，控制 DOM 操作；

### 4. 模版编译

* 模版是 Vue 开发中最常用的部分，即与使用相关联的原理
* 它不是 html，有指令、插值、JS 表达式，到底是什么？
* 面试不会直接问，但会通过“组件渲染和更新过程”考察

#### 4.1 前置知识：JS 的 with 语法

* 改变`{}`内自由变量的查找规则，当做 obj 属性来查找；
* 如果找不到匹配的 obj 属性，就会报错；
* with 要慎用，它打破了作用域的规则，易读性变差；

![image-20210206190727267](https://tva1.sinaimg.cn/large/008eGmZEgy1gne0ui5fi3j31js0ia4d9.jpg)

#### 4.2 `vue-template-complier` 将模版编译为 render 函数

* 模版不是 html ，有指令、插值、JS 表达式，能实验判断、循环♻️；
* html 是标签语言，只有 JS 才能实现判断、循环（图灵完备）
* 因此，模版一定是转换为某种 JS 代码，即编译模版；

#### 4.3 执行 render 函数生成 vnode

* 模版编译为 render 函数，执行 render 函数返回 vnode；
* 基于 vnode 再执行 patch 和 diff （后面会讲）；
* 使用 webpack vue-loader ，会在开发环境下编译模版（重要）；

![image-20210206193309521](https://tva1.sinaimg.cn/large/008eGmZEgy1gne1l76ov1j31as0tok59.jpg)

> * 讲完模板编译，再讲这个 render，就比较好理解了；
> * 在有些复杂情况中，不能用 template，可以考虑用 render；
> * React 一直都用 render（没有模板），和这里一样；

### 5. 组件渲染过程

#### 5.1 初次渲染过程

* 解析模板为 render 函数（或在开发环境已完成，vue-loader）
* 触发响应式，监听 data 属性 getter、setter
* 执行 render 函数，生成 vnode，patch(elem, vnode)

![image-20210206195107914](https://tva1.sinaimg.cn/large/008eGmZEgy1gne23wos8xj31ka0s8dup.jpg)

#### 5.2 更新过程

* 修改 data，触发 setter（此前在 getter 中已被监听）；
* 重新执行 render 函数，生成 newVnode；
* patch(vnode, newVnode)

![image-20210206195405733](https://tva1.sinaimg.cn/large/008eGmZEgy1gne26z65gxj311k0ru7en.jpg)

#### 5.3 异步渲染

* 回顾 `$nextTick`；
* 汇总 data 的修改，一次性更新视图；
* 减少 DOM 操作次数，提高性能；

![image-20210206200139144](https://tva1.sinaimg.cn/large/008eGmZEgy1gne2eus8ufj30ng0e044t.jpg)

### 6. 前端路由

![image-20210206211021450](https://tva1.sinaimg.cn/large/008eGmZEgy1gne4ecq3dgj31jq0o0e0f.jpg)

#### 6.1 hash 的特点

* hash 变化会触发网页跳转，即浏览器的前进、后退；
* hash 变化不会刷新页面，SPA 必需的特点；
* hash 永远不会提交到 server 端（前端自生自灭）；

```javascript
window.onhashchange = (event) => {
  console.log('old url', event.oldURL)
  console.log('new url', event.newURL)
  console.log('hash', location.hash)
}

// 页面初次加载、获取 hash
document.addEventListener('DOMContentLoaded', () => {
  console.log('hash:', location.hash)
})

// JS 修改 URL
document.getElementById('btn1').addEventListener('click', {
  location.hash = '#/user'
})
```

#### 6.2 H5 history

* 用 URL 规范的路由，但跳转时不刷新页面；
* `history.pushState`
* `window.onpopstate`

## Vue 真题

### 1. `v-show` 和 `v-if` 的区别？

* v-show 通过 CSS display 控制显示和隐藏；
* v-if 组件是真正的渲染和销毁，而不是显示和隐藏；
* 频繁切换显示状态用 v-show，否则用 v-if ；

### 2. 为何在 v-for 中使用 key 属性

* 必须用 key ，且不能是 index 和 random ；
* diff 算法中通过 tag 和 key 来判断，是否是 sameNode ；
* 减少渲染次数，提升渲染性能；

### 3. 描述一下 Vue 组件生命周期（父子组件）？

* 单组件生命周期图；
* 父子组件生命周期关系；

### 4. Vue 组件如何通讯（常见）？

* 父子组件 `props` 和 `this.$emit`
* 自定义事件 `event.$no`、`event.$off`、`event.$emit`
* `Vuex`

### 5. 描述组件渲染和更新的过程？

![image-20210206215548161](https://tva1.sinaimg.cn/large/008eGmZEgy1gne5pm53spj311c0l4dni.jpg)

### 6. 双向数据绑定 v-model 的实现原理

* input 元素的 value = this.name
* 绑定 input 事件 this.name = $event.target.value
* Data 更新触发 re-render

### 7. 对 MVVM 的理解

![Vue MVVM](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk1zls4pj318g0nmwfe.jpg)

### 8. computed 有何特点

* 缓存，data 不变不会重新计算；
* 提高性能

### 9. 为何组件 data 必须是一个函数？

```javascript
export default {
  name: 'app',
  data() {
    return {
      name: 'vue'.,
      list: ['a', 'b', 'c']
    }
  },
  methods: {
    changeName() {
      this.name = 'shuangyue'
    },
    
  }
}
```

* 组件是对 Vue class 实例化；
* 组件 data 在函数作用域内可以避免变量对全局实例化属性的污染；

### 10. ajax 请求应该放在哪个生命周期

* `mounted`
* JS 是单线程的，ajax 异步获取数据；
* 放在 mounted 之前没有用，只会让逻辑更加混乱；

### 11. 如何将组件所有 props 传递给子组件？

* `$props`
* `<User v-bind="$props">`

### 12. 如何自己实现 v-model

```vue
<template>
  <input type="text" :value="text" @input="$emit('change', $event.target.value)" />
  <!-- 
    注意：
    第一，上面使用 :value 而没用 v-model
    第二，上面的 change 和 model.event 对应起来即可，名字自己该
  -->
</template>
<script>
export default {
  model: {
    prop: 'text',	// 对应到 props text
    event: 'change'
  },
  props: {
    text: String
  }
}  
</script>
```

### 13. 多个组件有相同的逻辑，如何抽离？

* `mixin`
* 以及 mixing 的一些缺点

### 14. 何时要使用异步组件？

* 加载大组件；
* 路由异步加载；

### 15. 何时需要使用 keep-alive ？

* 缓存组件，不需要重复渲染；
* 如多个静态 tab 页的切换；
* 优化性能；

### 16. 何时需要使用 beforeDestory

* 解绑自定义事件 `event.$off`；
* 清除定时器；
* 解绑自定义的 DOM 事件，如 window scroll 等；

### 17. 什么是作用域插槽？

```vue
// 子组件
<template>
  <a :href="url">
    <slot :website="website">
      {{website.subTitle}}
    </slot>
  </a>
</template>
<script>
export default {
  name: 'ScopedSlotDemo',
  props: ['url'],
  data() {
    return {
      website: {
        url: 'http://wangEditor.com/',
        title: 'wangEditor',
        subTitle: '轻量级富文本编辑器'
      }
    }
  }
}
</script>

// 父组件
<ScopedSlotDemo :url="website.url">
  <template v-slot="slotProps">
    {{ /* slotProps 名字可自定义 */ }}
    {{slotProps.website.title}}
  </template>
</ScopedSlotDemo>
```

### 18. Vuex 中 action 和 mutation 有和区别？

* `action` 中可以处理异步，`mutation`不可以；
* `mutation`做原子操作；
* `action` 可以整合多个 `mutation`；

### 19. Vue-router 常用的路由模式

* hash 默认；
* H5 history（需要服务端支持）；
* 两者比较

### 20. 如何配置 Vue-router 异步加载

```javascript
export default new VueRouter({
  routes: [
    {
      path: '/',
      component: () => import('../components/Navigator')
    },
    {
      path: '/feedback',
      component: () => import('../components/FeedBack')
    }
  ]
})
```

### 21. 请用 vnode 描述一个 DOM 结构？

```html
<div id="div1" class="container">
  <p>vdom</p>
  <ul style="font-size: 20px">
    <li>a</li>
  </ul>
</div>
```

```json
{
  tag: 'div',
  props: {
    className: 'container',
    id: 'div1'
  },
  children: [
    {
      tag: 'p',
      children: 'vdom'
    },
    {
      tag: 'ul',
      props: { style: 'font-size: 200px' },
      children: [
        {
          tag: 'li',
          children: 'a',
        }
      ]
    }
  ]
}
```

### 22. 监听 data 变化的核心 API 是什么？

* `Object.defineProperty`
* 以及深度监听、监听数组
* 有何缺点

### 23. Vue 如何监听数组变化？

* `Object.defineProperty` 不能监听数组变化；
* 重新定义原型，重写 push、pop 等方法，实现监听；
* Proxy 可以原生支持监听数组变化；

### 24. 请描述响应式原理

* 监听 data 变化；
* 组件渲染和更新的流程；

### 25. diff 算法的事件复杂度

* O(n)
* 在 O(n^3) 基础上做了一些调整

### 26. 简述 diff 算法过程

* patch(elem, vnode) 和 patch(vnode, newVnode)
* patchVnode 和 addVnodes 和 removeVnodes
* updateChildren （key 的重要性）

### 27. Vue 为何是异步渲染，$nextTick 何用？

* 异步渲染（以及合并 data 修改），以提高渲染性能；
* $nextTick 在 DOM 更新完之后，触发回调；

### 28. Vue 常用性能优化方式

* 合理使用 v-show 和 v-if ；
* 合理使用 computed ；
* v-for 时加 key，以及避免和 v-if 同时使用；
* 自定义事件、DOM 事件及时销毁；
* 合理使用异步组件；
* 合理使用 keep-alive ；
* data 层级不要太深；
* 使用 vue-loader 在开发环境做模版编译（预编译）；
* webpack 层面的优化；
* 前端通用的性能优化，如图片懒加载；
* 使用 SSR ；

## Vue3 

**Vue 3 升级内容：**

* 全部用 ts 重写（响应式、vdom、模版编译等）
* 性能提升，代码量减少
* 会调整部分 API

Vue 2.x 马上就要过时了吗？

* Vue 3 从正式发布到推广开来，还需要一段时间；
* Vue 2.x 应用范围非常广，有大量项目需要维护、升级；
* Proxy 存在浏览器兼容性问题，且不能 polyfill ；

### 1. Proxy 实现响应式

**Object.defineProperty 的缺点：**

* 深度监听需要一次性递归；
* 无法监听新增属性、删除属性（Vue.set、Vue.delete）；
* 无法原生监听数组，需要特殊处理

#### 1.1 基本使用

```javascript
const data = {
  name: 'zhangsan',
  age: 20,
}

const proxyData = new Proxy(data, {
  get(target, key, receiver) {
    const result = Reflect.get(target, key, receiver)
    console.log('get', key)
    return result	// 返回结果
  }
  set(target, key, val, receiver) {
    const result = Reflect.set(target, key, val, receiver)
    console.log('set', key, val)
    return result	// 是否设置成功
  }
  deleteProperty(target, key) {
    const result = Reflect.deleteProperty(target, key)
    console.log('delete property', key)
    return result	// 是否删除成功
  }
})
```

#### 1.2 Reflect

* 和 Proxy 能力一一对应
* 规范化、标准化、函数式
* 替代掉 Object 上的工具函数

#### 1.3 实现响应式

```javascript
// 创建响应式
function reactive(target = {}) {
  if (typeof target !== 'object' || target == null) {
    // 不是对象或数组，则返回
    return target
  }
  
  // 代理配置
  const proxyConf = {
    get(target, key, receiver) {
      const ownKeys = Reflect.ownKeys(target)
      if (ownKeys.includes(key)) {
        console.log('get', key)	// 监听
      }
      const result = Reflect.get(target, key, receiver)
      // 深度监听
      return reactive(result)
    }
    
    set(target, key, val, receiver) {
      // 重复的数据，不处理
      if (val === target[key]) {
        return true
      }
      const ownKeys = Reflect.ownKeys(target)
      if (ownKeys.includes(key)) {
        console.log('已有的 key', key)
      } else {
        console.log('新增的 key', key)
      }
      const result = Reflect.set(target, key, val, receiver)
      console.log('set', key, val)
      return result	// 是否设置成功
    }
    
    deleteProperty(target, key) {
      const result = Reflect.deleteProperty(target, key)
      console.log('delete property', key)
      return result	// 是否删除成功
    }
  }
  
  // 生成代理对象
  return new Proxy(target, proxyConf)
}

// 测试数据
const data = {
  name: 'zhangsan',
  age: 20,
  info: {
    city: 'beijing'
  }
}

const proxyData = reactive(data)
```

**proxy 实现响应式：** 

* 深度监听，性能更好；
* 可监听新增、删除属性；
* 可监听数组变化；

## React 基本用法

函数式编程：

* 一种编程范式，概念比较多
* 纯函数
* 不可变值

### 1. JSX 基本使用

#### 1.1 变量、表达式

#### 1.2 class、style

#### 1.3 子元素和组件

### 2. 条件判断

#### 2.1 if else

#### 2.2 三元表达式

#### 2.3 逻辑运算符 &&  ||

### 3. 列表渲染

#### 3.1 map

#### 3.2 key

### 4. 事件

#### 4.1 bind this

```react
constructor() {
  this.state = {
    name: 'zhangsan'
  }
  this.clickHandler1 = this.clickHandler1.bind(this)
}

clickHandler1() {
  // this 默认指向 undefined
  this.setState({
    name: 'lisi'
  })
}

// 静态方法，this 指向当前实例
clickHnadler2 = () => {
  this.setState({
    name: 'lisi'
  })
}

render() {
  // this - 使用 bind
  return <p onClick={this.clickHandler1}>
    {this.state.name}
  </p>
  
  // this - 静态方法
  return <p onClick={this.clickHandler2}>
    {this.state.name}
  </p>
}
```

#### 4.2 关于 event 参数

```react
clickHandle3 = (event) => {
  event.preventDefault()	// 阻止默认行为
  event.stopPropagation()	// 阻止冒泡
  console.log('target', event.target)	// 指向当前元素，即当前元素触发
  console.log('curret target', event.currentTarget)	// 指向当前元素，假象！！！
  
  // 注意，event 其实是 React 封装的，可以看 __proto__.constructor 是 SyntheticEvent
  console.log('event', event)	// 不是原生的 Event，原生的 MouseEvent
  console.log('event.__proto__.constructor', event.__proto__.constructor)
  
  // 原生 event 如下。其__proto__.constructor 是 MouseEvent
  console.log('nativeEvent', event.nativeEvent)
  console.log('nativeEvent target', event.nativeEvent.target)	// 指向当前元素
  console.log('nativeEvent current target', event.nativeEvent.currentTarget)	// 指向 document ！！！
  
  // 1. event 是 SyntheticEvent ，模拟出来 DOM 事件所有能力
  // 2. event.nativeEvent 是原生事件对象
  // 3. 所有的事件，都被挂载到 document 上
  // 4. 和 DOM 事件不一样，和 Vue 事件也不一样
}
```

#### 4.3 传递自定义参数

```javascript
clickHandle4 = (id, title, event) => {
  console.log(id, title)
  console.log('event', event)	// 最后追加一个参数，即可接受 Event
}
```

### 5. 表单

#### 5.1 受控组件

```react
return (
  <div>
    <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for 属性*/}
    <input id="inputName" value={this.state.name} onChange={(e) => {
        this.setState({
          name: e.target.value
        })
      }} />
  </div>
)
```

#### 5.2 input、textarea、select 用 value

```react
<textarea value={this.state.info} onChange={(e) => {
    this.setState({
      info: e.target.value
    })
  }}>
</textarea>
```

```react
<select value={this.state.city} onChange={(e) => {
    this.setState({
      city: e.target.value
    })
  }}>
  <option value="beijing">北京</option>
  <option value="shanghai">上海</option>
  <option value="shenzhen">深圳</option>
</select>
```

#### 5.3 checkbox、radio 用 checked

```react
<input type="checkbox" checked={this.state.flag} onChange={(e) => {
  this.setState({
    flag: e.target.value
  })
 }} />
```

```react
<imput 
  type="radio"
  name="gender"
  value="male"
  checked={this.state.gender === 'male'}
  onChange((e) => {
    this.setState({
      gender: e.target.value
    })
  })
/>
<imput 
  type="radio"
  name="gender"
  value="female"
  checked={this.state.gender === 'female'}
  onChange((e) => {
    this.setState({
      gender: e.target.value
    })
  })
/>
```

### 6. 组件使用

#### 6.1 props 传递数据

#### 6.2 props 传递函数

#### 6.3 props 类型检查

### 7. setState

#### 7.1 不可变值

```javascript
// 不要直接修改 state，使用不可变值
this.state.count++	// 错误
this.setState({
  count: this.state.count + 1
})
```

```javascript
// 不可变值（函数式编程，纯函数）- 数组
const list5Copy = this.state.list5.slice()
list5Copy.splice(2, 0, 'a')	// 中间插入/删除
this.setState({
  list1: this.state.list1.concat(100),	// 追加
  list2: [...this.state.list2, 100],	// 追加
  list3: this.state.list3.slice(0, 3),	// 截取
  list4: this.state.list4.filter(item => item > 100), 	// 筛选
  list5: list5Copy	// 其他操作
})
// 注意，不能直接对 this.state.list 进行 push、pop、splice 等，这样违反不可变值
```

```javascript
// 不可变值 - 对象
this.setState({
  obj1: Object.assign({}, this.state.obj1, {a: 100}),
  obj2: {...this.state.obj2, a: 100}
})
// 注意：不能直接对 this.state.obj 进行属性设置，这样违反不可变值
```

#### 7.2 可能是异步更新

```javascript
// 作为普通函数调用
this.setState({
  count: this.state.count + 1
}, () => {
  console.log('', this.state.count)	// 回调函数内，可以拿到最新值
})
console.log('count', this.state.count)	// 异步，拿不到最新值
```

```javascript
// setTimeout 中 setState 是同步的
setTimeout(() => {
  this.setState({
    count: this.state.count + 1
  })
  console.log('count in setTimeout', this.state.count)
}, 0)
```

```javascript
// 自定义的 DOM 事件，setState 是同步的
bodyClickHandler = () => {
  this.setState({
    count: this.state.count + 1
  })
  console.log('count in body event', this.state.count)
}
componentDidMount() {
  // 自定义的 DOM 事件
  document.boby.addEventListener('click', this.bodyClickHandler)
}
componnetWillUnmount() {
  // 及时销毁自定义 DOM 事件
  document.body.removeEventListener('click', this.bodyClickHandler)
}
```

#### 7.3 可能会被合并

```javascript
// state 异步更新的话，更新前会被合并
// 传入对象，会被合并（ 类似 Object.assign ）
this.setState({
  count: this.state.count + 1
})
this.setState({
  count: this.state.count + 1
})
this.setState({
  count: this.state.count + 1
})
// 执行结果只一次 +1
```

```javascript
// 传入函数，不会被合并，执行结果 +3
this.setState((prevState, props) => {
  return {
    count: prevState.count + 1
  }
})
this.setState((prevState, props) => {
  return {
    count: prevState.count + 1
  }
})
this.setState((prevState, props) => {
  return {
    count: prevState.count + 1
  }
})
```

### 8. React 生命周期

[https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/]()

**React version 16.3：**

![image-20210207165515515](https://tva1.sinaimg.cn/large/008eGmZEgy1gnf2n9fsi3j31al0u0jxy.jpg)

**React version >= 16.4：**

![image-20210207165700448](https://tva1.sinaimg.cn/large/008eGmZEgy1gnf2p173s6j31ag0u0dme.jpg)

### 8.1 单组件生命周期

### 8.2 父子组件生命周期（和 Vue 的一样）

## React 高级特性

### 1. 函数组件

* 纯函数，输入 props ，输出 JSX ；
* 没有实例，没有生命周期，没有 state ；
* 不能扩展其他方法；

```react
// class 组件
class List extends React.Component {
  constructor(props) {
    super(props)
  }
  
  render() {
    const { list } = this.props
    
    return (
      <ul>
        {list.map(item) => (
          <li key={item.id}>
            <span>{item.title}</span>
          </li>
        )}
      </ul>
    )
  }
}
```

```react
// 函数组件
function List(props) {
  const { list } = this.props
  
  return (
    <ul>
      {list.map(item) => (
        <li key={item.id}>
          <span>{item.title}</span>
        </li>
      )}
    </ul>
  )
}
```

### 2. 非受控组件

* `ref`
* `defaultValue`、`defaultChecked`
* 手动操作 DOM 元素

```react
class App extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      name: 'shuangyue',
      flag: true,
    }
    this.nameInputRef = React.createRef()
    this.fileInputRef = React.createRef()
  }
  
  render() {
    return (
      <>
        {/* 使用 defaultValue 而不是 value，使用 ref */}
        <input defaultValue={this.state.name} ref={this.nameInputRef} />
        {/* state 并不会随着改变 */}
        <span>state.name: {this.state.name}</span>
        <button onClick={this.alertName}>alert name</button>
        <hr />
        <input type="file" ref={this.fileInputRef} />
        <button onClick={this.alertFile}>alert file</button>
      </>
    )
  }
  
  alertName = () => {
    const elem = this.nameInputRef.current
    alert(elem.value)
  }
  alertFile = () => {
    const elem = this.fileInputRef.current
    alert(elem.files[0].name)
  }
}
```

**使用场景：**

* 必须手动操作 DOM 元素，setState 实现不了；
* 文件上传 `<input type='file' />`；
* 某些富文本编辑器，需要传入 DOM 元素；

**受控组件 VS 非受控组件：**

* 优先使用受控组件，符合 React 设计原则；
* 必须操作 DOM 时，再使用非受控组件；

### 3. Portals

* 组件默认会按照既定层次嵌套渲染
* 如何让组件渲染到父组件以外？

```react
render() {
  // 使用 Portal 渲染到 body 上。
  // fixed 元素要放在 body 上，有更好的浏览器兼容性
  return ReactDom.creatPortal(
    <div className="modal">{this.props.children}</div>,
    document.body	// DOM 节点
  )
}
```

**Portals 使用场景：**

* `overflow:hidden`
* 父组件 `z-index` 值太小
* fixed 需要放在 body 第一层级

### 4. context

* 公共信息（语言、主题）如何传递给每个组件？
* 用 props 太繁琐
* 用 redux 小题大做

```react
// 创建 Context 填入默认值（任何一个 js 变量）
const ThemeContext = React.createContext('light')

class App extends React.Componnet {
  constructor(props) {
    super(props)
    this.state = {
      theme: 'light'
    }
  }
  
  render() {
    return (
      <ThemeContext.Provider value={this.state.theme}>
        <ThemeButton />
        <ThemeLink />
        <button onClick={this.changeTheme}>change theme</button>
      </ThemeContext.Provider>
    )
  }
  
  changeTheme = () => {
    this.setState({
      theme: this.state.theme === 'light' ? 'dark' : 'light'
    })
  }
}
```

```react
// 底层组件 - class 组件
class ThemedButton extends React.Component {
  /* static contextType = ThemeContext	// 也可以用此方式代替 ThemedButton.contextType = ThemeContext */
  
  render() {
    const theme = this.context	// React 会往上找到最近的 theme context
    return (
      <div>
        <p>button's theme is {theme}</p>
      </div>
    )
  }
}
ThemedButton.contextType = ThemeContext	// 指定 contextType 读取当前 ThemeContext 值
```

```react
// 底层组件 - 函数组件
function ThemeLink(props) {
  // 函数式组件可以使用 Consumer
  return (
    <ThemeContext.Consumer>
      {value => <p>link's theme is {value}</p>}
    </ThemeContext.Consumer>
  )
}
```

### 5. 异步组件

* import()
* React.lazy
* React.Suspense

```react
import React from 'react'
const ContextDemo = React.lazy(() => import('./ContextDemo'))

class App extends React.Component {
  constructor(props) {
    super(props)
  }
  
  render() {
    return (
      <div>
        <p>引入一个动态组件</p>
        <React.Suspense fallback={<div>loading...</div>}>
          <ContextDemo />
        </React.Suspense>
      </div>
    )
  }
}

export default App
```

### 6. 性能优化

#### 6.1 shouldComponentUpdate（简称 SCU）

```react
shouleComponentUpdate(nextProps, nextState) {
  if (nextState.count !== this.state.count) {
    return true	// 可以渲染
  }
  return false	// 不重复渲染
}
// React 默认：父组件有更新，子组件则无条件也更新！！！
// SCU 一定要每次都用吗？
// * 需要的时候才优化（框架不考虑具体实现细节）
// * 对 state 值处理时，要遵循不可变值
// * 对 nextState 要做前后对比
```

```react
shouldComponentUpdate(nextProps, nextState) {
  // _.isEqual 做对象或者数组的深度比较（一次性递归到底）
  if(_.isEqual(nextProps.list, this.props.list)) {
    return false	// 相等，则不重复渲染
  }
  return true	//不相等，则渲染
}
// 必须配合“不可变值”一起使用
```

**SCU 使用总结：**

* SCU 默认返回 true ，即 React 默认重新渲染所有子组件；
* 必须配合“不可变值”一起使用；
* 可先不用 SCU ，有性能问题时考虑使用；

#### 6.2 PureComponent 和 React.memo

* `PureComponent`，SCU 中实现了浅比较
* memo，函数组件中的 PureComponent
* 浅比较已使用大部分情况（尽量不要做深度比较）

```react
// PureComponent class表示方法
class List extends React.PureComponent {
  constructor(props) {
    super(props)
  }
  
  render() {
    ...
  }
}
```

```react
// React.memo 函数表示方法
function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, next) {
  /*
    如果把 nextProps 传入 render 方法的返回结果与 
    将 pervProps 传入 render 方法的返回结果一致则返回 true,
    否则返回 false
  */
}
export default React.memo(MyComponent, areEqual)
```

#### 6.3 不可变值 immutable.js

* 彻底拥抱“不可变值”；
* 基于共享数据（不是深拷贝），速度好；
* 有一定学习和迁移成本，按需使用；

```javascript
const map1 = Immutable.Map({ a: 1, b: 2, c: 3 })
const map2 = map1.set('b', 50)
map1.get('b')	// 2
map2.get('b')	// 50
```

### 7. 高阶组件 HOC

**关于组件公共逻辑的抽离：**

* mixin ，已被 React 弃用
* 高阶组件 HOC
* Render Props

**高阶组件-基本使用：**

```react
// 高阶组件不是一种功能，而是一种模式
const HOCFactory = (Component) => {
  class HOC extends React.Component {
    render() {
      return <Component {...this.props} />	// 返回拼装的结果
    }
  }
  return HOC
}
const EnhancedComponent1 = HOCFactory(WrappedComponent1)
const EnhancedComponent2 = HOCFactory(WrappedComponent2)
```

**高阶组件实例：**

```react
const withMouse = (Component) => {
  class withMouseComponent extends React.Component {
    constructor(props) {
      super(props)
      this.state = { x: 0, y: 0 }
    }
    
    handleMouseMove = (event) => {
      this.setState({
        x: event.clientX,
        y: event.clientY
      })
    }
    
    render() {
      return (
        <div onMouseMove={this.handleMouseMove}>
          {/* 1. 透传所有 props； 2. 增加 mouse 属性 */}
          <Component {...this.props} mouse={this.state} />
        </div>
      )
    }
  }
  return withMouseComponent
}

const App = (props) => {
  const { x, y } = props.mouse	// 接受 mouse 属性
  return (
    <div style={{ height: '500px'}}>
      <h1>The mouse position is ({x}, {y})</h1>
    </div>
  )
}

export default withMouse(App)	// 返回高阶函数
```



**redux connect 是高阶组件：**

```react
import { connect } from 'react-redux'

// connect 是高阶组件
const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)
```

**connect 源码：**

```react
export const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => {
  class Connect extends Component {
    constructor() {
      super()
      this.state = {
        allProps: {}
      }
    }
    /* 中间省略 N 行代码 */
    render() {
      return <WrappedComponent {...this.state.allProps} />
    }
  }
  return Connect
}
```

### 8. Render Props

```react
/**
* Render Props 的核心思想：
* 通过一个函数将 class 组件的 state 作为 props 传递给纯函数组件
*/
class Factory extends React.Component {
  constructor() {
    this.state = {
    	/* state 即多个组件的公共逻辑的数据 */
    }
  }
  
  /* 修改 state */
  
  render() {
    return (
      <div>{this.props.render(this.state)}</div>
    )
  }
}


const App = () => {
  <Factory render={
      /* render 是一个函数组件 */
    (props) => <p>{props.a} {props.b} ...</p>
  } />
}
```

**HOC vs Render Props：**

* HOC：模式简单，但会增加组件层级；
* Render Props：代码简洁，，学习成本较高；
* 按需使用；



## Redux 使用

### 1. 基本概念

* store state
* action
* reducer

### 2. 单项数据流

* dispatch(action)
* reducer -> newState
* subscribe 触发通知

### 3. react-redux

* `<Provider>` connect
* connect
* mapStateToProps、mapDispatchToProps

### 4. 异步 action

* redux-thunk
* redux-promise
* redux-saga

```javascript
// 同步 action
export const addTodo = text => {
  // 返回 action 对象
  return {
    type: 'ADD_TODO',
    id: nextTodoId++,
    text
  }
}
```

```javascript
// 异步 action
export const addTodoAsync = text => {
  // 返回函数，其中有 dispatch 参数
  return () => {
    // ajax 异步获取数据
    fetch(url).then(res => {
      // 执行异步 action
      dispatch(addTodo(res.text))
    })
  }
}
```

### 5. 中间件

![image-20210208141938360](https://tva1.sinaimg.cn/large/008eGmZEgy1gng3rm51x3j31jm0nyh3k.jpg)



![image-20210208142644988](https://tva1.sinaimg.cn/large/008eGmZEgy1gng3z02pojj30po0r0jzm.jpg)



## React-router 

### 1. 路由模式

* hash 模式（默认），如 http://abc/#/user/10
* H5 history 模式，如 http://abc.com/user/20
* 后者需要 server 端支持，因此无特殊需求可选择前者

![image-20210208144134236](https://tva1.sinaimg.cn/large/008eGmZEgy1gng4efgnljj314c0m87hj.jpg)

### 2. 路由配置

![image-20210208144214847](https://tva1.sinaimg.cn/large/008eGmZEgy1gng4f4lj8bj318e0lq4dm.jpg)

![image-20210208144240726](https://tva1.sinaimg.cn/large/008eGmZEgy1gng4fkeuvaj310c0m8tmy.jpg)

## React 原理

### 1. 回顾 vdom 和 diff

#### 1.1 vdom

![image-20210208151430725](https://tva1.sinaimg.cn/large/008eGmZEgy1gng5cp2ar2j318m0rk46r.jpg)

#### 1.2 diff

* 只比较同一层级，不跨级比较；
* tag 不相同，则直接删掉重建，不再深度比较；
* tag 和 key ，两者都相同，则认为是相同节点，不再深度比较；

### 2. JSX 本质

* React.createElement 即 h函数，返回 vnode
* 第一个参数，可能是组件，也可能是 html tag
* 组件名，首字母必须大写（React 规定）

![image-20210208152039815](https://tva1.sinaimg.cn/large/008eGmZEgy1gng5j3go9mj30oa0ic7cn.jpg)

### 3. 合成事件

* 所有事件挂载到 document 上；
* event 不是原生的，是 SyntheticEvent 合成事件对象；
* 和 Vue 事件不同，和 DOM 事件也不同；

![image-20210208155946815](https://tva1.sinaimg.cn/large/008eGmZEgy1gng6nu975pj30pm0dgdkm.jpg)

**合成事件 - 图示：**

* 更好的兼容性和跨平台；
* 载到 document ，减少内存消耗，避免频繁解绑；
* 方便事件的统一管理（如事务机制）；

### 4. setState 和 batchUpdate

* 有时异步（普通使用），有时同步（setTimeout、DOM 事件）
* 有时合并（对象形式），有时不合并（函数形式）

#### 4.1 setState 主流程

![noname](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7f0z9e2j30jy0f6whj.jpg)

![image-20210208162610281](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7f9c45zj30q60cmn51.jpg)

#### 4.2 batchUpdate 机制

**setState 异步还是同步？**

* setState 无所谓异步还是同步
* 看是否能命中 batchUpdate 机制
* 判断 isBatchingUpdates

![image-20210208163840818](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7sa41a2j30py0ci7bw.jpg)

![image-20210208162921043](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7ikdxlaj30zu0iiqfs.jpg)

![image-20210208162937572](https://tva1.sinaimg.cn/large/008eGmZEgy1gng7iuuoc3j30us0j8n6y.jpg)

**哪些能命中 batchUpdate 机制：**

* 生命周期（和它调用的函数）
* React 中注册的事件（和它调用的函数）
* React 可以“管理”的入口

**哪些不能命中 batchUpdate 机制：**

* setTimeOut、setInterval 等（和它调用的函数）
* 自定义的 DOM 事件（和它调用的函数）
* React “管不到” 的入口

#### 4.3 React 事务机制

![image-20210208164749616](https://tva1.sinaimg.cn/large/008eGmZEgy1gng81sdcilj30e00feq74.jpg)

![image-20210208164759847](https://tva1.sinaimg.cn/large/008eGmZEgy1gng81yth1pj30l60fo0y0.jpg)

![image-20210208164903652](https://tva1.sinaimg.cn/large/008eGmZEgy1gng832m5fzj30ou0c8wiv.jpg)

### 5. React 组件渲染和更新的过程

* JSX 如何渲染为页面
*  setState 之后如何更新页面

#### 5.1 JSX 本质和 vdom

* JSX 即 createElement 函数
* 执行生成 vnode
* patch(elem, vnode) 和 patch(vnode, newVnode)

#### 5.2 组件渲染过程

* props state
* render() 生成 vnode
* patch(elem, vnode)

#### 5.3 组件更新过程

* setState(newState)  --> dirtyComponents（可能有子组件）
* render() 生成 newVnode
* patch(vnode, newVnode)

#### 5.4 更新的两个阶段

上述的 patch 被拆分为两个阶段：

* reconciliation  阶段 - 执行 diff 算法，纯 JS 计算
* commit 阶段 - 将 diff 结果渲染 DOM

**可能会有性能问题：**

* JS 是单线程，且和 DOM 渲染共用一个线程；
* 当组件足够复杂，组件更新时计算和渲染的压力都很大；
* 同时再有 DOM 操作需求（动画，鼠标拖拽等），就有可能造成页面卡顿；
* 解决方案 - fiber

### 6. React-fiber 如何优化性能

* 将 reconciliation 阶段进行任务拆分（commit 无法拆分）
* DOM 需要渲染时暂停，空闲时恢复
* window.requestIdleCallback（监听 DOM 需要渲染时的 API）



## React 真题

### 1. 组件之间如何通讯？

* 父子组件 props
* 自定义事件
* Redux 和 Context

### 2. JSX 本质是什么？

* createElement
* 执行返回 vnode

### 3. Context 是什么，如何应用？

* 父组件，向其下所有子孙组件传递信息；
* 如一些简单的公共信息：主题色、语言等
* 复杂的公共信息，请用 redux

### 4. shouldComponentUpdate 用途？

* 性能优化
* 配合“不可变值”一起使用，否则会出错

### 5. redux 单项数据流

 ![image-20210213151322760](https://tva1.sinaimg.cn/large/008eGmZEgy1gnlxf3y351j30u00w6ajq.jpg)

### 6. setState 场景题

```react
componentDidMount() {
  this.setState({ count: this.state.count + 1 })
  console.log('1', this.state.count)	// 0
  this.setState({ count: this.state.count + 1 })
  console.log('2', this.state.count)	// 0
  setTimeout(() => {
    this.setState({ count: this.state.count + 1 })
    console.log('3', this,state.count)	// 2
  })
  setTimeout(() => {
    this.setState({ count: this.state.count + 1 })
    console.log('4', this.state.count)	// 3
  })
}
```

### 7. 什么是纯函数？

* 返回一个新值，没有副作用（不会“偷偷”修改其他值）
* 重点：不可变值
* 如 arr1 = arr.slice()

### 8. React 组件生命周期

* 单组件生命周期
* 父子组件生命周期
* 注意 SCU

### 9. React 发起 ajax 应该在哪个生命周期？

* 同 Vue
* componentDidMount

### 10. 渲染列表，为何使用 key

* 同 Vue。必须用 key，且不能是 index 和 random
* diff 算法中通过 tag 和 key 来判断，是否是 sameNode
* 减少渲染次数，提升渲染性能

### 11. 函数组件和 class 组件区别？

* 纯函数，输入 props，输出 JSX
* 没有实例，没有生命周期，没有 state
* 不能扩展其他方法

### 12. 什么是受控组件？

* 表单的值，受 state 控制
* 需要自行监听 onChange，更新 state
* 对比非受控组件

### 13. 何时使用异步组件

* 加载大组件
* 路由懒加载

### 14. 多个组件有公共逻辑，如何抽离

* 高阶组件（HOC）
* Render Props
* mixin 已被 React 废弃

### 15. redux 如何进行异步请求？

* 使用异步 action
* 如 redux-thunk

### 16. react-router 如何配置懒加载

```react
import { BrowerRouter as Router, Route, Switch } from 'react-router-dom'
import React, { Suspense, lazy } from 'react'

const Home = lazy(() => import('./routes/Home'))
const About = lazy(() => import('./routes/About'))

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Switch>
        <Route exact path="/" component={Home}>
        <Route path="/about" component={About}>
      </Switch>
    </Suspense>
  </Router>
)
```

### 17. PureComponent 有何区别？

* 实现了浅比较 shouldComponentUpdate
* 优化性能
* 但要结合不可变值使用

### 18. React 事件和 DOM 事件的区别？

* 所有事件挂载到 document 上；
* event 不是原生的，是 SyntheticEvent 合成事件对象；
* dispatchEvent

### 19. React 性能优化

* 渲染列表式加 key
* 自定义事件、DOM 事件及时销毁
* 合理使用异步组件
* 减少函数 bind this 的次数
* 合理使用 SCU PureComponent 和 memo
* 合理使用 Immutable.js
* Webpack 层面的优化
* 前端通用的性能优化，如图片懒加载
* 使用 SSR

### 20. React 和 Vue 的区别？

**相同点：**

* 都支持组件化
* 都是数据驱动视图
* 都使用 vdom 操作 DOM

**区别：**

* React 使用 JSX 拥抱 JS，Vue 使用模板拥抱 html
* React 函数式编程，Vue 声明式编程
* React 更多需要自力更生，Vue 把想要的都给你



## webpack

* Webpack 已是前端打包构建的不二选择
* 成熟工具，重点在于配置和使用，原理并不高优

### 1. webpack 基本配置

#### 1.1 拆分配置和 merge

```javascript
// file: webpack.common.js

const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { srcPath, distPath } = require('./paths')

module.exports = {
  entry: path.join(srcPath, 'index'),
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: ['babel-loader'],
        include: srcPath,
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        // loader 的执行顺序是：从后往前
        loader: ['style-loader', 'css-loader', 'postcss-loader']
      },
      {
        test: /\.less$/,
        loader: ['style-loader', 'css-loader', 'less-loader']
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(srcPath, 'index.html'),
      filename: 'index.html'
    })
  ]
}
```



```javascript
// file: webpack.dev.js

const path = require('path')
const webpack = require('webpack')
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
const webpackCommonConf = require('./webpack.common.js')
const { smart } = require('webpack-merge')
const { secPath, distPath } = require('./paths')

module.exports = smart(webpackCommonConf, {
  mode: 'development',
  module: {
    rules: [
      {
        // 直接引入图片 URL
        test: /\.(png|jpg|jpeg|gif)$/,
        use: 'file-loader'
      }
    ]
  },
  plugins: [
    new webpack.DefinePlugin({
      // window.ENV = 'development'
      ENV: JSON.stringify('development')
    })
  ],
  devServer: {
    port: 8080,
    progress: true,	// 显示打包的进度条
    contentBase: distPath	// 根目录
    open: true,	// 自动打开浏览器
    compress: true,	// 启动 gzip 压缩
    
    // 设置代理
    proxy: {
      // 将本地 /api/xxx 代理到 localhost:3000/api/xxx
      '/api': 'http://localhost:3000',
      
      // 将本地 /api2/xxx 代理到 localhost:3000/xxx
      '/api2': {
        target: 'http://localhost:3000',
        pathRewrite: {
          '/api2': ''
        }
      }
    }
  }
})
```



```javascript
// file: webpack.prod.js

const webpackCommonConf = require('./webpack.common.js')
const { smart } = require('webpack-merge')
const { srcPath, distPath } = require('./paths')

module.exports = smart(webpackCommonConf, {
  mode: 'production',
  output: {
    filename: 'bundle.[contentHash:8].js',	// 打包代码时，加上 hash
    path: distPath,
    // pubilcPath: 'http://cdn.abc.com'	// 修改所有静态文件 URL
  },
  module: {
    rules: [
      {
        test: /\.(png|jpg|jpeg|gif)$/,
        use: {
          loader: 'url-loader',
          options: {
            limit: 5 * 1024,
            outputPath: '/img/',
            // 设置图片的 cdn 地址（也可以统一在外面的 output）
            // pubilcPath: 'http://cdn.abc.com'
          }
        }
      }
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),	// 会默认清空 output.path 文件夹
    new webpack.DefinePlugin({
      // window.ENV = 'production'
      ENV: JSON.stringify('production')
    })
  ]
})
```

#### 1.2 启动本地服务

#### 1.3 处理 ES6

#### 1.4 处理样式

####  1.5 处理图片

#### 1.6 模块化



```javascript
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const { srcPath, distPath } = require('./paths')

module.exports = {
  entry: path.join(srcPath, 'index'),
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: ['babel-loader'],
        include: srcPath,
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        // loader 的执行顺序是：从后往前
        loader: ['style-loader', 'css-loader', 'postcss-loader']
      },
      {
        test: /\.less$/,
        loader: ['style-loader', 'css-loader', 'less-loader']
      },
      {
        test: /\.(png|jpg|jpeg|gif)$/,
        use: {
          loader: 'url-loader',
          options: {
            // 小于 5kb 的图片用 base64 格式产出
            // 否则，依然延用 file-loader 的形式，产出 url 格式
            limit: 5 * 1024,
            // 打包到 img 目录下
            outputPath: '/img/'
          }
        }
      }
    ]
  }
}
```

### 2. webpack 高级配置

#### 2.1 多入口配置

```javascript
const path = require('path')
const HtmlWebpackPlugin = reuqire('html-webpack-plugin')
const { srcPath, distPath } = require('./paths')

module.exports = {
  entry: {
    index: path.join(srcPath, 'index.js')
    other: path.join(srcPath, 'other.js')
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: ['babel-loader'],
        include: srcPath,
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    // 多入口 - 生成 index.html
    new HtmlWebpackPlugin({
      template: path.join(srcPath, 'index.html'),
      filename: 'index.html',
      // chunks 表示该页面要引用哪些 chunk（即上面的 index 和 other）
      chunks: ['index']	// 只引用 index.js
    }),
    // 多入口 - 生成 other.html
    new HtmlWebpackPlugin({
      template: path.join(srcPath, 'other.html'),
      filename: 'other.html',
      chunks: ['other']	// 只引用 other.js
    })
  ]
}
```

#### 2.2 抽离压缩 css 文件

```javascript
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const TerserJSPlugin = require('terser-webpack-plugin')
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack')

module.exports = {
  module: {
    rules: [
      // 抽离 css
      {
        test: /\.css$/,
        loader: [
          MiniCssExtractPlugin.loader,	// 注意这里不再用 ‘style-loader’
          'css-loader',
          'postcss-loader'
        ]
      },
      // 抽离 less -> css
      {
        test: /\.less$/,
        loader: [
          MiniCssExtractPlugin.loader,  // 注意这里不再用 ‘style-loader’
          'css-loader',
          'less-loader',
          'postcss-loader'
        ]
      }
    ]
  },
  plugins: [
    // 抽离 css 文件
    new MiniCssExtractPlugin({
      filename: 'css/main.[contentHash:8].css'
    })
  ],
  optimization: {
    // 压缩 css
    minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin]
  }
}
```

#### 2.3 抽离公共代码

```javascript
module.exports = {
  optimization: {
    minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin],
    
    // 分割代码块
    splitChunks: {
      /**
      * initial 入口 chunk，对于异步导入的文件不处理
      * async 异步 chunk，只对异步导入的文件处理
      * all 全部 chunk
      */
      chunks: 'all',
      
      // 缓存分组
      cacheGroups: {
        // 第三方模块
        vender: {
          name: 'verdor',	// chunk 名称
          priority: 1,	// 权限更高，优先抽离，重要！！！
          test: /node_modules/,
          minSize: 0,	// 大小限制
          minChunks: 1,	// 最少复用过几次
        },
        // 公共模块
        common: {
          name: 'common',	// chunk 名称
          priority: 0,	// 优先级
          minSize: 0,	// 公共模块的大小限制
          minChunks: 2	// 公共模块最小复用过几次
        }
      }
    }
  }
}
```

#### 2.4 异步懒加载 JS

```javascript
// 引入动态数据 - 懒加载
setTimeout(() => {
  import('./dynamic-data.js').then(res => {
    console.log(res.default.message)	// 注意这里的 default
  })
}, 1500)
```

#### 2.5 module chunk bundle 的区别

* module - 各个源码文件，webpack 中一切皆模块
* chunk - 多模块合并成的，如 entry、import()、splitChunk
* bundle - 最终的输出文件

![image-20210218191138084](https://tva1.sinaimg.cn/large/008eGmZEgy1gnrwekpyg1j31ou0ps4fc.jpg)

### 3. webpack 性能优化

* 优化打包构建速度 - 开发体验和效率
* 优化产出代码 - 产品性能

#### 3.1 webpack 性能优化 - 构建速度

##### 3.1.1 优化 babel-loader

```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: ['babel-loader?cacheDirectory'],	// 开启缓存
        include: path.resolve(__dirname, 'src'),	// 明确范围
        // 排除范围，include 和 exclude 两者选一个即可
        // exclude: path.resolve(__dirname, 'node_modules')
      }
    ]
  }
}
```

##### 3.1.2 IgnorePlugin

##### 3.1.3 noParse

##### 3.1.4 happyPack 多进程打包

* JS 单线程，开启多进程打包
* 提高构建速度（特别是多核 CPU）

```javascript
const HappyPack = require('happypack')

module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例
        use: ['happypack/loader?id=babel'],
        include: srcPath,
        // exclude: /node_modules/
      }
    ]
  },
  plugins: [
    new HappyPack({
      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件
      id: 'babel',
      // 如何处理 .js 文件，用法和 Loader 配置中一样
      loaders: ['babel-loader?cacheDirectory']
    })
  ]
}
```

##### 3.1.5 ParallelUglifyPlugin 多进程压缩 JS

* webpack 内置 Uglify 工具压缩 JS
* JS 单线程，开启多进程压缩更快
* 和 happyPack 同理

```javascript
const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')

module.exports = {
  plugins: [
    new ParallelUglifyPlugin({
      uglifyJS: {
        output: {
          beautify: false,
          comments: false,
        },
        compress: {
          // 删除所有的 `console` 语句，可以兼容 IE 浏览器
          drop_console: true,
          // 内嵌定义了，但是只用到一次的变量
          collapse_vars: true,
          // 提取出出现多次，但是没有定义成变量去引用的静态值
          reduce_vars: true,
        }
      }
    })
  ]
}
```

> **关于开启多进程：**
>
> * 项目较大，打包较慢，开启多进程能提高速度；
> * 项目较小，打包很快，开启多进程会降低速度（进程开销 ）；
> * 按需使用

##### 3.1.6 自动刷新

```javascript
module.export = {
  // 注意，开启监听之后，webpack-dev-serve 会自动开启刷新浏览器
  watch: true,	// 开启监听，默认为 false
  // 监听配置
  watchOptions: {
    ignored: /node_modules/,	// 忽略哪些
    // 监听到变化发生后会等 300ms 再去执行动作，防止文件更新太快导致重新编译频率太高
    aggregateTimeout: 300,
    // 判断文件是否发生变化，是通过不停的去询问系统指定文件有没有变化实现的
    poll: 1000,	// 默认每隔 1000 毫秒询问一次
  }
}
```

##### 3.1.7 热更新

* 自动刷新：整个网页全部刷新，速度较慢，状态会丢失；
* 热更新：新代码生效，网页不刷新，状态不丢失；

```javascript
const HotModuleReplaceMentPlugin = require('webpack/lib/HotModuleReplacementPlugin')

module.exports = {
  entry: {
    index: [
      'webpack-dev-server/client?http://localhost:8080',
      'webpack/hot/dev-server',
      path.join(srcPath, 'index.js')
    ]
  },
  plugins: [
    new HotModuleReplacementPlugin()
  ],
  devServer: {
    port: 8080,
    progress: true,	// 显示打包进度
    contentBase: distPath,	// 根目录
    open: true,	// 自动打开浏览器
    compress: true,	// 启动 gzip 压缩
    hot: true,
  }
}
```

```javascript
// file: index.js

import {} = from './math'
if (module.hot) {
  module.hot.accept(['./math'], () => {
    const sunRes = sun(10, 30)
    console.log('sumRes in hot', sumRes)
  })
}
```

##### 3.1.8 DllPlugin 动态链接库插件

**前提：**

* 前端框架，如 Vue、React ，体积大，构建慢；
* 较稳定，不常升级版本；
* 同一个版本只构建一次即可，不用每次都重新构建；

**原理：**

* webpack 已内置 DllPlugin 支持
* DllPlugin - 打包出 dll 文件
* DllReferencePlugin - 使用 dll 文件

```javascript
const path = require('path')
const DllPlugin = require('webpack/lib/DllPlugin')
const { srcPath, distPath } = require('./paths')

module.exports = {
  mode: 'development',
  // JS 执行入口文件
  entry: {
    // 把 React 相关模块的放到一个单独的动态链接库
    react: ['react', 'react-dom'],
  },
  output: {
    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称
    // 也就是 entry 中配置的 react 和 polyfill
    filename: '[name].dll.js',
    // 输出的文件都放到 dist 目录下
    path: distPath,
    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react
    // 之所以在前面加上 _dll_ 是为了全局变量冲突
    library: '_dll_[name]',
  },
  plugins: [
    // 接入 DllPlugin
    new DllPlugins({
      // 动态链接库的全局变量名称，需要和 output.library 中保持一致
      // 该字段的值也就是输出的 mainfest.json 文件中 name 字段的值
      // 例如 react.mainfest.json 中就有 "name": "_dll_react"
      name: '_dll_[name]',
      path: path.join(distPath, '[name].mainfest.json'),
    })
  ]
}
```

#### 3.2 webpack 性能优化 - 产出代码

* 体积更小
* 合理分包，不重复加载
* 速度更快、内存使用更少

##### 3.2.1 小图片 base64 编码

##### 3.2.2 bundle 加 hash

##### 3.2.3 IngorePlugin

##### 3.2.4 使用 CDN 加速

##### 3.2.5 提取公共代码

##### 3.2.6 懒加载

##### 3.2.7 使用 production

* 自动开启代码压缩

* Vue、React 等会自动删掉调试代码（如开发环境的 warning）

* 启动 Tree-Shaking

  > ES6 Module 才能让 tree-shaking 生效
  >
  > commonJS 就不可以

**ES6 Module 和 CommonJS 区别：** 

* ES6 Module 静态引入，编译时引入；
* CommonJS 动态引入，执行时引入；
* 只有 ES6 Module 才能静态分析，实现 Tree-Shaking

```javascript
// 静态引入和动态引入的区别

/* ES6 Module */
let apiList = require('../config/api.js')
if (isDev) {
  // 可以动态引入，执行时引入
  apiList = require('../config/api_dev.js')
}

/* CommonJS */
import apiList from '../config/api.js'
if (isDev) {
  // 编译时报错，只能静态引入
  import apiList from '../config/api_dev.js'
}
```


##### 3.2.8 scope hosting

**好处：**

* 代码体积更小
* 创建函数作用域更少
* 代码可读性更好

**代码：**

```javascript
const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin')

module.exports = {
  resolve: {
    // 针对性 npm 中的第三方模块优先采用 jsnext: main 中指向的 ES6 模块化语法的文件
    mainFields: ['jsnext: main', 'browser', 'main']
  },
  plugins: [
    // 开启 Scope Hosting
    new ModuleConcatenationPlugin(),
  ]
}
```

### 4. babel

#### 4.1 环境搭建 & 基本配置

##### 4.1.1 环境搭建

```json
"devDependencies": {
  "@babel/cli": "^7.7.5",
  "@babel/core": "^7.7.5",
  "@babel/plugin-transform-runtime": "^7.7.5",
  "@babel/preset-env": "^7.7.5"
},
"dependencies": {
  "@babel/polyfill": "^7.7.0",
  "@babel/runtime": "^7.7.5"
}
```

##### 4.1.2 .babelrc 配置

##### 4.1.3 presets 和 plugins

```json
// file: .babelrc

{
  "presets": [
    ["@babel/preset-env"]
  ],
  "plugins": []
}
```

#### 4.2 babel-polyfill

**前言：**

* 什么是 Polyfill
* core-js 和 regenerator
* babel-polyfill 即两者的集合

**babel-polyfill 按需引入**

* 文件较大
* 只有一部分功能，无需全部引入
* 配置按需引入

**代码：**

```json
{
  "presets": [
    [ 
      "@babel/preset-env",
      {
        "useBuiltIns": "usage",
        "corejs": 3
      }
    ]
  ],
  "plugins": []
}
```

#### 4.3 babel-runtime

**前言：**

*babel-polyfill 的问题：*

* 会污染全局环境
* 如果做一个独立的 web 系统，则无碍
* 如果做一个第三方 lib ，则会有问题

**代码：**

```json
{
  "presets": [],
  "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "absoluteRuntime": false,
        "corejs": 3,
        "helpers": true,
        "regenerator": true,
        "useESModules": false,
      }
    ]
  ]
}
```

### 真题

#### 1. 前端为何要进行打包和构建？

* 体积更小（tree-Shaking、压缩、合并），加载更快
* 编译高级语言或语法（TS，ES6+，模块化，scss）
* 兼容性和错误检查（polyfill、postcss、eslint）
* 统一、高效的开发环境
* 统一的构建流程和产出标准
* 集成公司构建规范（提测、上线等）

#### 2. module、chunk、bundle 的区别

* module - 各个源码文件，webpack 中一切皆模块
* chunk - 多模块合并成的，如 entry、import()、splitChunk
* bundle - 最终的输出文件

#### 3. loader 和 plugin 的区别

* loader 模块转换器，如 less -> css
* plugin 扩展插件，如 HtmlWebpackPlugin

#### 4. babel 和 webpack 的区别

* babel - JS 新语法编译工具，不关心模块化
* webpack - 打包构建工具，是多个 loader plugin 的集合

#### 5. 如何产出一个 lib

```json
output: {
  // lib 的文件名
  filename: 'lodash.js',
  // 输出 lib 到 dist 目录下
  path: distPath,
  // lib 的全局变量名
  library: 'lodash'
}
```

#### 6. babel-polyfill 和 babel-runtime 的区别

* babel-polyfill 会污染全局
* babel-runtime 不会污染全局
* 产出第三方 lib 要用 babel-runtime

#### 7. webpack 如何实现懒加载

* import()
* 结合 Vue、React 异步文件
* 结合 Vue-router、React-router 异步加载路由

#### 8. 为何 Proxy 不能被 Polyfill

* 如 Class 可以用 function 模拟
* 如 Promise 可以用 callback 来模拟
* 但 Proxy 的功能用 Object.defineProperty 无法模拟



## 组件设计

**前言：**

* 数据驱动视图
* 状态： 数据结构设计（React - state， Vue - data）
* 视图：组件结构和拆分

### 1. 组件设计

* 从功能上拆分层次
* 尽量让组件原子化
* 容器组件（只管理数据）& UI 组件（只显示视图）

### 2. 数据结构设计

* 用数据描述所有内容
* 数据要结构化，易于程序操作（遍历、查找）
* 数据要可扩展，以便增加新的功能

## 项目

### 项目角色

* PM 产品经理
* UE 视觉设计师
* FE 前端开发
* RD 后端开发
* CRD 移动端开发
* QA 测试人员

### 完整项目流程

![image-20210219164003761](https://tva1.sinaimg.cn/large/008eGmZEgy1gnsxn5hrhcj31d80jodpj.jpg)

### Stage1 - 需求分析

* 了解背景
* 质疑需求是否合理
* 需求是否闭环
* 开发难度如何
* 是否需要其他支持
* 不要急于给排期

### Stage2 - 技术方案设计

* 求简，不过渡设计
* 产出文档
* 找准设计重点
* 组内评审
* 和 RD 、CRD 沟通
* 发出会议结论

### Stage3 - 开发

* 如何反馈排期
* 符合开发规范
* 写出开发文档
* 及时单元测试
* Mock API
* Code Review

### Stage4 - 联调

* 和 RD、CRD 技术联调
* 让 UE 确定视觉效果
* 让 PM 确定产品功能

### Stage5 - 测试

* 提测发邮件，抄送项目组
* 测试问题要详细记录
* 有问题及时沟通，QA 和 FE 天生信息不对称

### Stage6 - 上线

* 上线之后及时通知 QA 回归测试
* 上线之后及时同步给 PM 和项目组
* 如有问题，及时回滚。先止损，再排查问题

### 项目沟通

* 多人协作，沟通是最重要的事情
* 每日一沟通（如站会），有事说事，无事报平安
* 及时识别风险，及时汇报

### PM 加需求怎么办？

* 不能拒绝，走需求变更流程即可
*  如果公司有规定，则按规定走
* 否则，发起项目组和 leader 的评审，重新评估排期