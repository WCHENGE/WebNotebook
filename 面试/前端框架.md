## Vue 组件使用

### 1. props 和 $emit

### 2. 组件间通讯-自定义事件

### 3. 组件生命周期

![vue Lifecycle](https://tva1.sinaimg.cn/large/008eGmZEgy1gnacneg4xej30u023zt9s.jpg)

## Vue 高级特性

### 1. 自定义 v-model

```vue
<template>
	<input type="text" :value="text1" @input="$emit('change1', $event.target.value)" />
<!-- 
  1. 上面的 input 使用了 :value 而不是 v-model
  2. 上面的 change1 和 model.event1 要对应起来
  3. text1 属性对应起来
-->
</template>
<script>
export default {
  model: {
    prop: 'text1',
    event: 'change1'
  },
  props: {
    text1: String,
    default: () => ''
  }
}
</script>
```

### 2. $nextTick

* Vue 是异步渲染（原理部分会详细讲解）；
* data 改变之后，DOM 不会立刻渲染；
* $nextTick 会在 DOM 渲染之后被触发，以获取最新 DOM 节点；

```vue
<template>
  <div id="app">
    <ul ref="uli">
      <li v-for="(item, index) in list" :key="index">
        {{item}}
  		</li>
  	</ul>
    <button>添加一项</button>
  </div>
</template>
<script>
export defualt {
	name: 'app',
  data: () => ({
    list: ['a', 'b', 'c']
  }),
  methods: {
    addItem() {
      this.list.push(`${Date.now()}`)
      this.list.push(`${Date.now()}`)
      this.list.push(`${Date.now()}`)
      
      // 1. 异步渲染，$nextTick 待 DOM 渲染完再回调
      // 2. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次
      this.$nextTick(() => {
        const ulElem = this.$refs.uli
        console.log(ulElem.childNodes.length)
      })
    }
  }
}
</script>
```

### 3. slot

* 基本使用

* 作用域插槽

* 具名插槽

  ```vue
  <!-- NamedSolt 组件 -->
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
  
  <!-- parent 组件 -->
  <NamedSlot>
    <template v-slot:header>
      <h1>将插入到 header slot 中</h1>
    </template>
    <p>将插入到 main slot 中，即为命名的 slot</p>
    <template v-slot:footer>
    <p>将插入到 footer slot 中</p>
    </template>
  </NameSlot>
  ```
  

### 4. 动态组件

* 用法：`<component :is="component-name" />`
* 需要根据数据，动态渲染的场景。即组件类型不确定。

### 5. 异步组件

* `import()`函数
* 按需加载，异步加载大组件

```vue
<srcipt>
  components: {
    FormDemo: () => import('../Baseuse/FormDemo.vue')
  }
</script>
```

### 6. Keep-alive

* 缓存组件
* 频繁切换，不需要重复渲染
* Vue 常见性能优化

```vue
<template>
  <div>
    <button @click="changeState('A')">A</button>
    <button @click="changeState('B')">B</button>
    <button @click="changeState('C')">C</button>
    <keep-alive>
      <KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
    </keep-alive>
  </div>
</template>
```

### 7. mixin

* 多个组件有相同的逻辑，抽离出来；
* mixin 并不是完美的解决方案，会有一些问题；
* Vue 3 提出的 Composition API 旨在解决这些问题；

```vue
<template>
  <div>
    <p>{{name}}{{major}}{{city}}</p>
    <button @click="showName">显示姓名</button>
  </div>
</template>

<script>
import myMixin from './mixin'
export default {
  mixins: [myMixin],	// 可以添加多个，会自动合并起来
  data: () => ({
    name: 'shuangyue',
    major: 'web 前端'
  }),
  mounted() {
    console.log('component mounted', this.name)
  },
  methods: {},
}
</script>
```

```vue
<!-- mixin -->
<script>
export default {
  data: () => ({
    city: 'beijing'
  }),
  mounted() {
    console.log('mixin mounted', this.name)
  },
  methods: {
    showName() {
      console.log(this.name)
    }
  }
}
</script>
```

**mixin 的问题：**

* 变量来源不明确，不利于阅读；
* 多 mixin 可能会造成命名冲突；
* mixin 和组件可能出现多对多的关系，复杂度较高；



## Vuex 使用

![vuex](https://tva1.sinaimg.cn/large/008eGmZEgy1gnb9wfuqvcj30jh0fbwef.jpg)


### 1. Vuex 基本概念

#### 1.1 state

#### 1.2 getters

#### 1.3 mutation

#### 1.4 action

### 2. 用于 Vue 组件

#### 2.1 dispatch

#### 2.2 commit

#### 2.3 mapState

#### 2.4 mapGetters

#### 2.5 mapMutations

#### 2.6 mapActions

## Vue-router 使用

### 1. 路由模式（hash、H5 history）

* hash 模式（默认），如 `http://abc.com/#/user/10`
* H5 history 模式，如`http://abc.com/user/20`
* 后者需要 server 端支持，因此无特殊需求可选择前者

### 2. 路由配置（动态路由、懒加载）

```javascript
const router = new VueRouter({
  mode: 'history',	// 使用 H5 history 模式
  routes: [...]
})
```

**动态路由配置：**

```javascript
const user = {
  // 获取参数如 10 20
  template: '<div>User {{ $route.params.id }}</div>'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头，能命中 `/user/10`、`/user/20` 等格式的路由
    { path: '/user/:id', component: User }
  ]
})
```

**路由-懒加载：**

```javascript
export default new VueRouter({
  routes: [
    {
      path: '/',
      component: () => import('../components/Navigator')
    },
    {
      path: '/feedback',
      component: () => import('../components/FeedBack')
    }
  ]
})
```

## Vue 原理

### 1. 组件化和 MVVM

#### 1.1 组件化基础

* “很久以前”就有组件化

  * asp、jsp、php 已经有组件化了
  * nodejs 中也有类似的组件化

  ![CC2977CB-DF53-427A-A217-15B1B2F388FB_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjvkdv6ej31n80hz42g.jpg)

  ![E13C2DB3-C978-4AAA-BC63-31DA5EC0D908_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbjvouc1vj31m80t50x4.jpg)

* 数据驱动视图（MVVM，setState）

  * 传统组件，只是静态渲染，更新还要依赖与操作 DOM；

  * 数据驱动视图 - Vue MVVM

    ![Vue MVVM](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk1zls4pj318g0nmwfe.jpg)

  * 数据驱动视图 - React setState

### 2. 响应式原理

* 组件 data 的数据一旦变化，立刻触发视图的更新；
* 实现数据驱动视图的第一步；

![E2A1FE7C-4AD9-4750-BA02-32EB9FB15FA4_1_201_a](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk88omg5j31o30pbq6h.jpg)

实现响应式：

* 核心 API - Object.defineProperty
* 如何实现响应式，代码演示
* Object.defineProperty 的一些缺点（Vue3.0 启用 Proxy）

Proxy 有兼容性问题：

* Proxy 兼容性不好，且无法 polyfill
* Vue2.x 还会存在一段时间，所以都得学

**Object.defineProperty 基本用法：**

```javascript
const data = {}
const name = 'zhangsan'
Object.defineProperty(data, 'name', {
  get: function() {
    console.log('get')
    return name
  },
  set: function(newVal) {
    console.log('set')
    name = newVal
  }
})

// 测试
console.log(data.name)	// get zhangsan
data.name = 'list'	// set
```

* 监听对象，监听数组
* 复杂对象，深度监听
* Object.defineProperty 几个缺点
  * 深度监听，需要递归到底，一次性计算量大；
  * 无法监听新增属性/删除属性（Vue.set / Vue.delete）
  * 无法原声监听数组，需要特殊处理

```javascript

```

### 3. 虚拟 DOM （Virtual DOM）和 diff 算法

* vdom 是实现 vue 和 React 的重要基石；
* diff 算法是 vdom 中最核心、最关键的部分；

> * DOM 操作非常耗费性能
> * 以前用 jQuery，可以自行控制 DOM 操作的时机，手动调整
> * Vue 和 React 是数据驱动视图，如何有效控制 DOM 操作？
>   * 有了一定复杂度，想减少计算次数比较难
>   * 能不能把计算，更多的转移为 JS 计算？因为 JS 执行速度很快
>   * vdom - 用 JS 模拟 DOM 结构，计算出最小的变更，操作 DOM

![IMG_2100](https://tva1.sinaimg.cn/large/008eGmZEgy1gnch5440hbj31dt0u0wp7.jpg)

**通过 snabbdom 学习 vdom**

* 简洁强大的 vdom 库，易学易用
* Vue 参考它实现的 vdim 和 diff
* [https://github.com/snabbdom/snabbdom](snabbdom)

**diff 算法**

* diff 算法是 vdom 中最核心、最关键的部分；
* diff 算法能在日常使用 Vue、React 中体现出来（如 key）

**diff 算法概述**

* diff 即对比，是一个广泛的概念，如 Linux diff 命令、git diff 等
* 两个 js 对象也可以做 diff，如 [https://github.com/cujojs/jiff]()
* 两颗树做 diff，如这里的 vdom diff

![IMG_2101](https://tva1.sinaimg.cn/large/008eGmZEgy1gnchp36djej31fc0oytn3.jpg)

**树 diff 的时间复杂度 O(n^3)**

* 第一，遍历 tree1
* 第二，遍历 tree2
* 第三，排序

如 1000 个节点，要计算 1 亿次，算法不可用。

**优化时间复杂度到 O(n)**

* 只比较同一层级，不跨级比较；
* tag 不相同，则直接删掉重建，不再深度比较；
* tag 和 key，两者都相同，则认为是相同节点，不再深度比较；

![86A6566A-4876-4E51-839C-AF0924368D37_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gnchz98sg6j30ya0hp76m.jpg)

![A8084E13-3FAC-4632-AD4E-57746605006D_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gnci01x27kj310i0gmjte.jpg)

**vdom 和 diff 总结：**

* 细节不重要，updateChildren 的过程也不重要，不要讲究；
* vdom 核心概念很重要：h、vnode、patch、diff、key 等；
* vdom 存在的价值更加重要：数据驱动视图，控制 DOM 操作；

### 4. 模版编译

* 模版是 Vue 开发中最常用的部分，即与使用相关联的原理
* 它不是 html，有指令、插值、JS 表达式，到底是什么？
* 面试不会直接问，但会通过“组件渲染和更新过程”考察

#### 4.1 前置知识：JS 的 with 语法

* 改变`{}`内自由变量的查找规则，当做 obj 属性来查找；
* 如果找不到匹配的 obj 属性，就会报错；
* with 要慎用，它打破了作用域的规则，易读性变差；

![image-20210206190727267](https://tva1.sinaimg.cn/large/008eGmZEgy1gne0ui5fi3j31js0ia4d9.jpg)

#### 4.2 `vue-template-complier` 将模版编译为 render 函数

* 模版不是 html ，有指令、插值、JS 表达式，能实验判断、循环♻️；
* html 是标签语言，只有 JS 才能实现判断、循环（图灵完备）
* 因此，模版一定是转换为某种 JS 代码，即编译模版；

#### 4.3 执行 render 函数生成 vnode

* 模版编译为 render 函数，执行 render 函数返回 vnode；
* 基于 vnode 再执行 patch 和 diff （后面会讲）；
* 使用 webpack vue-loader ，会在开发环境下编译模版（重要）；

![image-20210206193309521](https://tva1.sinaimg.cn/large/008eGmZEgy1gne1l76ov1j31as0tok59.jpg)

> * 讲完模板编译，再讲这个 render，就比较好理解了；
> * 在有些复杂情况中，不能用 template，可以考虑用 render；
> * React 一直都用 render（没有模板），和这里一样；

### 5. 组件渲染过程

#### 5.1 初次渲染过程

* 解析模板为 render 函数（或在开发环境已完成，vue-loader）
* 触发响应式，监听 data 属性 getter、setter
* 执行 render 函数，生成 vnode，patch(elem, vnode)

![image-20210206195107914](https://tva1.sinaimg.cn/large/008eGmZEgy1gne23wos8xj31ka0s8dup.jpg)

#### 5.2 更新过程

* 修改 data，触发 setter（此前在 getter 中已被监听）；
* 重新执行 render 函数，生成 newVnode；
* patch(vnode, newVnode)

![image-20210206195405733](https://tva1.sinaimg.cn/large/008eGmZEgy1gne26z65gxj311k0ru7en.jpg)

#### 5.3 异步渲染

* 回顾 `$nextTick`；
* 汇总 data 的修改，一次性更新视图；
* 减少 DOM 操作次数，提高性能；

![image-20210206200139144](https://tva1.sinaimg.cn/large/008eGmZEgy1gne2eus8ufj30ng0e044t.jpg)

### 6. 前端路由

![image-20210206211021450](https://tva1.sinaimg.cn/large/008eGmZEgy1gne4ecq3dgj31jq0o0e0f.jpg)

#### 6.1 hash 的特点

* hash 变化会触发网页跳转，即浏览器的前进、后退；
* hash 变化不会刷新页面，SPA 必需的特点；
* hash 永远不会提交到 server 端（前端自生自灭）；

```javascript
window.onhashchange = (event) => {
  console.log('old url', event.oldURL)
  console.log('new url', event.newURL)
  console.log('hash', location.hash)
}

// 页面初次加载、获取 hash
document.addEventListener('DOMContentLoaded', () => {
  console.log('hash:', location.hash)
})

// JS 修改 URL
document.getElementById('btn1').addEventListener('click', {
  location.hash = '#/user'
})
```

#### 6.2 H5 history

* 用 URL 规范的路由，但跳转时不刷新页面；
* `history.pushState`
* `window.onpopstate`

## Vue 真题

### 1. `v-show` 和 `v-if` 的区别？

* v-show 通过 CSS display 控制显示和隐藏；
* v-if 组件是真正的渲染和销毁，而不是显示和隐藏；
* 频繁切换显示状态用 v-show，否则用 v-if ；

### 2. 为何在 v-for 中使用 key 属性

* 必须用 key ，且不能是 index 和 random ；
* diff 算法中通过 tag 和 key 来判断，是否是 sameNode ；
* 减少渲染次数，提升渲染性能；

### 3. 描述一下 Vue 组件生命周期（父子组件）？

* 单组件生命周期图；
* 父子组件生命周期关系；

### 4. Vue 组件如何通讯（常见）？

* 父子组件 `props` 和 `this.$emit`
* 自定义事件 `event.$no`、`event.$off`、`event.$emit`
* `Vuex`

### 5. 描述组件渲染和更新的过程？

![image-20210206215548161](https://tva1.sinaimg.cn/large/008eGmZEgy1gne5pm53spj311c0l4dni.jpg)

### 6. 双向数据绑定 v-model 的实现原理

* input 元素的 value = this.name
* 绑定 input 事件 this.name = $event.target.value
* Data 更新触发 re-render

### 7. 对 MVVM 的理解

![Vue MVVM](https://tva1.sinaimg.cn/large/008eGmZEgy1gnbk1zls4pj318g0nmwfe.jpg)

### 8. computed 有何特点

* 缓存，data 不变不会重新计算；
* 提高性能

### 9. 为何组件 data 必须是一个函数？

```javascript
export default {
  name: 'app',
  data() {
    return {
      name: 'vue'.,
      list: ['a', 'b', 'c']
    }
  },
  methods: {
    changeName() {
      this.name = 'shuangyue'
    },
    
  }
}
```

* 组件是对 Vue class 实例化；
* 组件 data 在函数作用域内可以避免变量对全局实例化属性的污染；

### 10. ajax 请求应该放在哪个生命周期

* `mounted`
* JS 是单线程的，ajax 异步获取数据；
* 放在 mounted 之前没有用，只会让逻辑更加混乱；

### 11. 如何将组件所有 props 传递给子组件？

* `$props`
* `<User v-bind="$props">`

### 12. 如何自己实现 v-model

```vue
<template>
  <input type="text" :value="text" @input="$emit('change', $event.target.value)" />
  <!-- 
    注意：
    第一，上面使用 :value 而没用 v-model
    第二，上面的 change 和 model.event 对应起来即可，名字自己该
  -->
</template>
<script>
export default {
  model: {
    prop: 'text',	// 对应到 props text
    event: 'change'
  },
  props: {
    text: String
  }
}  
</script>
```

### 13. 多个组件有相同的逻辑，如何抽离？

* `mixin`
* 以及 mixing 的一些缺点

### 14. 何时要使用异步组件？

* 加载大组件；
* 路由异步加载；

### 15. 何时需要使用 keep-alive ？

* 缓存组件，不需要重复渲染；
* 如多个静态 tab 页的切换；
* 优化性能；

### 16. 何时需要使用 beforeDestory

* 解绑自定义事件 `event.$off`；
* 清除定时器；
* 解绑自定义的 DOM 事件，如 window scroll 等；

### 17. 什么是作用域插槽？

```vue
// 子组件
<template>
  <a :href="url">
    <slot :website="website">
      {{website.subTitle}}
    </slot>
  </a>
</template>
<script>
export default {
  name: 'ScopedSlotDemo',
  props: ['url'],
  data() {
    return {
      website: {
        url: 'http://wangEditor.com/',
        title: 'wangEditor',
        subTitle: '轻量级富文本编辑器'
      }
    }
  }
}
</script>

// 父组件
<ScopedSlotDemo :url="website.url">
  <template v-slot="slotProps">
    {{ /* slotProps 名字可自定义 */ }}
    {{slotProps.website.title}}
  </template>
</ScopedSlotDemo>
```

### 18. Vuex 中 action 和 mutation 有和区别？

* `action` 中可以处理异步，`mutation`不可以；
* `mutation`做原子操作；
* `action` 可以整合多个 `mutation`；

### 19. Vue-router 常用的路由模式

* hash 默认；
* H5 history（需要服务端支持）；
* 两者比较

### 20. 如何配置 Vue-router 异步加载

```javascript
export default new VueRouter({
  routes: [
    {
      path: '/',
      component: () => import('../components/Navigator')
    },
    {
      path: '/feedback',
      component: () => import('../components/FeedBack')
    }
  ]
})
```

### 21. 请用 vnode 描述一个 DOM 结构？

```html
<div id="div1" class="container">
  <p>vdom</p>
  <ul style="font-size: 20px">
    <li>a</li>
  </ul>
</div>
```

```json
{
  tag: 'div',
  props: {
    className: 'container',
    id: 'div1'
  },
  children: [
    {
      tag: 'p',
      children: 'vdom'
    },
    {
      tag: 'ul',
      props: { style: 'font-size: 200px' },
      children: [
        {
          tag: 'li',
          children: 'a',
        }
      ]
    }
  ]
}
```

### 22. 监听 data 变化的核心 API 是什么？

* `Object.defineProperty`
* 以及深度监听、监听数组
* 有何缺点

### 23. Vue 如何监听数组变化？

* `Object.defineProperty` 不能监听数组变化；
* 重新定义原型，重写 push、pop 等方法，实现监听；
* Proxy 可以原生支持监听数组变化；

### 24. 请描述响应式原理

* 监听 data 变化；
* 组件渲染和更新的流程；

### 25. diff 算法的事件复杂度

* O(n)
* 在 O(n^3) 基础上做了一些调整

### 26. 简述 diff 算法过程

* patch(elem, vnode) 和 patch(vnode, newVnode)
* patchVnode 和 addVnodes 和 removeVnodes
* updateChildren （key 的重要性）

### 27. Vue 为何是异步渲染，$nextTick 何用？

* 异步渲染（以及合并 data 修改），以提高渲染性能；
* $nextTick 在 DOM 更新完之后，触发回调；

### 28. Vue 常用性能优化方式

* 合理使用 v-show 和 v-if ；
* 合理使用 computed ；
* v-for 时加 key，以及避免和 v-if 同时使用；
* 自定义事件、DOM 事件及时销毁；
* 合理使用异步组件；
* 合理使用 keep-alive ；
* data 层级不要太深；
* 使用 vue-loader 在开发环境做模版编译（预编译）；
* webpack 层面的优化；
* 前端通用的性能优化，如图片懒加载；
* 使用 SSR ；

## Vue3 

**Vue 3 升级内容：**

* 全部用 ts 重写（响应式、vdom、模版编译等）
* 性能提升，代码量减少
* 会调整部分 API

Vue 2.x 马上就要过时了吗？

* Vue 3 从正式发布到推广开来，还需要一段时间；
* Vue 2.x 应用范围非常广，有大量项目需要维护、升级；
* Proxy 存在浏览器兼容性问题，且不能 polyfill ；

### 1. Proxy 实现响应式

**Object.defineProperty 的缺点：**

* 深度监听需要一次性递归；
* 无法监听新增属性、删除属性（Vue.set、Vue.delete）；
* 无法原生监听数组，需要特殊处理

#### 1.1 基本使用

```javascript
const data = {
  name: 'zhangsan',
  age: 20,
}

const proxyData = new Proxy(data, {
  get(target, key, receiver) {
    const result = Reflect.get(target, key, receiver)
    console.log('get', key)
    return result	// 返回结果
  }
  set(target, key, val, receiver) {
    const result = Reflect.set(target, key, val, receiver)
    console.log('set', key, val)
    return result	// 是否设置成功
  }
  deleteProperty(target, key) {
    const result = Reflect.deleteProperty(target, key)
    console.log('delete property', key)
    return result	// 是否删除成功
  }
})
```

#### 1.2 Reflect

* 和 Proxy 能力一一对应
* 规范化、标准化、函数式
* 替代掉 Object 上的工具函数

#### 1.3 实现响应式

```javascript
// 创建响应式
function reactive(target = {}) {
  if (typeof target !== 'object' || target == null) {
    // 不是对象或数组，则返回
    return target
  }
  
  // 代理配置
  const proxyConf = {
    get(target, key, receiver) {
      const ownKeys = Reflect.ownKeys(target)
      if (ownKeys.includes(key)) {
        console.log('get', key)	// 监听
      }
      const result = Reflect.get(target, key, receiver)
      // 深度监听
      return reactive(result)
    }
    
    set(target, key, val, receiver) {
      // 重复的数据，不处理
      if (val === target[key]) {
        return true
      }
      const ownKeys = Reflect.ownKeys(target)
      if (ownKeys.includes(key)) {
        console.log('已有的 key', key)
      } else {
        console.log('新增的 key', key)
      }
      const result = Reflect.set(target, key, val, receiver)
      console.log('set', key, val)
      return result	// 是否设置成功
    }
    
    deleteProperty(target, key) {
      const result = Reflect.deleteProperty(target, key)
      console.log('delete property', key)
      return result	// 是否删除成功
    }
  }
  
  // 生成代理对象
  return new Proxy(target, proxyConf)
}

// 测试数据
const data = {
  name: 'zhangsan',
  age: 20,
  info: {
    city: 'beijing'
  }
}

const proxyData = reactive(data)
```

**proxy 实现响应式：** 

* 深度监听，性能更好；
* 可监听新增、删除属性；
* 可监听数组变化；



























