## HTML

### 1. 如何理解 HTML 语义化？

* 让人更容易读懂（增加代码可读性）；
* 让搜索引擎更容易读懂（SEO）；

### 2. 块级元素 & 内联元素 ？

* display：block / table；

  > 有 div、h1、h2、table、ul、ol、p 等。

* display：inline / inline-block；

  >有 span、img、input、button 等。

## CSS 布局

### 1. 盒模型宽度的计算

```html
<!-- 如下代码，请问 div1 的 offsetWidth 是多大？-->
<style>
  #div1 {
    width: 100px;
    padding: 10px;
    border: 1px solid #ccc;
    margin: 10px;
  }
</style>

<div id="div1"></div>
```

> 定义：offsetWidth = (内容宽度 + 内边距 + 边框)，无外边距。
>
> 因此，答案是 122px；
>
> 补充：如果让 offsetWidth 等于 100px，该如何做？
>
> `box-sizing: border-box`

### 2. Margin 纵向重叠问题？

```html
<!-- 如下代码，AAA 和 BBB 之间的距离是多少？-->
<style>
  p {
    font-size: 16px;
    line-height: 1;
    margin-top: 10px;
    margin-bottom: 15px;
  }
</style>

<p>AAA</p>
<p></p>
<p></p>
<p></p>
<p>BBB</p>
```

>相邻元素的 margin-top 和 margin-bottom 会发生重叠
>
>空白内容的 `<p></p>`也会重叠
>
>答案：15px

### 3. Margin 负值问题

* margin-top 和 margin-left 负值，元素向上、向左移动；
* margin-right 负值，右侧元素左移，自身不受影响；
* margin-bottom 负值，下方元素上移，自身不受影响；

### 4. BFC 理解与应用

#### 4.1 什么是 BFC？如何应用？

* Block format context，块级格式化上下文；
* 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素；

#### 4.2 形成 BFC 的常见条件？

* float 不是 none；
* position 是 absolute 或 fixed；
* overflow 不是 visible；
* display 是 flex 或 inline-block 等。

#### 4.3 BFC 的常见应用

* 清除浮动；

### 5. float 布局

#### 5.1 圣杯布局和双飞翼布局的目的

* 三栏布局，中间一栏最先加载和渲染（内容最重要）；
* 两侧内容固定，中间内容随宽度自适应；
* 一般用于 PC 网页。

```html
<!-- 圣杯布局 -->
<div id="container">
  <div id="center" class="column">this is center</div>
  <div id="left" class="column">this is left</div>
  <div id="right" class="column">this is right</div>
</div>
<style type="text/css">
  .column {
    float: left;
  }
  #container {
    padding-left: 200px;
    padding-right: 150px;
  }
  #center {
    width: 100%;
  }
  #left {
    display: relative;
    width: 200px;
    margin-left: -100%;
    right: 200px;
  }
  #right {
    width: 150px;
    margin-right: -150px;
  }
</style>
```

```html
<!-- 双飞翼布局 -->
<div id="main" class="col">this is center</div>
<div id="left" class="col">this is left</div>
<div id="right" class="col">this is right</div>
<style type="text/css">
  #main {
    width: 100%;
    margin: 0 190px 0;
  }
  #left, #right {
    width: 190px;
  }
  #left {
    margin-left: -100%;
  }
  #right {
    margin-left: -190px;
  }
</style>
```

#### 5.2 圣杯布局和双飞翼布局的技术总结

* 使用 float 布局
* 两侧使用 margin 负值，以便和中间内容横向重叠；
* 防止中间内容被两侧覆盖，一个用 padding ，一个用 margin ；

#### 5.3 手写清除浮动

```css
/* 手写 clear fix */
.clearfix:after {
  content: '';
  display: table;
  clear: both;
}
.clearfix {
  *zomm: 1; /* 兼容 IE 低版本 */
}
```

### 6. flex 布局

#### 6.1 常用语法回顾

* flex-direction：决定主轴的方向（row | row-reverse | column | column-reverse）

* flex-warp：是否换行（nowrap | wrap | wrap-reverse）

* flex-flow：`<flex-direction>`和`<flex-wrap>`的简写形式，默认值为row nowrap。

* justify-content：项目在主轴上的对齐方式（flex-start | flex-end | center | space-between | space-around）

* align-items：项目在交叉轴上的对齐方式（stretch | flex-start | flex-end | center | baseline）

* align-content：项目在交叉轴上定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

* order：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

* flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

* flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

* flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。

* flex：属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后面哥属性可选。

  > 该属性有两个快捷值：auto（1 1 auto）和 none（0 0 auto）。
  >
  > 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

* align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为  auto，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

#### 6.2 flex 画三个点的色子

```css
/* flex 画三个点的色子 */
.box {
  display: flex;	/* flex 布局 */
  justify-content: space-between;	/* 两端对齐 */
}
.item {
  /* 背景色、大小、边框等 */
}
.item:nth-child(2) {
  align-self: center;	/* 第二项居中对齐 */
}
.item:nth-child(3) {
  align-self: flex-end;	/* 第三项尾对齐 */
}
```

### 7. CSS - 定位

#### 7.1 absolute 和 relative 分别依据什么定位？

* relative 依据自身定位；

* absolute 依据最近一层的定位元素定位；

  > 定位元素：
  >
  > * absolute
  > * relative
  > * fixed
  > * body

#### 7.2 居中对齐有哪些实现方式？

##### 7.2.1 水平居中

* inline 元素：text-align：center
* block 元素：margin：auto
* absolute 元素：left：50% + margin-left 负值

##### 7.2.2 垂直居中

* inline 元素：line-height 的值等于 height 值
* absolute 元素：top：50% + margin-top 负值
* absolute 元素：transform（-50%，-50%）
* absolute 元素：top，left，bottom，right = 0 `+` margin：auto

### 8. CSS - 图文样式

#### 8.1 line-height 如何继承

```html
<!-- 如下代码，p 标签的行高将会是多少？答案：40px -->
<style>
  body {
    font-size: 20px;
    line-height: 200%;
  }
  p {
    font-size: 16px;
  }
</style>
<body>
  <p>AAAA</p>
</body>
```

* 写具体数值，如 30px，则继承该值（比较好理解）
* 写比例，如 2 / 1.5 ，则继承该比例（比较好理解）
* 写百分比，如 200%，则继承**计算出来的值**（考点）

### 9. CSS - 响应式

#### 9.1 rem 是什么？

> rem 是一个长度单位：
>
> * px ，绝对长度单位，最常用；
> * em ，相对长度单位，相对于父元素，不常用；
> * rem，相对长度单位，相对于根元素，常用于响应式布局；

#### 9.2 响应式布局的常用方案

* media-query，根据不同的屏幕宽度设置根元素 font-size；
* rem，基于根元素的相对单位；

#### 9.3 CSS - 响应式 - vw / vh

rem 的弊端：“阶梯”性

```css
@media only screen and (max-width: 374px) {
  html { font-size: 86px; }
}
@media only screen and (min-width: 375px) and (max-width: 423px) {
  html { font-size: 100px; }
}
@media only screen and (min-width: 414px) {
  html { font-size: 110px; }
}
```

网页视口尺寸：

* window.screen.height	// 屏幕高度
* window.innerHeight	// 网页视口高度
* document.body.clientHeight	// body 高度

vw / vh

* vh 网页视口高度的 1 / 100
* vw 网页视口高度的 1 / 100
* vmax 取两者最大值；
* vmin 取两者最小值；

## javascript 基础知识

### 1. 变量类型和计算

值类型：Number、String、Boolean、null、undefined、Symbol；

引用类型：Object、Array、Function

```javascript
// 常见值类型
let a						// undefined
const s = 'abc'					// String
const n = 100					// Number
const b = true					// Boolean
const s = Symbol('s')				// Symbol
```

```javascript
// 常见引用类型
const obj = { x: 100 }
const arr = ['a', 'b', 'c']

const n = null		// 特殊引用类型，指针指向为空地址

function fn() {}	// 特殊引用类型，但不用于存储数据，所以没有“拷贝、复制函数”这一说
```

#### 1.1 typeof 能判断哪些类型？

* 识别所有值类型；
* 识别函数；
* 判断是否是引用类型（不可再细分）

```javascript
// 判断所有值类型
let a;						typeof a	// 'undefined'
const str = 'abc'				typeof str	// 'string'
const n = 100					typeof n	// 'number'
const b = true					typeof b	// 'boolean'
const s = Symbol('s')				typeof s	// 'symbol'

// 能判断函数
typeof console.log 		// 'function'
typeof function () {}		// 'function'

// 能识别引用类型（不能在继续识别）
typeof null			// 'object'
typeof ['a', 'b']		// 'object'
typeof { x: 100 }		// 'object'
```

#### 1.2 何时使用 === 何时使用 == 

除了 `== null` 之外，其它都一律用 `===`。

```javascript
const obj = { x: 100 }
if (obj.a == null) { }
// 相当于：
// if (obj.a === null || obj.a === undefined) { }
```

#### 1.3 值类型和引用类型的区别？

值类型变量的值是存储在栈中，而引用类型变量存储在栈中的是指向堆中的数组或者对象的**地址**，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。

1. 值类型：
   * 占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）
   * 保存于复制的是值本身；
   * 使用 typeof 检测数据的类型；
   * 基本类型数据是值类型；
2. 引用类型：
   * 占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）
   * 保存于复制的是指向对象的一个指针；
   * 使用 instanceof 检测数据类型；
   * 使用 new() 方法构造出的对象是引用型；

```javascript
// 例题：
const obj1 = { x: 100, y: 200 }
const obj2 = obj1
let x1 = obj1.x
obj2.x = 101
x1 = 102
console.log(obj1)	// { x: 101, y: 200 }
```

#### 1.4 手写深拷贝

```javascript
function deepClone (obj) {
  // obj 是 null，或者不是对象和数组，直接返回
  if (typeof obj !== 'object' || obj == null) return obj
  // 初始化返回结果
  let result
  (obj instanceof Array) ? result = [] : result = {}
  for (let key in obj) {
    // 保证 key 不是原型的属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key])
    }
  }
  return result
}
```

#### 1.5 变量计算 - 类型转换

* 字符串拼接

  ```javascript
  const a = 100 + 10	// 110
  const b = 100 + '10'	// '10010'
  const c = true + '10'	// 'true10'
  ```

* == 运算符

  ```javascript
  100 == '100'			// true
  0 == ''				// true
  0 == false			// true
  false == ''			// true
  null == undefined		// true
  ```

  除了 `== null` 之外，其它都一律用 `===` ，例如

  ```javascript
  const obj = { x: 100 }
  if (obj.a == null) {}
  // 相当于：if (obj.a === null || obj.a === undefined) {}
  ```

* if 语句和逻辑运算

  * truly 变量：!!a === true 的变量
  * falsely 变量：!!a === false 的变量

  ```javascript
  // 以下是 falsely 变量。除此之外都是 truly 变量
  !!0 === false
  !!NaN === false
  !!'' === false
  !!null === false
  !!undefined === false
  !!false === false
  ```

### 2. 原型和原形链

#### 2.1 class 和继承

##### 2.1.1 class

* constructor
* 属性
* 方法

```javascript
class People {
  constructor(name) {
    this.name = name
  }
  eat() {
    console.log(`${this.name} eat something`)
  }
}
```

##### 2.1.2 继承

* extends
* super
* 扩展或重写方法

```javascript
class Student extends People {
  constructor(name, number) {
    super(name)
    this.number = number
  }
  sayHi() {
    console.log(`姓名 ${this.name} 学号 ${this.number}`)
  }
}
```

#### 2.2 类型判断 - instanceof

```javascript
[] instanceof Array		// true
[] instanceof Object		// true

{} instanceof Object		// true
```

#### 2.3 原型和原型链

##### 2.3.1 原型关系：

* 每个 `class` 都有显示原型 `prototype`
* 每个实例都有隐式原型 `__proto__`
* 实例的`__proto__`指向对应`class`的`prototype`

```javascript
// class 实际上是函数，可见是语法糖
typeof People		// 'function'
typeof Student		// 'function'

// 隐式原型和显示原型
console.log(xialuo.__proto__)
console.log(Student.prototype)
console.log(xialuo.__proto__ === Student.prototype)
```

##### 2.3.2 基于原型的执行规则

* 获取属性 `xialuo.name`或执行方法`xiauo.sayhi()`时；
* 先在自身属性和方法寻找；
* 如果找不到则去 `__proto__`中寻找；

### 3. 作用域和闭包

#### 3.1 作用域和自由变量

##### 3.1.1 作用域

* 全局作用域
* 函数作用域
* 块级作用域（ES6 新增）

##### 3.1.2 自由变量

* 一个变量在当前作用域没有定义，但被使用了；
* 向上级作用域，一层一层依次寻找，直至找到为止；
* 如果到全局作用域都没找到，则报错 `xx is not defined`；

```javascript
let a = 0
function fn1() {
  let a1 = 100
  
  function fn2() {
    let a2 = 200
    
    function fn3() {
      let a3 = 300
      return a + a1 + a2 + a3
    }
    fn3()
  }
  fn2
}
fn1()
```

#### 3.2 闭包

作用域应用的特殊情况，有两种表现：

* 函数作为参数被传递；
* 函数作为返回值被返回；

```javascript
// 函数作为参数
function print(fn) {
  let a = 200
  fn()
}
let a = 100
function fn() {
  console.log(a)
}
print(fn)	// 100
```

```javascript
// 函数作为返回值
function create() {
  let a = 100
  return function () {
    console.log(a)
  }
}

let fn = create()
let a = 200
fn()	// 100
```

**所有的自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方。**

#### 3.3 this

* 作为普通函数  （this 的指向 window）
* 使用 call、apply、bind  （this 指向传入的参数）
* 作为对象方法被调用  （this 指向对象本身）
* 在 class 方法中调用  （this 指向当前实例化本身）
* 箭头函数 （取它上级作用域的 this）

`this` 取什么样的值，是在函数执行的时候确定的，不是在函数定义的时候确定的。

```javascript
// 1. 作为普通函数调用
function fn1() {
  console.log(this)
}
fn1()	// window

// 2. 使用 call、apply、bind 调用
fn1.call({ x: 100 })	// { x: 100 }

const fn2 = fn1.bind({ x: 200 })
fn2()	// { x: 200 }
```

```javascript
// 3. 作为对象方法被调用
const zhangsan = {
  name: '张三',
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  wait() {
    setTimeout(function() {
      // this === window
      console.log(this)
    })
  }
}
```

```javascript
// 4. 箭头函数
const zhangsan = {
  name: '张三',
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  waitAgain() {
    setTimeout(() => {
      // this 即当前对象
      console.log(this)
    })
  }
}
```

```javascript
// 在 class 方法中调用
class People {
  constructor(name) {
    this.name = name
    this.age = 20
  }
  sayHi() {
    console.log(this)
  }
}
const zhangsan = new People('张三')
zhangsan.sayHi()	// zhangsan 对象
```

#### 题目

* this 的不同应用场景，如何取值？

  > * 当做普通函数被调用    （this 指向 window）
  > * 使用 call、apply、bind    （this 指向取决于传入的参数）
  > * 作为对象方法调用    （this 指向是对象的本身）
  > * 在 class 的方法中调用    （this 指向是当前实例的本身）
  > * 箭头函数    （this 指向是箭头函数的上级作用域）

* 手写 bind 函数

  > ```javascript
  > Function.prototype.bind1 = function() {
  >   // 将参数解析为数组
  >   const args = Array.prototype.slice.call(arguments)
  >   // 获取 this（取出数组第一项，数组剩余的就是传递的参数）
  >   const t = args.shift()
  >   const self = this	// 当前函数
  >   // 返回一个函数
  >   return function() {
  >     // 执行原函数，并返回结果
  >     return self.apply(t, args)
  >   }
  > }
  > ```

* 实际开发中闭包的应用

  * 隐藏数据

    ```javascript
    // 闭包隐藏数据，只提供 API
    function createCache() {
      const data = {}
      return {
        get: function (key) {
          return data[key]
        },
        set: function (key, value) {
          data[key] = value
        }
      }
    }
    ```

### 4. 异步和单线程

#### 4.1 单线程和异步

* JS 是单线程语言，只能同时做一件事；
* 浏览器和 nodejs 已支持 JS 启动**进程**，如 Web Worker；
* JS 和 DOM 渲染共用同一个**线程**，因为 JS 可修改 DOM 结构；
* 遇到等待（网络请求，定时任务）页面不能卡住，所以需要异步；异步是以回调 callback 函数形式调用；

```javascript
// 同步
console.log(100)
alert(200)
console.log(300)
```

```javascript
// 异步 (callback 回调函数)
console.log(100)
setTimeout(function() {
  console.log(200)
}, 1000)
console.log(300)
```

#### 4.2 异步和同步

* 基于 JS 是单线程语言
* 异步不会阻塞代码执行
* 同步会阻塞代码执行

#### 4.3 应用场景

* 网络请求，如 ajax 图片加载
* 定时任务，如 setTimeout

```javascript
// ajax
console.log('start')
$.get('./data1.json', function(data1) {
  console.log(data1)
})
console.log('end')
```

```javascript
// 图片加载
console.log('start')
let img = document.createElement('img')
img.onload = function() {
  console.log('loaded')
}
img.src = '/xxx.png'
console.log('end')
```

```javascript
// setTimeout
console.log(100)
setTimeout(function() {
  console.log(200)
}, 1000)
console.log(300)
```

```javascript
// setInterval
console.log(100)
setInterval(function() {
  console.log(200)
}, 1000)
console.log(300)
```

#### 4.4 callback hell 和 Promise

##### 4.4.1 callback hell

```javascript
// 获取第一份数据
$.get(url1, (data1) => {
  console.log(data1)
  
  // 获取第二份数据
  $.get(url2, (data2) => {
    console.log(data2)
    
    // 获取第三份数据
    $.get(url3, (data3) => {
      console.log(data3)
      
      // 还可能获取更多的数据
    })
  })
})
```

##### 4.4.2 promise

```javascript
function getData(url) {
  return new Promise((resolve, reject) => {
    $.ajax({
      url,
      success(data) {
        resolve(data)
      },
      error(err) {
        reject(err)
      }
    })
  })
}
```

#### 题目

* 同步和异步的区别是什么？

  >* 基于 JS 是单线程语言
  >* 异步不会阻塞代码执行
  >* 同步会阻塞代码执行

* 手写用 Promise 加载一张图片？

  > ```javascript
  > function loadImg(src) {
  >   return new Promise((resolve, reject) => {
  >    const img = document.createElement('img')
  >     img.onload = () => { resolve(img) }
  >     img.onerror = () => {
  >       const err = new Error(`图片加载失败 ${src}`)
  >       reject(err)
  >     }
  >     img.src = src
  >   })
  > }
  > ```

* 前端使用异步的场景有哪些？

  > 网络请求，如 ajax 图片加载
  >
  > 定时任务，如 setTimeout
  >
  > ```javascript
  > // setTimeout 笔试题
  > console.log(1)
  > setTimeout(function() {
  >   console.log(2)
  > }, 1000)
  > console.log(3)
  > setTimeout(function() {
  >   console.log(4)
  > }, 0)
  > console.log(5)
  > 
  > // 1、3、5、4、2
  > ```

### 5. JS 异步 - 进阶

#### 5.1 event loop（事件循环/事件轮询）

* JS 是单线程运行的
* 异步要基于回调来实现
* event loop 就是异步回调的实现原理

#### 5.2 JS 如何执行？

* 从前到后，一行一行执行
* 先把同步代码执行完，再执行异步代码
* 如果某一行执行报错，则停止下面代码的执行

#### 5.3 event loop 过程

![E4397F7E-41F6-4DA6-83E4-552EDF61FC7A_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm3w23pjj30wq0ij0tp.jpg)

1. 同步代码，一行一行放在 Call Stack 执行；
2. 遇到异步代码（定时、网络请求），会先“记录”下，等待时机；
3. 时机到了，就移动到 Callback Queue；
4. 如 Call Stack 为空（即同步代码执行完）Event Loop 开始工作；
5. 轮询查找 Callback Queue，如果不为空，则移动到 Call Stack 执行；
6. 然后继续轮询查找（永动机一样）；

#### 5.4 DOM 事件和 event loop

* JS 是单线程的
* 异步（setTimeout，ajax等）使用回调，基于 event loop；
* DOM 事件也使用回调，基于 event loop

#### 5.5 Promise

* 三种状态
  * pending resolved rejected
  * pending -> resolved  或  pending -> rejected
  * 变化不可逆
* 状态的表现和变化
  * pending 状态，不会触发 then 和 catch 方法；
  * resolved 状态，会触发后续的 then 回调函数；
  * reject 状态，会触发后续的 catch 回调函数；
* then 和 catch 对状态的影响
  * then 正常返回 resolved，里面有报错则返回 rejected；
  * catch 正常返回 resolved，里面有报错则返回 rejected；

#### 5.6 async / await

* 异步回调 callback hell；
* Promise then catch 链式调用，但也是基于回调函数；
* async / await 是同步语法，彻底消灭回调函数；

#### 5.7 async / await 和 Promise 的关系

async / await 是消灭异步回调的终极武器，但和 Promise 并不互斥，反而两者相辅相成。

* 执行 async 函数，返回的是 Promise 对象；
* await 相当于 Promise 的 then；
* try...catch 可捕获异常，代替了 Promise 的 catch；

#### 5.8 异步的本质

* async / await 是消灭异步回调的终极武器；
* JS 还是单线程，还得是有异步，还得是基于 event loop；
* async / await 只是一个语法糖，但这颗糖真香！

```javascript
async function async1 () {
  console.log('async1 start')	// 2
  await async2()
  /* 
    await 的后面，都可以看做是 callback 里的内容，即异步
    类似，event loop ，setTimeout(cb1)
    // setTimeout(function() { console.log('async1 end') })
    // Promise.resolve().then(()=>{console.log('async1 end')})
  */
  console.log('async1 end')	// 5
}

async function async2() {
  console.log('async2')	// 3
}

console.log('script start')	// 1
async1()
console.log('script end')	// 4
// 同步代码已经执行完（event loop）
```

```javascript
async function async1() {
  console.log('async1 start')	// 2
  await async2()
  // 下面三行都是异步回调 callback 的内容
  console.log('async1 end')	// 5
  await async3()
  // 下面一行是异步回调的内容
  console.log('async1 end 2')	// 7
}

async function async2() {
  console.log('async2')	// 3
}

async function async3() {
  console.log('async3')	// 6
}

console.log('script start')	// 1
async1()
console.log('script end')	// 4
// 同步代码执行完 event loop
```

#### 5.9 for ... of

* for ... in （以及 forEach 、for）是常规的同步遍历
* for ... of 常用于异步的遍历

```javascript
function muti(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num * num)
    }, 1000)
  })
}

const nums = [1, 2, 3]
nums.forEach(async(i) => {
  const res = await muti(i)
  console.log(res)	// 1，4，9 同时打印
})
```

```javascript
function muti(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num * num)
    }, 1000)
  })
}

!(async function() {
  for (let i of nums) {
    const res = await muti(i)
    console.log(res)	// 1，4，9 依次打印
  }
})()
```

#### 5.10 微任务（microTask）和宏任务（macroTask）

```javascript
console.log(100)		// 1
// 宏任务
setTimeout(() => {
  console.log(200)		// 4
})
// 微任务
Promise.resolve().then(() => {
  console.log(300)		// 3
})
console.log(400)		// 2
```

* **微任务：** Promise、async / await；
* **宏任务：** setTimeout，setInterval，Ajax，DOM 事件；
* *微任务执行时机比宏任务更早*。

#### 5.11 event loop 和 DOM 渲染

event loop 的过程：

* JS 是单线程的，而且和 DOM 渲染共用一个线程；
* JS 执行的时候，得留一些时机供 DOM 渲染；

每次 Call Stack 清空（即每次轮询结束），即同步任务执行完；都是 DOM 重新渲染的机会，DOM 结构如有改变则重新渲染，然后再去触发下一次 Event Loop。

**微任务和宏任务的区别：**

* **微任务**：DOM 渲染**前**触发，如 Promise

* **宏任务**：DOM 渲染**后**触发，如 setTimeout

```javascript
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container').append($p1).append($p2).append($p3)

// 微任务：DOM 渲染前触发
Promise.resolve().then(() => {
  console.log('length1', $('#container').children().length )	// 3
  alert('Promise then')		// DOM 渲染了吗？ —— NO
})

// 宏任务：DOM 渲染后触发
setTimeout(() => {
  console.log('length2', $('#container').children().length )	// 3
  alert('setTimeout')		// DOM 渲染了吗？ —— YES
})
```

从 event loop 解释，为何微任务执行更早：

* 微任务是 ES6 语法规定的；

* 宏任务是由浏览器规定的；


![81981A1D-302F-4155-B965-12516819731F_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm4p3slyj30w00iy0tv.jpg)

![1469979C-DB70-4391-9851-B6B661C210A2_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm4x2krej30w80it75c.jpg)



#### 题目：

* 请描述 event loop（事件循环/事件轮询）的机制，可画图

* 什么是宏任务和微任务，两者有什么区别？

  > 宏任务：setTimeout，setInterval，Ajax，DOM 事件；
  >
  > 微任务：Promise，async / await；
  >
  > 微任务执行时机比宏任务要早。

* Promise 有哪三种状态？如何变化？

  > * pending	resolved	rejected
  > * pending -> resolved  或 pending -> rejected
  > * 变化不可逆

* 场景题 - promise then 和 catch 的连接

  ```javascript
  // 第一题
  Promise.resolve().then(() => {
    console.log(1)	// 1
  }).catch(() => {
    console.log(2)
  }).then(() => {
    console.log(3)	// 3
  })
  // 1，3
  ```

  ```javascript
  // 第二题
  Promise.resolve().then(() => {
    console.log(1)	// 1
    throw new Error('error1')
  }).catch(() => {
    console.log(2)	// 2
  }).then(() => {
    console.log(3)	// 3
  })
  // 1，2，3
  ```

  ```javascript
  // 第三题
  Promise.resolve().then(() => {
    console.log(1)	// 1
    throw new Error('error1')
  }).catch(() => {
    console.log(2)	// 2
  }).catch(() => {
    console.log(3)
  })
  // 1，2
  ```

* 场景题 - async / await 语法

  ```javascript
  async function fn() {
    return 100
  }
  
  (async function() {
    const a = fn()	    // Promise
    const b = await fn()	// 100
  })()
  ```

  ```javascript
  (async function() {
    console.log('start')	    // start
    const a = await 100
    console.log('a', a)		// 100
    const b = await Promise.resolve(200)
    console.log('b', b)		// 200
    const c = await Promise.reject(300)
    console.log('c', c)
    console.log('end')
  })()		
  // 执行完毕，打印出哪些内容？
  // start，100，200
  ```

* 场景题 - promise 和 setTimeout 的顺序

  ```javascript
  console.log(100)
  setTimeout(() => {
    console.log(200)
  })
  Promise.resolve().then(() => {
    console.log(300)
  })
  console.log(400)
  // 100，400，300，200
  ```

* 场景题 - 外加 async / await 的顺序问题

  ```javascript
  async function async1() {
    console.log('async1 start')	// 2
    await async2()	// 微任务
    console.log('async1 end')		// 6
  }
  
  async function async2() {
    console.log('async2')	        // 3
  }

  console.log('script start')		// 1
  
  setTimeout(function() {	// 宏任务
    console.log('setTimeout')		// 8
  }, 0)
  
  async1()
  
  // 初始化 promise 时，传入的函数会立刻执行
  new Promise(function(resolve) {
    console.log('promise1')		// 4
    resolve()
  }).then(function() {	// 微任务
    console.log('promise2')		// 7
  })
  
  console.log('script end')		// 5
  
  /* 
  同步代码执行完毕（event loop - call stack 被清空）
  执行完毕
  （尝试触发 DOM 渲染）
  触发 event loop，执行宏任务
  */
  ```


#### 总结：

event loop 过程：

* 同步代码，一行一行放在 Call Stack 执行；
* 遇到异步代码（定时、网络请求等），会先“记录”下，等待时机；
* 时机到了，就移动到 Callback Queue；
* 如 Call Stack 为空（即同步代码执行完）Event Loop 开始工作；
* 轮询查找 Callback Queue，如有则移动到 Call Stack 执行；
* 然后继续轮询查找（永动机一样）。

DOM 事件和 event loop：

* JS 是单线程的；
* 异步（setTimeout，ajax 等）使用回调，基于 event loop；
* DOM 事件也使用回调，基于 event loop；

## 从 JS 基础知识到 JS Web API

* JS 基础知识，规定语法（ECMA 262 标准）
* JS Web API，网页操作的 API（W3C 标准）
* 前者是后者的基础，两者结合才能真正实际应用

JS 基础知识：

* 变量类型和计算
* 原型和原型链
* 作用域和闭包

JS Web API：

* DOM
* BOM
* 事件绑定
* Ajax
* 存储

### 1. DOM 操作（Document Object Model）

#### 1.1 DOM 本质

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
  </head>
  <body>
    <div>
      <p>this is p</p>
    </div>
  </body>
</html>
```

DOM 是 Document Object Module 的缩写。大概意思是浏览器给 Javascript 操作网页 Html 文档的一种树状数据结构，可以通过浏览器给 Javascript 设置的可以访问网页文档的全局变量如`document`、`window`来创建、获取、添加、删除浏览器 Html 文档上的节点。

#### 1.2 DOM 节点操作

```javascript
const div1 = document.getElementById('div1')	// 元素
const divList = document.getElementsByTagName('div')	// 集合
console.log(divList.length)
console.log(divList[0])

const containerList = document.getElementsByClassName('container')	// 集合
const pList = document.querySelectorAll('p')		// 集合
```
#### 1.3 DOM 结构操作

* 获取子元素列表，获取父元素

  ```javascript
  // 获取父元素
  const div1 = document.getElementById('div1')
  const parent = div1.parentNode
  
  // 获取子元素列表
  const div1 = document.getElementById('div1')
  const child = div1.childNodes
  ```

* 新增 / 插入节点

  ```javascript
  const div1 = document.getElementBuId('div1')
  // 添加新节点
  const p1 = document.createElement('p')
  p1.innerHTML = 'this is p1'
  div1.appendChild(p1)	// 添加新创建的元素
  // 移动已有节点。(注意是移动)
  const p2 = document.getElementById('p2')
  div1.appendChild(p2)
  ```

* 删除子元素

  ```javascript
  const div1 = document.getElementById('div1')
  const child = div1.childNodes
  div1.removeChild(child[0])
  ```

#### 1.4 property 和 attr 的区别

property 是浏览器提供给 JavaScript 的可以用来获取或修改节点的属性值，如 `className`。

```javascript
var div1 = docement.getElementById('div1')
div1.className = 'banner'
```

attr 是通过 `getAttribute` 和 `setAttribute`来获取或者修改 Html 文档标签上的任意属性值。

```javascript
var p1 = document.getElementById('p1')
p1.setAttribute('data-name', '123')
var attr = p1.getAttribute('data-name')
```

* property：修改对象属性，不会体现到 html 结构中；
* attribute：修改 html 属性，会改变 html 结构；
* 两者都有可能引起 DOM 重新渲染（建议优先考虑使用 property）；


#### 1.5 DOM 性能

DOM 操作非常“昂贵”，避免频繁的 DOM 操作：

* 对 DOM 查询做缓存；
* 将频繁操作改为一次性操作；

##### 1.5.1 DOM 查询做缓存

```javascript
// 不缓存 DOM 查询结果
for (let i = 0; i < document.getElementsByTagName('p').length; i++) {
	// 每次循环，都会计算 length，频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName('p')
const length = pList.length
for(let i = 0; i < length; i++) {
  // 缓存 length，只进行一次 DOM 查询
}
```

##### 1.5.2 将频繁操作改为一次性操作

```javascript
const listNode = document.getElementByd('list')

// 创建一个文档片段，此时还没有插入到 DOM 树中
const frag = document.createDocumentFragment()

// 执行插入
for(let x = 0; x < 10; x++) {
  const li = document.createElement('li')
  li.innerHTML = 'List item' + x
  frag.appendChild(li)
}

// 都完成后，再插入到 DOM 树中
listNode.appendChild(frag)
```

#### 题目

* DOM 是哪种数据结构？

  > 树（DOM 树）

* DOM 操作的常用 API ？

  > DOM 节点操作
  >
  > DOM 结构操作

* attr 和 property 的区别？

  > property：修改对象属性，不会体现到 html 结构中；
  >
  > attribute：修改 html 属性，会改变 html 结构；
  >
  > 两者都有可能引起 DOM 重新渲染；

* 一次性插入多个 DOM 节点，考虑性能？

  ```javascript
  // 创建一个文档片段，此时还没有插入到 DOM 树中
  const frag = document.createDocumentFragment()
  ```

### 2. BOM 操作（Browser Object Model）

#### 2.1 navigator

```javascript
// navigator
const ua = navigator.userAgent
const isChrome = ua.indexOf('Chrome')
console.log(isChrome)
```

#### 2.2 screen

```javascript
// screen
console.log(screen.width)
console.log(screen.height)
```

#### 2.3 location

```javascript
// location
console.log(location.href)
console.log(location.protocol)	// 'http:', 'https:'
console.log(location.pathname)	// '/learn/199'
console.log(location.search)
console.log(location.hash)
```

#### 2.4 history

```javascript
// history
history.back()
history.forwrad()
```

### 3. 事件

#### 3.1 事件绑定

```javascript
const btn = document.getElementById('btn1')
btn.addEventListener('click', event => {
  console.log('clicked')
})
```

```javascript
// 通用的绑定函数
function bindEvent(elem, type, fn) {
  elem.addEventListener(type, fn)
}

const a = document.getEmementById('link1')
bindEvent(a, 'click', e => {
  e.preventDefault()	// 阻止默认行为
  // console.log(event.target)	// 获取触发的元素
  alter('clicked')
})
```

#### 3.2 事件冒泡

```html
// html
<body>
  <div id="div1">
    <p id="p1">激活</p>
    <p id="p2">取消</p>
    <p id="p3">取消</p>
    <p id="p4">取消</p>
  </div>
  <div id="div2">
    <p id="p5">取消</p>
    <p id="p6">取消</p>
  </div>
</body>
```

```javascript
// javascript
const p1 = document.getElementById('p1')
const body = document.body
bindEvent(p1, 'click', e => {
  e.stopPropagation()		// 阻止事件冒泡
  alert('激活')
})
bindEvent(body, 'click', e => {
  alert('取消')
})
```

#### 3.3 事件代理

```html
<div id="div1">
  <a href="#">a1</a>
  <a href="#">a2</a>
  <a href="#">a3</a>
  <a href="#">a4</a>
</div>
<button>
  点击增加一个 a 标签
</button>
```

```javascript
const div1 = document.getElementById('div1')
div1.addEventListener('click', e => {
  event.preventDefault()
  const target = e.target
  if (e.nodeName === 'A') {
  	alert(target.innerHTML)
  }
})
```

> 代码简洁；减少浏览器内存占用；但是，不要滥用。

通用的事件绑定函数：

```javascript
function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
  	fn = selector
    selector = null
  }
  elem.addEventListener(type, event => {
    const target = event.target
  	if (selector) {
      // 代理绑定
      if (target.matches(selector)) fn.call(target, event)
    } else {
    	// 普通绑定
      fn.call(target, event)
    }
  })
}
```

#### 题目：

* 编写一个通用的事件监听函数？

* 描述事件冒泡的流程？

  > 基于 DOM 树形结构；
  >
  > 事件会顺着触发元素往上冒泡；
  >
  > 应用场景：代理

* 无限下拉的图片列表，如何监听每个图片的点击？

  > 事件代理；
  >
  > 用 e.target 获取触发元素；
  >
  > 用 matches 来判断是否是触发元素；



### 4. ajax

#### 4.1 XMLHttpRequest

```javascript
// get 请求
const xhr = new XMLHttpRequest()
xhr.open('GET', '/api', true)	// true 是异步的请求
xhr.onreadystatechange = function() {
  // 这里的函数异步执行，可参考之前 JS 基础中的异步模块
  if (xhr.readyState === 4) {
  	if (xhr.status === 200) {
    	alert(xhr.responseText)
    }
  }
}
xhr.send(null)
```

```javascript
// post 请求
const xhr = new XMLHttpRequest()
xhr.open('POST', 'api', true)
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
  	if (xhr.status === 200) {
    	alert(xhr.responseText)
    }
  }
}
const postData = {
  username: 'zhangsan',
  password: 'xxx'
}
xhr.send(JSON.stringify(postData))
```

#### 4.2 状态码

##### 4.2.1 xhr.readyState

* 0 - （为初始化）还没有调用 send() 方法；
* 1 - （载入）已调用 send() 方法，正在发送请求；
* 2 - （载入完成）send() 方法执行完成，已经接受到全部响应内容；
* 3 - （交互）正在解析响应内容；
* 4 - （完成）响应内容解析完成，可以在客户端调用；

##### 4.2.2 xhr.status

* 2xx - 表示成功处理请求，如 200
* 3xx - 需要重定向，浏览器直接跳转，如 301、302、304
* 4xx - 客户端请求错误，如 403、404
* 5xx - 服务器端错误

#### 4.3 跨域：同源策略，跨域解决方案

##### 4.3.1 什么是跨域（同源策略）

* ajax 请求时，浏览器要求当前网页和 server必须同源（安全）；
* 同源：协议、域名、端口，三者必须一致；
* 前端：http://a.com:8080 &nbsp; server：https://b.com/api/xxx

##### 4.3.2 加载图片 css  js 可无视同源策略

* `<img src=跨域的图片地址 />`
* `<link href=跨域的 css 地址 />`
* `<script src=跨域的 JS 地址></script>`

利用上述三种无视同源的策略，我们可以用来做什么：

* `<img />` 可用于统计打点，可使用第三方统计服务；
* `<link />` `<script>` 可使用 CDN，CDN一般都是外域；
* `<script>` 可实现 JSONP ；

> 所有的跨域，都必须经过 server 端允许和配合；未经 server 端允许就实现跨域，说明浏览器有漏洞，危险信号。

##### 4.3.3 JSONP

访问 https://imooc.com ，服务端一定返回一个 html 文件吗？

服务器可以任意动态拼接数据返回，只要符合 html 格式要求；同理于 `<script src="https://imooc.com/getData.js">`

* `<script>` 可绕过跨域限制；
* 服务器可以任意动态拼接数据返回；
* 所以，`<script>`就可以获得跨域的数据，只要服务端愿意返回。

```html
<script>
window.callback = function(data) {
  // 这是我们跨域得到的信息
  console.log(data)
}
</script>
<script src="https://imooc.com/getData.js"></script>
<!-- 将返回 callback({ x: 100, y: 200 }) -->
```

jQuery 实现 jsonp ：

```javascript
$.ajax({
  url: 'http://localhost:8882/x-origin.json',
  dataType: 'jsonp',
  jsonpCallback: 'callback',
  success: function(data) {
  	console.log(data)
  }
})
```

##### 4.3.4 CORS（服务端支持）

CORS - 服务器设置 http header

```javascript
// 第二个参数填写允许跨域的域名称，不建议直接写 “*”
response.setHeader("Access-Control-Allow-Origin", "http://localhost:8011");
response.setHeader("Access-Control-Allow-Headers", "X-Requested-Width");
response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

// 接受跨域的 cookie
response.setHeader("Access-Control-Allow-Credentials", "true")
```

#### 题目：

* 手写一个简易的 ajax 

  ```javascript
  function ajax(url) {
    const p = new Promise((resolve, reject) => {
    	const xhr = new XMLHttpRequest()
      xhr.open('GET', '', true)
      xhr.onreadystatechange = function() {
      	if (xhr.readyState === 4) {
        	if (xhr.status === 200) {
          	resolve(JSON.parse(xhr.responseText))
          } else if (xhr.status === 404) {
          	reject(new Error('404 not found'))
          }
        }
      }
      xhr.send(null)
    })
    return p
  }
  ```

* 跨域的常用实现方式？

  > * JSONP
  >
  > * CORS



### 5. 存储

#### 5.1 cookie

* 本身用于浏览器和 server 通讯
* 被“借用”到本地来存储
* 可用 document.cookie = '...' 来修改

**cookie 的缺点：**

* 存储大小，最大 4KB；
* http 请求时需要发送到服务器，增加请求数量；
* 只能用 document.cookie = ' ... ' 来修改，太过简陋；

#### 5.2 localStorage 和 sessionStorage

* HTML5 专门为存储而设计，最大可存 5M；
* API 简单易用 `setItem`、`getItem`；
* 不会随着 http 请求被发送出去；

**区别：**

* localStorage 数据会永久存储，除非代码或手动删除；
* sessionStorage 数据只存在于当前会话，浏览器关闭则清空；
* 一般用 localStorage 会更多一些；

#### 题目

* 描述 cookie、localStorage、sessionStorage 区别？

  > 容量
  >
  > API 易用性
  >
  > 是否跟随 http 请求发送出去

### 6. http 

前端工程师开发界面，需要调用后端的接口，提交、获取数据 —— http 协议。

#### 6.1 http 状态码

##### 6.1.1 状态码分类

* 1xx 服务器收到请求
* 2xx 请求成功，如 200
* 3xx 重定向，如 302
* 4xx 客服端错误，如 404
* 5xx 服务端错误，如 500

##### 6.1.2 常见状态码

* 200 成功
* 301 永久重定向（配合 location，浏览器自动处理）
* 302 临时重定向（配合 location，浏览器自动处理）
* 304 资源未被修改
* 404 资源未找到
* 403 没有权限
* 500 服务器错误
* 504 网关超时

##### 6.1.3 关于协议和规范

就是一个约定，要求大家都跟着执行，不要违反规范，例如 IE 浏览器。

#### 6.2 http methods

##### 6.2.1 传统的 methods

* get 获取服务器的数据
* post 向服务器提交数据

简单的网页功能，就这两个操作。

##### 6.2.2 现在的 methods

* get 获取数据
* post 新建数据
* patch / put 更新数据
* delete 删除数据

##### 6.2.3 Restful API 

* 一种新的 API 设计方法（早已推广使用）
* 传统 API 设计：把每个 URL 当做一个功能；
* Restful API 设计：把每个 URL 当做一个唯一的资源标识；

如何设计成一个资源？

* 尽量不用 URL 参数；
  * 传统 API 设计：/api/list?pageIndex=2
  * Restful API 设计：/api/list/2
* 用 method 表示操作类型；
  * 传统 API 设计：
    * post 请求：/api/create-blog
    * post 请求：/api/update-blog?id=100
    * get 请求：/api/get-blog?id=100
  * Restful API  设计：
    * post 请求：/api/blog
    * patch 请求：/api/blog/100
    * get 请求：/api/blog/100

#### 6.3 http headers

##### 6.3.1 常见的 Request Headers

* Accept 浏览器可接收的数据格式；
* Accept-Encoding 浏览器可接收的压缩算法，如 gzip；
* Accept-Languange 浏览器可接收的语言，如 zh-CN；
* Connection：keep-alive 一次 TCP 连接重复使用；
* cookie
* Host
* User-Agent（简称 UA）浏览器信息
* Content-type 发送数据的格式，如 application/json

##### 6.3.2 常见的 Response Headers

* Content-type 返回数据的格式，如 application/json
* Content-length 返回数据的大小，多少字节
* Content-Encoding 返回数据的压缩算法，如 gzip
* Set-Cookie

##### 6.3.3 自定义 header

```javascript
/* axios-js.com/docs/#Request-Config */
// 'headers' are custome headers to be sent

headers: { 'X-Requested-Width': 'XMLHttpRequest' }
```

##### 6.3.4 缓存相关的 headers

* Cache-Control  &nbsp;  Expires
* Last-Modified  &nbsp; If-Modified-Since
* Etag  &nbsp;  If-None-match

#### 6.4 http 缓存

##### 6.4.1 关于缓存的介绍

* 什么是缓存？

  > http 缓存指的是：当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有要请求资源的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

* 为什么需要缓存？

  > 通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP 缓存，变得更加响应性。

* 哪些资源可以被缓存？

  > 静态资源（js 、css、img）

##### 6.4.2 http 缓存策略（强制缓存 + 协商缓存）

###### 6.4.2.1 http 缓存 - 强制缓存

![64D0D05F-BF0E-4DB4-A3EE-A79CEAAE0475_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm5h82tfj30tv0kbta7.jpg)

**Cache-Control：**

Response Headers 中，控制强制缓存的逻辑。例如 Cache-Control：max-age=31536000 (单位秒) *最大时间一年*。

**Cache-control 的值：**

* max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒）。
* no-cache：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存验证）。
* no-store：缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。

* private：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。
* public：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。

**关于 Expires**

* 同在 Response Headers 中
* 同为控制缓存过期
* 已被 Cache-Control 代替

###### 6.4.2.2 http 缓存 - 协商缓存

* 服务器端缓存策略；
* 服务器判断客户端资源，是否和服务端资源一样；
* 一致则返回 304，否则返回 200 和最新的资源；

![F28D66EB-89C6-481F-A427-04BFBD2B1C7C_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm62adp1j30ti0kkwg0.jpg)

**资源标识：**

在 Response Headers 中，有两种：

* Last-Modified 资源的最后修改时间；

  ![1339B408-C40B-4BED-AD20-F38BB25087A9_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm69rlnkj30ux0jlabn.jpg)

* Etag 资源的唯一标识（一个字符串，类似人类的指纹）；

  ![79BF65DE-811B-4AFC-97CF-5BEEB94B11A1_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6fama8j30ug0jxjsu.jpg)

**Last-Modified 和 Etag**

* 会优先使用 Etag，
* Last-Modified 只能精确到秒级，
* 如果资源被重复生成，而内容不变，则 Etag 更精确；

![05B19ECF-F0EB-43C4-BC6B-D7A4AAB45F7E_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6kxrx8j313a0fgdhh.jpg)

![4BC90980-9603-452A-A429-5AC711C6ACE6_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6oq92pj30wz0iejsm.jpg)

##### 6.4.3 刷新操作方式，对缓存的影响

三种刷新操作：

* 正常操作：地址栏输入 URL，跳转链接，前进后退等；

  > 正常操作：强制缓存有效，协商缓存有效

* 手动刷新：F5，点击刷新按钮，右击菜单刷新，`ctrl/command + r`；

  > 手动刷新：强制缓存失效，协商缓存有效

* 强制刷新：win: `ctrl + F5`  ， Mac：`shfit + command + r`;

  > 强制刷新：强制缓存失效，手动缓存失效

##### 6.4.4 http 缓存-综述

![24767724-5DDB-43B4-9FD5-B2E658E9D26D_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6shnl1j30se0lct9r.jpg)

#### 题目：

* http 常见的状态码有哪些？
* http 常见的 header 有哪些？
* 什么是 Restful API ？
* 描述一下 http 的缓存机制（重要）？



## 开发环境

### 1. git

* 最常用的代码版本管理工具；
* 大型项目需要多人协作开发，必须使用 git 对代码进行管理；

**常用 git 命令：**

* `git add .`
* `git commit -m "xxx"`
* `git push origin master`
* `git pull origin master`
* `git branch`
* `git checkout -b xxx`
* `git checkout xxx`
* `git merge xxx`
* `git stach`
* `git stach pop`


### 2. chrome 调试工具

* Elements
* Console
* debugger
* Network
* Application

### 3. 抓包

* 移动端 h5 页，查看网络请求，需要用工具抓包
* Windows 一般用 fiddler
* Mac OS 一般用 Charles

抓包过程：

* 手机和电脑连在同一个局域网
* 将手机代理到电脑上
* 手机浏览网页，即可抓包

### 4. webpack  babel

* ES6 模块化，浏览器暂不支持；
* ES6 语法，浏览器并不完全支持；
* 压缩代码，整合代码，以让网页加载更快；

```javascript
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'development', 	// production
  entry: path.join(__dirname, 'src', 'index.js')
  output: {
    filename: 'bundle.js'
    path: path.join(__dirname, 'dist')
  },
  module: {
  	rules: [
      {
      	test: /\.js$/,
        loader: ['babel-loader'],
        include: path.join(__dirname, 'src'),
        exclude: /node_modules/
      }
    ]
  }
  plugins: [
  	new HtmlWebpackPlugin({
      template: path.join(__dirname, 'src', 'index.html'),
      filename: 'index.html'
    })
  ],
  devServer: {
  	port: 3000,
    contentBase: path.join(__dirname, 'dist')
  }
}
```

### 5. Linux 常用命令

* `ls` 查看文件及文件夹
* `ls -a` 查看隐藏的文件及文件夹
* `ll` 列表平铺文件及文件夹
* `clear` 清楚 shell
* `mkdir xxx` 新建文件夹
* `rm -rf xxx` 删除文件
* `cd xxx` 进入某个文件夹
* `mv xxx1 xxx2` 重命名文件
* `mv file ./dir` 移动文件
* `cp file1 file2` 拷贝文件
* `thouch xxx` 新建文件
* `cat xxx` 打印文件头
* `tail xxx`  打印文件头
* `grep 'xxx' file`  查找
* vim 编辑器
  * `vim d.js` 用 vim 打开文件
  * `i`  进入编辑模式
  * `ESC` 退出编辑模式
  * `:q` 保存文件并退出
  * `:q!` 强制退出，不保存文件



## 运行环境

运行环境及浏览器（server 端有 nodejs）。下载网页代码，渲染出页面，期间会执行若干 JS 。要保证代码在浏览器中：稳定且高效。

### 1. 网页加载过程

#### 1.1 加载资源的形式

* html 代码
* 媒体文件，如图片、视频等
* javascript、css

#### 1.2 加载资源的过程

* DNS 解析：域名 -> IP 地址
* 浏览器根据 IP 地址向服务器发起 http 请求
* 服务器处理 http 请求，并返回给浏览器

#### 1.3 渲染页面的过程

* 根据 HTML 代码生成 DOM Tree
* 根据 CSS 代码生成 CSSOM
* 将 DOM Tree 和 CSSOM 整合行程 Render Tree
* 根据 Render Tree 渲染页面
* 遇到 `<script>`则暂停渲染，优先加载并执行 JS 代码，完成再继续
* 直至把 Render Tree 渲染完成

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="test.css">
  </head>
  <body>
    <div>test</div>
  </body>
</html>
```

```css
div {
  width: 100%;
  height: 100%;
  font-size: 50px;
}
```

#### 1.4 window.onload 和 DOMContentLoaded

```javascript
window.addEventListener('load', function() {
	// 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentloaded', function() {
	// DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

#### 题目：

* 从输入 URL 到渲染出页面的整个过程

  > 下载资源：各个资源类型，下载过程
  >
  > 渲染页面：结合 html、css、javascript 图片等

* window.onload 和 DOMContentLoaded 的区别

  > window.onload：资源全部加载完才能执行，包括图片；
  >
  > DOMContentLoaded：DOM 渲染完成即可，图片可能尚未下载

### 2. 性能优化

* 是一个综合性问题，没有标准答案，但要求尽量全面
* 某些细节问题可能会单独提问：手写防抖、节流

#### 2.1 性能优化原则

* 多使用内存、缓存或其他方法

* 减少 CPU 计算量，减少网络加载耗时

> 适用于所有编程的性能优化——空间换时间

#### 2.2 从何入手

##### 2.2.1 让加载更快

* 减少资源体积：压缩代码；
* 减少访问次数：合并代码，SSR 服务器端渲染，缓存；
* 使用更快的网络：CDN

##### 2.2.2 让渲染更快

* CSS 放在 head，JS 放在 body 最下面；
* 尽早开始执行 JS，用 DOMContentLoaded 触发；
* 懒加载（图片懒加载，上滑加载更多）；
* 对 DOM 查询进行缓存；
* 频繁 DOM 操作，合并到一起插入 DOM 结构；
* 节流 throttle，防抖 debounce；

##### 2.2.3 示例

###### 2.2.3.1 资源合并

```html
// 未合并
<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>

// 合并后
<script src="abc.js"></script>
```

###### 2.2.3.2 缓存

![ADB0C755-916F-4BD6-8EE0-07CCB5AD755E_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6ziiz3j30sw0kzta1.jpg)

* 静态资源加 hash 后缀，根据文件内容计算 hash；
* 文件内容不变，则 hash 不变，则 URL 不变；
* URL 和文件不变，则会自动触发 http 缓存机制，返回 304；

###### 2.2.3.3 SSR

* 服务器端渲染：将网页和数据一起加载，一起渲染；
* 非 SSR（前后端分离）：先加载网页，再加载数据，在渲染数据；
* 早先的 JSP、ASP、PHP，现在的 Vue React SSR；

###### 2.2.3.4 懒加载

```html
<img src="img1" src="preview.png" data-realsrc="abc.png"/>
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.src = img1.getAttribute('data-realsrc')
</script>
```

###### 2.2.3.5 缓存 DOM 查询

```javascript
// 不缓存 DOM 查询结果
for (let = 0; i < document.getElementsByTagName('p').length; i++) {
	// 每次循环，都会计算 length，频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName('p')
const length = pList.length
for (let i = 0; i < length; i++) {
	// 缓存 length，只进行一次 DOM 查询
}
```

###### 2.2.3.6 多个 DOM 操作一起插入到 DOM 结构

```javascript
const listNode = document.getElementById('list')

// 创建一个文档片段，此时还没有插入到 DOM 树中
const frag = document.createDocumentFragment()

// 执行插入
for(let x = 0; x < 10; x++) {
  const li = document.createElement('li')
  li.innerHTML = 'List item ' + x
  frag.appendChild(li)
}

// 都完成后，再插入到 DOM 树中
listNode.appendChild(frag)
```

###### 2.2.3.7 尽早开始 JS 执行

```javascript
window.addEventListener('load', function() {
	// 页面的全部资源加载完才会执行，包括图片、视频等
})

document.addEventListener('DOMContentLoaded', function() {
	// DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

#### 2.3 防抖 debounce

* 监听一个输入框的文字变化后触发 change 事件；
* 直接用 keyup 事件，则会频繁触发 change 事件；
* 防抖：用户输入结束或停止时，才会触发 change 事件；

```javascript
// 防抖
function debounce(fn, delay = 500) {
  // timer 是闭包中的
  let timer = null
  return function() {
  	if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}
```

#### 2.4 节流 throttle

* 拖拽一个元素时，要随时拿到该元素被拖拽的位置；
* 直接用 drag 事件，则会频繁触发，很容易导致卡顿；
* 节流：无论推拽速度多快，都会每隔 100ms 触发一次；

```javascript
// 节流
function throttle(fn, delay = 100) {
  let timer = null
  return function() {
  	if (timer) return
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}
```

### 3. Web 安全

#### 3.1 XSS 跨站请求攻击

一个博客网站，我发表一篇博客，其中嵌入`<script>`脚本；脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）；发布这篇博客，有人查看它，我就能轻松收割访问者的 cookie。

**XSS 预防：**

* 替换特殊字符，如 `<`变成`&lt;`，`>`变成`&gt;`
* `<script>`变成 `&lt;script&gt;`，直接显示，而不会作为脚本执行；
* 前端要替换，后端也要替换。

#### 3.2 XSRF 跨站请求伪造

你正在购物，看中了某个商品，商品 id 是 100，付费接口是 `xxx.com/pay?id=100`，但没有任何验证；我向你发送一封电子邮件，邮件标题很吸引人；但邮件正文隐藏着 `<img src='xxx.com/pay?id=200'/>`，你一查看邮件，就帮我买了 id 是 200 的商品。

**XSRF 预防：**

* 使用 post 接口；
* 增加验证，例如密码、短信验证码、指纹等；

## 真题

### 1. var 和 let、const 的区别

* var 是 ES5 语法，let、const 是 ES6 语法；var 有变量提升
* var 和 let 是变量，可修改；const 是常量，不可修改
* let、const 有块级作用域，var 没有

### 2. typeof 能判断哪些类型

* undefined、string、number、boolean、symbol
* object（注意，typeof null === ‘object’）
* function

### 3. 列举强制类型转换和隐式类型转换

* 强制：parseInt、parseFloat、toString 等
* 隐式：if、逻辑运算、==、+ 拼接字符串

### 4. 手写深度比较 lodash.isEqual

```javascript
// 实现如下效果
const obj1 = {a: 10, b: {x: 100, y: 200}}
const obj2 = {a: 10, b: {x: 100, y: 200}}
isEqual(obj1, obj2) === true

// 判断是否是 object 类型
function isObject(obj) {
  return typeof obj === 'object' && obj !== null
}

// 手写深度比较
function isEqual(obj1, obj2) {
  if (!isObject(obj1) || !isObject(obj2)) return obj1 === obj2
  // 两个都是对象或数组，且都不相等
  const obj1Keys = Object.keys(obj1)
  const obj2Keys = Object.keys(obj2)
  if (obj1Keys.length !== obj2Keys.length) return false
  for (let key in obj1) {
  	const res = isEqual(obj1[key], obj2[key])
    if (!res) return false
  }
  return true
}
```

### 5. split() 和 join() 的区别

```javascript
'1-2-3'.split('-')		// [1, 2, 3]
[1, 2, 3].join('-')		// '1-2-3'
```

### 6. 数组的 pop、push、unshift、shift 分别是什么？

> 思考：
>
> * 功能是什么？
> * 返回值是什么？
> * 是否会对原数组造成影响？

```javascript
const arr = [10, 20, 30, 40]

// pop
const popRes = arr.pop()	// 删除数组的最后一项的值，并返回删除该项的值
// push
const pushRes = arr.push(50)	// 从数组的最后追加一项值，并返回变化后数组的 length
// unshift
const unshiftRes = arr.unshift(5)		// 从数组的最前端插入一项值，并返回变化后数组的 length
// shift
const shift = arr.shift()		// 删除数组的第一项的值，并返回删除该项的值


//【扩展】数组的 API，有哪些是纯函数？
// 纯函数：1.不改变原数组（没有副作用）；2.返回一个数组；

// concat
const arr1 = arr.concat([50, 60, 70])
// map
const arr2 = arr.map(num => num * 10)
// filter
const arr3 = arr.filter(num => num > 25)
// slice
const arr4 = arr.slice()

// 非存函数：
// push、pop、shift、unshift、forEach、some、every、reduce

```

### 7. 数组 slice 和 splice 的区别？

> 思考：
>
> * 功能区别（slice - 切片，splice - 剪接）
>
> * 参数和返回值
> * 是否是纯函数？

```javascript
// slice 纯函数
const arr = [10, 20, 30, 40, 50]

// slice 纯函数
const arr1 = arr.slice()
const arr2 = arr.slice(1, 4)
const arr3 = arr.slice(2)
const arr4 = arr.slice(-3)

// splice 非纯函数
const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
const spliceRes1 = arr.splice(1, 2)
const spliceRes2 = arr.splice(1, 0, 'a', 'b', 'c')
```

### 8. [10,  20,  30].map(parseInt) 返回结果是什么？

> 思考：
>
> * map 的参数和返回值
> * parseInt 参数和返回值

```javascript
// 拆解
[10, 20, 30].map((num, index) => {
	return parseInt(num, index)
})
// 10, NaN, NaN
```

### 9. Ajax 请求 get 和 post 的区别？

* get 一般用于查询操作，post 一般用于提交数据；
* get 参数拼接在 URL 上，post 放在请求体内（数据体积更大）；
* 安全性：post 易于防止 CSRF

### 10. 函数 call 和 apply 的区别？

```javascript
fn.call(this, p1, p2, p3)
fn.apply(this, arguments)
```

### 11. 事件代理（委托）是什么？

```javascript
const p1 = document.getElementById('p1')
const body = document.body
bindEvent(p1, 'click', e => {
	// e.stopPropagation()	// 阻止捕获和冒泡阶段中当前事件的进一步传播
  alert('激活')
})
bindEvent(body, 'click', e => {
	alert('取消')
})
```

### 12. 闭包是什么，有什么特性？有什么负面影响？

> 思考：
>
> * 回顾作用域和闭包
> * 回顾闭包应用场景：作为参数被传入，作为返回值被返回
> * 回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）

影响： 变量会常驻内存，得不到释放。闭包不要乱用。

```javascript
// 闭包 函数作为返回值 —— 内存不会被释放
function create() {
  let a = 100
  return function() {
  	console.log(a)
  }
}
let fn = create()
let a = 200
fn()	// 100

// 闭包 函数作为参数被传入
function print(fn) {
  let a = 200
  fn()
}
let a = 100
function fn() {
  console.log(a)
}
print(fn)	// 100
```

### 13. 如何阻止事件冒泡和默认行为？

* event.stopPropagation()	// 阻止事件冒泡
* Event.preventDefault()       // 阻止默认行为

### 14. 查找、添加、删除、移动 DOM 节点的方法？

```javascript
document.getElementById()
document.getElementsByClassName()
document.getElementsBuTagName()
document.querySelectorAll()
```

### 15. 如何减少 DOM 操作？

* 缓存 DOM 查询结果；
* 多次 DOM 操作，合并到一次插入；

```javascript
const list = document.getElementById('list')
// 创建一个文档片段，此时还没有插入到 DOM 结构中
const frag = document.createDocumentFragment()
for (let i = 0; i < 20; i++) {
  const li = document.createElement('li')
  li.innerHTML = `List item ${i}`
  // 先插入到文档片段中
  frag.appendChild(li)
}
// 都完成之后，再统一插入到 DOM 结构中
list.appendChild(frag)
```

### 16. 解释 jsonp 的原理，为何它不是真正的 ajax ？

* 浏览器的同源策略（服务端没有同源策略）和跨域

* 哪些 html 标签能绕过跨域？

  > link、img、script

* jsonp 的原理

  ![A7F1B3CE-E035-4772-94D3-3D98C2F781B7_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmwb0pe21rj310a0gqjte.jpg)

### 17. document load 和 ready 的区别？

```javascript
window.addEventListener('load', function() {
	// 页面的全部资源加载完才会执行，包括图片、视频等
})

window.addEventListener('DOMContentLoaded', function() {
	// DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

### 18. == 和 === 的不同？

* == 会尝试类型转换
* === 严格相等
* 只有一个场景下使用 == ：判断是否是 undefined 或 null 时，等价于 == null

### 19. 函数声明和函数表达式的区别？

* 函数声明：`function fn() {...}`
* 函数表达式：`const fn = function() {...}`
* 函数声明会在代码执行前预加载，而函数表达式不会。

### 20. New Object() 和 Object.create() 的区别？

* `{}`等同于`new Object()`，原型 `Object.prototype`；
* `Object.create(null)`没有原型；
* `Object.create({...})`可指定原型；

### 21. 关于 this 的场景题

```javascript
const User = {
  count: 1,
  getCount: function() {
  	return this.count
  }
}
console.log(User.getCount)	// 1
const func = User.getCount
console.log(func())	// undefined
```

### 22. 关于作用域和自由变量的场景题

```javascript
let i
for(i = 1; i <= 3; i++) {
  setTimeout(function() {
  	console.log(i)
  }, 0)
}
// 4
```

```javascript
let a = 100
function test() {
  alert(a)	// 100
  a = 10
  alert(a)	//10
}
test()
alert(a)	// 10
```

### 23. 判断字符串以字母开头，后面字母数字下划线，长度 6-30

```javascript
const reg = /^[a-zA-Z]\w[5,29]$/
```

### 24. 手写字符串 trim  方法，保证浏览器兼容性？

```javascript
String.prototype.trim = function() {
  return this.replace(/^\s+/, '').replace(/\s+$/, '')
}
```

### 25. 如何获取多个数字中的最大值？

```javascript
function max() {
  const nums = Array.prototype.slice.call(arguments)	// 变为数组
  let max = 0
  nums.forEach(n => {
  	if (n > max) max = n
  })
  return max
}

// Math 方法
Math.max(10, 30, 20, 40)
```

### 26. 如何用 JS 实现继承？

> class 继承
>
> prototype 继承

### 27. 如何捕获 JS 程序中的异常？

```javascript
// 手动捕获异常
try {
  // todo
} catch (ex) {
  console.log(ex)	// 手动捕获
} finally {
  // todo
}
```

```javascript
// 自动捕获
window.onerror = function(message, source, lineNum, colNum, error) {
  // 第一，对跨域的 js，如 CDN 的，不会有详细的报错信息
  // 第二，对于压缩的 js，还要配合 sourceMap 反查到未压缩的行、列
}
```

### 28. 什么是 JSON ？

* json 是一种数据格式，本质是一段字符串。
* json 格式和 JS 对象结构一致，对 JS 语言更友好。
* `window.JSON`是一个全局对象：`JSON.stringifg`、`JSON.parse`。

```json
// json
{
  "name": "张三",
  "info": {
  	"single": true,
    "age": 30,
    "city": "北京"
  },
  "like": ["篮球", "音乐"]
}
```

### 29. 获取当前页面 URL 参数？

```javascript
// 传统方法
function query(name) {
  const search = location.search.substr(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res === null) return null
  return res[2]
}
```

```javascript
// URLSearchParams
function query(name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```

### 30. 将 URL 参数解释为 JS 对象

```javascript
// 传统方式，分析 search
function queryToObj() {
  const res = {}
  const search = location.search.substr(1)	// 去掉前面的 ‘?’
  search.split('&').forEach(paramStr => {
  	const arr = paramStr.split('=')
    const key = arr[0]
    const value = arr[1]
    res[key] = val
  })
  return res
}
```

```javascript
// 使用 URLSearchParams
function queryToObj() {
  const res = {}
  const pList = new URLSearchParams(location.search)
  pList.forEach((val, key) => {
  	res[key] = val
  })
  return res
}
```

### 31. 手写 flatern 考虑多层级

```javascript
function flat(arr) {
  const isDeep = arr.some(item => item instanceof Array)
  if (!isDeep) return arr
  const res = Array.prototype.concat.apply([], arr)
  return flat(res)
}
```

### 32. 数组去重

> 思考：
>
> * 传统方式，遍历元素挨个比较、去重
> * 使用 set
> * 考虑计算效率

```javascript
// 传统方式
function unique(arr) {
  const res = []
  arr.forEach(item => {
  	if (res.indexOf(item) < 0) res.push(item)
  })
}
```

```javascript
// 使用 Set（无序，不能重复）
function unqiue(arr) {
  const set = new Set(arr)
  return [...set]
}
```

### 33. 手写深拷贝

```javascript
function deepClone(obj = {}) {
  if (typeof obj !== 'object' || obj == null) return obj
  let result
  if (obj instanceof Array) result []
  else result {}
  for (let key in obj) {
  	if (obj.hasOwnProperty(key)) result[key] === deepClone(obj[key])
  }
  return result
}
```

### 34. 介绍一下 RAF（requestAnimationFrame）

* 要想动画流畅，更新频率要 60 帧/s，即 16.67 ms 更新一次视图；
* setTimeout 要手动控制频率，而 RAF 浏览器会自动控制；
* 后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行；

### 35. 前端性能如何优化？一般从哪几个方面考虑？

* 原则：多使用内存、缓存，减少计算、减少网络请求
* 方向：加载页面，页面渲染，页面操作流畅度