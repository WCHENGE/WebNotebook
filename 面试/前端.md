## HTML

### 1. 如何理解 HTML 语义化？

* 让人更容易读懂（增加代码可读性）；

* 让搜索引擎更容易读懂（SEO）；

  > 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小。

> 用正确的标签做正确的事情！

### 2. 块级元素 & 内联元素 ？

* display：block / table；

  > 有 div、h1、h2、table、ul、ol、p 等。

* display：inline / inline-block；

  >有 span、img、input、button 等。

* 行内元素有：a、b、span、img、input、select、strong
* 块级元素有：div、ul、ol、li、dl、dt、dd、h1、h2...、p
* 空元素：`<br>`、`<hr>`、`<img>`、`<input>`、`<link>`、`<meta>`
* 行内元素不可以设置宽高，不独占一行；
* 块级元素可以设置宽高，独占一行；

### 3. `img`的`title`和`alt`有什么区别

* `title`通常当鼠标滑动到元素上的时候显示。
* `alt`是`img`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提升图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。

### 4. HTML 全局属性（global attribute）有哪些

* `class`：为元素设置类标识；
* `data-*`：为元素增加自定义属性；
* `draggable`：设置元素是否可拖拽；
* `id`：元素`id`，文档内唯一；
* `lang`：元素内容的语言；
* `style`：行内`css`样式；
* `title`：元素相关的建议信息；

### 5. Canvas 和 SVG 有什么区别？

* `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，能够方便的绑定事件或用来修改。`canvas`输出的是一整幅画布。
* `svg`输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而`canvas`输出画布，就像一张图片一样，放大会失真或者锯齿。

### 6. HTML5 为什么只需要写`<!DOCTYPE html>`

* `HTML5`不基于`SGML`,因此不需要对`DTD`进行引用，但是需要`doctype`来规范浏览器的行为。
* 而`HTML4.01`基于`SGML`，所以需要对`DTD`进行引用，才能告诉浏览器文档所使用的文档类型。

### 7. viewport

```javascript
<meta name="viewport" content="width=device-width,initial-scale=1.0,minmum-scale=1.0,maximum-scale=1.0,user-scalable=no">
  // width	设置 viewport 宽度，为一个正数，或字符串‘device-width’(设备宽度)
  // height	设置 viewport 高度，一般设置了宽度，会自动解析出高度，可以不用设置
  // initial-scale	默认缩放比例（初始缩放比例），为一个数字，可以带小数
  // minimum-scale	允许用户最小缩放比例，为一个数字，可以带小数
  // maximum-scale	允许用户最大缩放比例，为一个数字，可以带小树
  // user-scalable	是否允许手动缩放
```

### 8. 怎样处理移动端`1px`被渲染成`2px`问题

**局部处理**

* `meta`标签中的`viewport`属性，`initial-scale`设置为`1`；
* `rem`按照设计稿标准走，外加利用`transfrome`的`scale(0.5)`缩小一倍即可；

**全局处理**

* `meta`标签中的`viewport`属性，`initial-scale`设置为`0.5`；
* `rem`按照设计稿标准走即可

### 9. meta viewport 相关

```html
<!DOCTYPE html>  <!--H5标准声明，使用 HTML5 doctype，不区分大小写-->
<head lang=”en”> <!--标准的 lang 属性写法-->
<meta charset=’utf-8′>    <!--声明文档使用的字符编码-->
<meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/>   <!--优先使用 IE 最新版本和 Chrome-->
<meta name=”description” content=”不超过150个字符”/>       <!--页面描述-->
<meta name=”keywords” content=””/>     <!-- 页面关键词-->
<meta name=”author” content=”name, email@gmail.com”/>    <!--网页作者-->
<meta name=”robots” content=”index,follow”/>      <!--搜索引擎抓取-->
<meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> <!--为移动设备添加 viewport-->
<meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin-->
<meta name=”apple-mobile-web-app-capable” content=”yes”/>  <!--添加到主屏后的标题（iOS 6 新增）
是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏-->
<meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”>
<!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）-->
<meta name=”apple-mobile-web-app-status-bar-style” content=”black”/>
<meta name=”format-detection” content=”telphone=no, email=no”/>  <!--设置苹果工具栏颜色-->
<meta name=”renderer” content=”webkit”> <!-- 启用360浏览器的极速模式(webkit)-->
<meta http-equiv=”X-UA-Compatible” content=”IE=edge”>     <!--避免IE使用兼容模式-->
<meta http-equiv=”Cache-Control” content=”no-siteapp” />    <!--不让百度转码-->
<meta name=”HandheldFriendly” content=”true”>     <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓-->
<meta name=”MobileOptimized” content=”320″>   <!--微软的老式浏览器-->
<meta name=”screen-orientation” content=”portrait”>   <!--uc强制竖屏-->
<meta name=”x5-orientation” content=”portrait”>    <!--QQ强制竖屏-->
<meta name=”full-screen” content=”yes”>              <!--UC强制全屏-->
<meta name=”x5-fullscreen” content=”true”>       <!--QQ强制全屏-->
<meta name=”browsermode” content=”application”>   <!--UC应用模式-->
<meta name=”x5-page-mode” content=”app”>   <!-- QQ应用模式-->
<meta name=”msapplication-tap-highlight” content=”no”>    <!--windows phone 点击无高亮
设置页面不缓存-->
<meta http-equiv=”pragma” content=”no-cache”>
<meta http-equiv=”cache-control” content=”no-cache”>
<meta http-equiv=”expires” content=”0″>
```

### 10. strong 与 em 的异同？

* `strong`：粗体强调标签，强调，表示内容的重要性；
* `em`：斜体强调标签，更强烈强调，表示内容的强调点；

### 11. 描述一下渐进增强和优雅降级之间的不同

* 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
* 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

> 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。

### 12. 为什么利用多个域名来存储网站资源会更有效？

* `CDN`缓存更方便；
* 突破浏览器并发限制；
* 节约`cookie`带宽；
* 节约主域名的连接数，优化页面响应速度；
* 防止不必要的安全问题；

### 13. 简述一下`src`和`href`的区别

* `src`用于替换当前元素，`href`用于在当前文档和引用资源之间确立联系。

* `src`是`source`的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求`src`资源时会将其指向的资源下载并应用到文档内，例如`JS`脚本，`img`图片和`frame`等元素。

  > `<script src="js.js"></script>`当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

* `href`是`Hypertext Reference`的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接。

  > 在文档中添加`<link href="common.css" rel="stylesheet" >`那么浏览器会识别该文档为`css`文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用`link`方式来加载`css`，而不是使用`@import`方式。

### 14. 制作网页会用到的图片格式有哪些？

* `png-8`、`png-24`、`jpeg`、`gif`、`svg`、`webp`、`apng`
* **Webp**：`Webp`格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有`JPEG`的`2/3`，并能节省大量的服务器带宽资源和数据空间。`Facebook Ebay`等知名网站已经开始测试并使用`WebP`格式。在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小`40%`。
* **Apng**：全称是`“Animated Portable Network Graphics”`, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 `iOS safari 8`的支持，有望代替`GIF`成为下一代动态图标准。

### 15. 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。

* 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。
* 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。
* 如果图片为css图片，可以使用`CSSsprite`，`SVGsprite`，`Iconfont`、`Base64`等技术。
* 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。
* 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。

### 16. title与h1的区别、b与strong的区别、i与em的区别

* `title`属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；
* `strong`是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：`<strong>`会重读，而`<b>`是展示强调内容；
* `i`内容展示为斜体，`em`表示强调的文本；

### 17. 谈谈 Cookie 的弊端

* 每个特定的域名下最多生成`20`个`cookie`
* `IE6`或更低版本最多`20`个`cookie`
* `IE7`和之后的版本最后可以有`50`个`cookie`
* `Firefox`最多50个`cookie`
* `chrome`和`Safari`没有做硬性限制
* IE 和 Opera 会清理近期最少使用的 `cookie`，`Firefox` 会随机清理 `cookie`
* `cookie` 的最大大约为 `4096` 字节，为了兼容性，一般设置不超过 `4095` 字节
* 如果 `cookie` 被人拦截了，就可以取得所有的 `session` 信息



## CSS 布局

### 1. 盒模型宽度的计算

```html
<!-- 如下代码，请问 div1 的 offsetWidth 是多大？-->
<style>
  #div1 {
    width: 100px;
    padding: 10px;
    border: 1px solid #ccc;
    margin: 10px;
  }
</style>

<div id="div1"></div>
```

> 定义：offsetWidth = (内容宽度 + 内边距 + 边框)，无外边距。
>
> 因此，答案是 122px；
>
> 补充：如果让 offsetWidth 等于 100px，该如何做？
>
> `box-sizing: border-box`

### 2. Margin 纵向重叠问题？

```html
<!-- 如下代码，AAA 和 BBB 之间的距离是多少？-->
<style>
  p {
    font-size: 16px;
    line-height: 1;
    margin-top: 10px;
    margin-bottom: 15px;
  }
</style>

<p>AAA</p>
<p></p>
<p></p>
<p></p>
<p>BBB</p>
```

>相邻元素的 margin-top 和 margin-bottom 会发生重叠
>
>空白内容的 `<p></p>`也会重叠
>
>答案：15px

### 3. Margin 负值问题

* margin-top 和 margin-left 负值，元素向上、向左移动；
* margin-right 负值，右侧元素左移，自身不受影响；
* margin-bottom 负值，下方元素上移，自身不受影响；

### 4. BFC 理解与应用

#### 4.1 什么是 BFC？如何应用？

* Block format context，块级格式化上下文；
* 一块独立渲染区域，内部元素的渲染不会影响边界以外的元素；

#### 4.2 形成 BFC 的常见条件？

* float 不是 none；
* position 是 absolute 或 fixed；
* overflow 不是 visible；
* display 是 flex 或 inline-block 等。

> 在`IE`下, `Layout`,可通过`zoom:1` 触发

#### 4.3 BFC 的常见应用

* 清除浮动；

### 5. float 布局

#### 5.1 圣杯布局和双飞翼布局的目的

* 三栏布局，中间一栏最先加载和渲染（内容最重要）；
* 两侧内容固定，中间内容随宽度自适应；
* 一般用于 PC 网页。

```html
<!-- 圣杯布局 -->
<div id="container">
  <div id="center" class="column">this is center</div>
  <div id="left" class="column">this is left</div>
  <div id="right" class="column">this is right</div>
</div>
<style type="text/css">
  .column {
    float: left;
  }
  #container {
    padding-left: 200px;
    padding-right: 150px;
  }
  #center {
    width: 100%;
  }
  #left {
    display: relative;
    width: 200px;
    margin-left: -100%;
    right: 200px;
  }
  #right {
    width: 150px;
    margin-right: -150px;
  }
</style>
```

```html
<!-- 双飞翼布局 -->
<div id="main" class="col">this is center</div>
<div id="left" class="col">this is left</div>
<div id="right" class="col">this is right</div>
<style type="text/css">
  #main {
    width: 100%;
    margin: 0 190px 0;
  }
  #left, #right {
    width: 190px;
  }
  #left {
    margin-left: -100%;
  }
  #right {
    margin-left: -190px;
  }
</style>
```

#### 5.2 圣杯布局和双飞翼布局的技术总结

* 使用 float 布局
* 两侧使用 margin 负值，以便和中间内容横向重叠；
* 防止中间内容被两侧覆盖，一个用 padding ，一个用 margin ；

#### 5.3 手写清除浮动

```css
/* 手写 clear fix */
.clearfix:after {
  content: '';
  display: table;
  clear: both;
}
.clearfix {
  *zomm: 1; /* 兼容 IE 低版本 */
}
```

### 6. flex 布局

#### 6.1 常用语法回顾

* flex-direction：决定主轴的方向（row | row-reverse | column | column-reverse）

* flex-warp：是否换行（nowrap | wrap | wrap-reverse）

* flex-flow：`<flex-direction>`和`<flex-wrap>`的简写形式，默认值为row nowrap。

* justify-content：项目在主轴上的对齐方式（flex-start | flex-end | center | space-between | space-around）

* align-items：项目在交叉轴上的对齐方式（stretch | flex-start | flex-end | center | baseline）

* align-content：项目在交叉轴上定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

* order：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。

* flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

* flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

* flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。

* flex：属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后面哥属性可选。

  > 该属性有两个快捷值：auto（1 1 auto）和 none（0 0 auto）。
  >
  > 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

* align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为  auto，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。

#### 6.2 flex 画三个点的色子

```css
/* flex 画三个点的色子 */
.box {
  display: flex;	/* flex 布局 */
  justify-content: space-between;	/* 两端对齐 */
}
.item {
  /* 背景色、大小、边框等 */
}
.item:nth-child(2) {
  align-self: center;	/* 第二项居中对齐 */
}
.item:nth-child(3) {
  align-self: flex-end;	/* 第三项尾对齐 */
}
```

### 7. CSS - 定位

#### 7.1 absolute 和 relative 分别依据什么定位？

* relative 依据自身定位；

* absolute 依据最近一层的定位元素定位；

  > 定位元素：
  >
  > * absolute
  > * relative
  > * fixed
  > * body

#### 7.2 居中对齐有哪些实现方式？

##### 7.2.1 水平居中

* inline 元素：text-align：center
* block 元素：margin：auto
* absolute 元素：left：50% + margin-left 负值

##### 7.2.2 垂直居中

* inline 元素：line-height 的值等于 height 值
* absolute 元素：top：50% + margin-top 负值
* absolute 元素：transform（-50%，-50%）
* absolute 元素：top，left，bottom，right = 0 `+` margin：auto

### 8. CSS - 图文样式

#### 8.1 line-height 如何继承

```html
<!-- 如下代码，p 标签的行高将会是多少？答案：40px -->
<style>
  body {
    font-size: 20px;
    line-height: 200%;
  }
  p {
    font-size: 16px;
  }
</style>
<body>
  <p>AAAA</p>
</body>
```

* 写具体数值，如 30px，则继承该值（比较好理解）
* 写比例，如 2 / 1.5 ，则继承该比例（比较好理解）
* 写百分比，如 200%，则继承**计算出来的值**（考点）

### 9. CSS - 响应式

#### 9.1 rem 是什么？

> rem 是一个长度单位：
>
> * px ，绝对长度单位，最常用；
> * em ，相对长度单位，相对于父元素，不常用；
> * rem，相对长度单位，相对于根元素，常用于响应式布局；

#### 9.2 响应式布局的常用方案

* media-query，根据不同的屏幕宽度设置根元素 font-size；
* rem，基于根元素的相对单位；

#### 9.3 CSS - 响应式 - vw / vh

rem 的弊端：“阶梯”性

```css
@media only screen and (max-width: 374px) {
  html { font-size: 86px; }
}
@media only screen and (min-width: 375px) and (max-width: 423px) {
  html { font-size: 100px; }
}
@media only screen and (min-width: 414px) {
  html { font-size: 110px; }
}
```

网页视口尺寸：

* window.screen.height	// 屏幕高度
* window.innerHeight	// 网页视口高度
* document.body.clientHeight	// body 高度

vw / vh

* vh 网页视口高度的 1 / 100
* vw 网页视口高度的 1 / 100
* vmax 取两者最大值；
* vmin 取两者最小值；

### 真题

#### 1. CSS sprite 优缺点？

* 概念：将多个小图片拼接到一个图片中。通过`background-position`和元素尺寸调节需要显示的背景图案。
* 优点：
  * 减少`HTTP`请求数，极大地提高页面加载速度
  * 增加图片信息重复度，提高压缩比，减少图片大小
  * 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现
* 缺点：
  * 图片合并麻烦
  * 维护麻烦，修改一个图片可能需要从新布局整个图片，样式

#### 2. `display: none;`与`visibility: hidden;`的区别

* 共同点：它们都能让元素不可见
* 区别：
  * `display:none`;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；`visibility: hidden`;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见
  * `display: none`;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示`；visibility: hidden;`是继承属性，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible;`可以让子孙节点显式
  * 修改常规流中元素的`display`通常会造成文档重排。修改`visibility`属性只会造成本元素的重绘。
  * 读屏器不会读取`display: none`;元素内容；会读取`visibility: hidden;`元素内容

#### 3. `link`与`@import`的区别

1. `link`是`HTML`方式， `@import`是CSS方式
2. `link`最大限度支持并行下载，`@import`过多嵌套导致串行下载，出现`FOUC`(文档样式短暂失效)
3. `link`可以通过`rel="alternate stylesheet"`指定候选样式
4. 浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式
5. `@import`必须在样式规则之前，可以在css文件中引用其他文件
6. 总体来说：`link`优于`@import`

#### 4. 什么是FOUC?如何避免

* `Flash Of Unstyled Content`：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。
* **解决方法**：把样式表放到文档的`<head>`

#### 5. 清除浮动的几种方式，各自的优缺点

* 父级`div`定义`height`

* 结尾处加空`div`标签`clear:both`

* 父级`div`定义伪类`:after`和`zoom`

* 父级`div`定义`overflow:hidden`

* 父级`div`也浮动，需要定义宽度

* 结尾处加`br`标签`clear:both`

> 比较好的是第3种方式，好多网站都这么用

#### 6. CSS3 有哪些新特性

* 新增选择器 `p:nth-child(n){color: rgba(255, 0, 0, 0.75)}`
* 弹性盒模型 `display: flex;`
* 多列布局 `column-count: 5;`
* 媒体查询 `@media (max-width: 480px) {.box: {column-count: 1;}}`
* 个性化字体 `@font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}`
* 颜色透明度 `color: rgba(255, 0, 0, 0.75);`
* 圆角 `border-radius: 5px;`
* 渐变 `background:linear-gradient(red, green, blue);`
* 阴影 `box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);`
* 倒影 `box-reflect: below 2px;`
* 文字装饰 `text-stroke-color: red;`
* 文字溢出 `text-overflow:ellipsis;`
* 背景效果 `background-size: 100px 100px;`
* 边框效果 `border-image:url(bt_blue.png) 0 10;`
* 转换
  * 旋转 `transform: rotate(20deg);`
  * 倾斜 `transform: skew(150deg, -10deg);`
  * 位移 `transform: translate(20px, 20px);`
  * 缩放 `transform: scale(.5);`
* 平滑过渡 `transition: all .3s ease-in .1s;`
* 动画 `@keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;`

**CSS3新增伪类有那些？**

* `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
* `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
* `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
* `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
* `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
* `:after` 在元素之前添加内容,也可以用来做清除浮动。
* `:before` 在元素之后添加内容。
* `:enabled` 已启用的表单元素。
* `:disabled` 已禁用的表单元素。
* `:checked` 单选框或复选框被选中。

#### 7. display 有哪些值？各自的作用

* `none` 设置元素不可见。

* `block` 转换成块状元素。
* `inline` 转换成行内元素。
* `inline-block` 像行内元素一样显示，但其内容像块类型元素一样显示。
* `list-item` 象块类型元素一样显示，并添加样式列表标记。
* `table` 此元素会作为块级表格来显示
* `inherit` 规定应该从父元素继承 `display` 属性的值

#### 8. 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？

有两种， `IE`盒子模型、`W3C`盒子模型；

* 盒模型： 内容(`content`)、填充(`padding`)、边界(`margin`)、 边框(`border`)；

* 区 别： `IE`的`content`部分把 `border` 和 `padding`计算了进去;

> * `IE8`及其以下版本浏览器，未声明 `DOCTYPE`，内容宽高会包含内填充和边框，称为怪异盒模型(`IE`盒模型)
> * 标准(`W3C`)盒模型：元素宽度 = `width + padding + border + margin`
> * 怪异(`IE`)盒模型：元素宽度 = `width + margin`
> * 标准浏览器通过设置 css3 的 `box-sizing: border-box` 属性，触发“怪异模式”解析计算宽高

**box-sizing 常用的属性有哪些？分别有什么作用**

* `box-sizing: content-box;` 默认的标准(W3C)盒模型元素效果
* `box-sizing: border-box;` 触发怪异(IE)盒模型元素的效果
* `box-sizing: inherit;` 继承父元素 `box-sizing` 属性的值

#### 9. CSS不同选择器的权重(CSS层叠的规则)

* `!important`规则最重要，大于其它规则
* 行内样式规则，加`1000`
* 对于选择器中给定的各个`ID`属性值，加`100`
* 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加`10`
* 对于选择其中给定的各个元素标签选择器，加1
* 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则

```css
/* 例子是演示各种定义的权重值：*/
/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
}
```

#### 11. `display: inline-block`什么时候不会显示间隙？

* 移除空格
* 使用`margin`负值
* 使用`font-size: 0`
* `letter-spacing`：属性用于设置文本字符的间距表现
* `word-spacing`：用于声明标签和单词直接的间距行为

#### 12. 行内元素float:left后是否变为块级元素？

> 行内元素设置成浮动之后变得更加像是`inline-block`（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是`100%`），这时候给行内元素设置`padding-top`和`padding-bottom`或者`width`、`height`都是有效果的。

#### 13. ::before 和 :after中双冒号和单冒号 有什么区别?

* 单冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素
* 用于区分伪类和伪元素

#### 14. 伪类和伪元素的区别

* 伪类表状态
* 伪元素是真的有元素
* 前者单冒号，后者双冒号

#### 15. CSS3 动画

`CSS3`中提出的三个属性：`transition`、`transform`、`animation`

* `transition`：定义了元素在变化过程中是怎么样的，包含`transition-property`、`transition-duration`、`transition-timing-function`、`transition-delay`。
* `transform`：定义元素的变化结果，包含`rotate`、`scale`、`skew`、`translate`。
* `animation`：动画定义了动作的每一帧（`@keyframes`）有什么效果，包括`animation-name`，`animation-duration`、`animation-timing-function`、`animation-delay`、`animation-iteration-count`、`animation-direction`

#### 16. `rgba()`和`opacity`的透明效果有什么不同？

* `rgba()`和`opacity`都能实现透明效果。
* `opacity`作用于元素以及元素内所有内容的透明度；
* `rgba()`只作用域元素的颜色或其背景色。（设置`rgba`透明的元素的子元素不会继承透明效果）

#### 17. 如何使用 CSS 实现硬件加速？

> 硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能。

一般触发硬件加速的 `CSS` 属性有 `transform`、`opacity`、`filter`，为了避免 2D 动画在开始和结束的时候的 `repaint` 操作，一般使用 `tranform:translateZ(0)`。

#### 18. 重绘和回流（重排）是什么？

* 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘。
* 回流：当渲染树中的元素布局（如：尺寸、位置、隐藏、状态）发生改变时，产生重绘回流。

> 注意：JS 获取 Layout 属性值（如：`offsetLeft`、`scrollTop`、`getComputedStyle`等）也会引起回流，因为浏览器需要通过回流计算最新值。
>
> 回流必将引起重绘，而重绘不一定会引起回流。

#### 19. 如何最小化重绘（repaint）和回流（reflow）？

* 需要对元素进行复杂的操作时，可以先隐藏（`display: none`），操作完成后再显示；

* 需要创建多个`DOM`节点时，使用`DocumentFragment`创建完成后一次性的加入`document`；

* 缓存`layout`属性值

  > 如`var left = elem.offsetLeft;`多次使用`left`只产生一次回流。

* 尽量避免用`table`布局

  > `table`元素一旦触发回流就会导致 table 里所有的其它元素回流

* 避免使用`css`表达式（`expression`），因为每次调用都会重新计算值（包括加载页面）；

* 尽量使用`CSS` 属性简写，如用`border`代替`border-width`、`borer-style`、`border-color`；

* 批量修改元素样式：`elem.className`和`elem.style.cssText`代替`elem.style.xxx`；

#### 20. CSS3 的 animation

CSS3 的`animation`是 CSS3 新增的动画属性，这个 CSS3 动画的每一帧是通过`@keyframes`来声明的，`keyframes`声明了动画的名称，通过`from`、`to`或者是百分比来定义。

动画子属性：

* `animation-name`：定义动画名；
* `animation-duration`：定义动画播放的时长；
* `animation-delay`：定义动画延迟播放的时间；
* `animation-direction`：定义动画的播放方向；
* `animation-iteration-count`：定义播放次数；
* `animation-fill-mode`：定义动画播放之后的状态；
* `animation-play-state`：定义播放状态，如战提高运行等；
* `animation-timing-function`：定义播放的方式，如恒速播放、艰涩播放等。

#### 21. CSS 有哪些继承属性

* `font`文字排版属性
  * `word-break`：指定了怎样在单词内断行
  * `letter-spacing`
  * `text-align`
  * `text-rendering`
  * `word-spacing`
  * `white-space`
  * `text-indent`
  * `text-transform`
  * `text-shadow`
* `line-height`
* `color`
* `visibility`
* `cursor`

#### 22. CSS 选择器有哪些？

* ID 选择器：`# myid`
* 类选择器：`.myclassname`
* 标签选择器：`div`、`h1`、`p`
* 相邻选择器：`h1 + p`
* 子选择器：`ul > li`
* 后代选择器：`li a`
* 通配符选择器：`*`
* 属性选择器：`a[rel = "external"]`
* 伪类选择器：`a:hover`、`li:nth-child`

#### 23. CSS3 新增伪类有哪些？

* `:root`：选择文档的根元素，等同于 html 元素；
* `:empty`：选择没有子元素的元素；
* `:target`：选择当前活动的目标元素；
* `:not(selector)`：选择除`selector`元素以外的元素；
* `:enabled`：选择可用的表单元素；
* `:disabled`：选择禁用的表单元素；
* `:checked`：选择被选中的表单元素；
* `::after`：在元素内部最前添加内容；
* `::before`：在元素内部最后添加内容；
* `:nth-child(n)`：匹配父元素下指定子元素，在所有子元素中排序第 n；
* `:nth-last-child(n)`：匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数；
* `:nth-child(odd)`
* `:nth-child(even)`
* `:nth-child(3n+1)`
* `:first-child`
* `:last-child`
* `:only-child`：匹配没有兄弟元素的元素。
* `:nth-of-type(n)`：匹配某种类型的一列兄弟元素（比如，`<p>`元素）
* `:nth-last-of-type(n)`
* `:nth-of-type(odd)`
* `:nth-of-type(even)`
* `:nth-of-type(3n+1)`
* `:first-of-type`
* `:last-of-type`
* `:only-of-type`：匹配兄弟元素中某类型仅有的元素。
* `::selection`：匹配被用户选取的元素部分。
* `::first-line`：选择元素中的第一行。
* `::first-letter`：选择元素中的第一个字符。

#### 24. 伪元素有哪些？

* `::after`：匹配出现在原有元素的实际内容之后的一个可样式化元素。
* `::before`：匹配出现在原油元素的实际内容之前的一个可样式化元素。
* `::first-letter`：匹配元素的第一个字母。
* `::first-line`：匹配包含此伪元素的元素的第一行。
* `::grammar-error`：匹配文档中包含了浏览器标记的语法错误的那部分。
* `::selection`：匹配文档中被选择的那部分。
* `::spelling-error`：匹配文档中包含了浏览器标记的拼写错误的那部分。

#### 25. CSS 优化、提高性能的方法有哪些？

* 多个 CSS 合并，尽量减少`HTTP`请求；
* 将 CSS 文件放在 head 标签内；
* 移除空的 CSS 规则；
* 避免使用 CSS 表达式；
* CSS 雪碧图；
* 选择器优化嵌套，尽量避免层级过深；
* 充分利用 CSS 继承属性，减少代码量；
* 抽提公共样式，减少代码量；
* 属性值为 `0` 时，不加单位；
* 属性值为小于`1`的小数时，省略小数点前面的 `0`；

#### 26. `margin`和`padding`分别适合什么场景使用？

* 需要在`border`外侧添加空白，且空白处不需要背景（色）时，使用`margin`；
* 需要在`border`内侧添加空白，且空白处需要背景（色）时，使用`padding`；

#### 27. 元素竖向的百分比设定是相对于容器的高度吗

> 元素竖向的百分比设定是相对于容器的宽度，而不是高度。

#### 28. `a`标签上四个伪类的执行顺序是怎么样的

> `link` > `visited` > `hover` > `active`

`L-V-H-A`	`love hate` 用喜欢和讨厌两个词来方便记忆。

#### 29. `::before`和`:after`中双冒号和单冒号有什么区别？

* 在 CSS 中伪类一直用 `:` 表示，如`:hover`，`:active`等；
* 伪元素在 CSS1 中已存在，当时语法是用 `:` 表示，如`:before`和`:after`；
* 在 CSS3 中修订，伪元素用 `::` 表示，如`::before`和`::after`，以此区分伪元素和伪类；

> 综上所述，`::before`是`CSS3`中写伪元素的新语法；`:after`是`CSS1`中存在的老语法；开发者为了兼容各个浏览器，继续使用`:after`这种老语法表示伪元素。

#### 30. iOS safari 如何阻止“橡皮筋效果”

```javascript
$(document).ready(function() {
	var stopScrolling = function(event) {
  	event.preventDefault()
  }
  
  document.addEventListener('touchstart', stopScrolling, false)
  document.addEventListener('touchmove', stopScrolling, false)
})
```

#### 31. `line-height`三种赋值方式有何区别？（带单位、纯数字、百分比）

* 带单位：`px`是固定值，而`em`会参考父元素`font-size`值计算自身的行高。
* 纯数字：会把比例传递给后代。例如，父级行高为`1.5`，子元素字体为`18px`，则子元素行高为`1.5 * 18 = 27px`。
* 百分比：将计算后的值传递给后代。

## javascript 基础知识

### 1. 变量类型和计算

值类型：`undefined`、`null`、`boolean`、`number`、`string`、`symbol`

引用类型：`object`、`array`、`function`

```javascript
// 常见值类型
let a						// undefined
const s = 'abc'					// String
const n = 100					// Number
const b = true					// Boolean
const s = Symbol('s')				// Symbol
```

```javascript
// 常见引用类型
const obj = { x: 100 }
const arr = ['a', 'b', 'c']

const n = null		// 特殊引用类型，指针指向为空地址

function fn() {}	// 特殊引用类型，但不用于存储数据，所以没有“拷贝、复制函数”这一说
```

#### 1.1 typeof 能判断哪些类型？

* 识别所有值类型；
* 识别函数；
* 判断是否是引用类型（不可再细分）

```javascript
// 判断所有值类型
let a;						typeof a	// 'undefined'
const str = 'abc'				typeof str	// 'string'
const n = 100					typeof n	// 'number'
const b = true					typeof b	// 'boolean'
const s = Symbol('s')				typeof s	// 'symbol'

// 能判断函数
typeof console.log 		// 'function'
typeof function () {}		// 'function'

// 能识别引用类型（不能在继续识别）
typeof null			// 'object'
typeof ['a', 'b']		// 'object'
typeof { x: 100 }		// 'object'
```

小结：

* `typeof`对于基本类型，除了`null`都可以显示正确的类型；
* `typeof`对于对象，除了**函数**都会显示`object`；
* 如果我们想获得一个变量的正确类型，可以通过 `Object.prototype.toString.call(xx)`。这样我们就可以获得类似 `[object Type]` 的字符串。

#### 1.2 何时使用 === 何时使用 == 

除了 `== null` 之外，其它都一律用 `===`。

```javascript
const obj = { x: 100 }
if (obj.a == null) { }
// 相当于：
// if (obj.a === null || obj.a === undefined) { }
```

#### 1.3 值类型和引用类型的区别？

值类型变量的值是存储在栈中，而引用类型变量存储在栈中的是指向堆中的数组或者对象的**地址**，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。

1. 值类型：
   * 占用空间固定，保存在栈中（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，基础变量的值是存储在栈中，而引用变量存储在栈中的是指向堆中的数组或者对象的地址，这就是为何修改引用类型总会影响到其他指向这个地址的引用变量。）
   * 保存于复制的是值本身；
   * 使用 typeof 检测数据的类型；
   * 基本类型数据是值类型；
2. 引用类型：
   * 占用空间不固定，保存在堆中（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。）
   * 保存于复制的是指向对象的一个指针；
   * 使用 instanceof 检测数据类型；
   * 使用 new() 方法构造出的对象是引用型；

```javascript
// 例题：
const obj1 = { x: 100, y: 200 }
const obj2 = obj1
let x1 = obj1.x
obj2.x = 101
x1 = 102
console.log(obj1)	// { x: 101, y: 200 }
```

#### 1.4 手写深拷贝

对于一些简单数据，可以通过`JSON.parse(JSON.stringify(object))`来解决。

```javascript
let a = {
    age: 1,
    jobs: {
        first: 'FE'
    }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

该方法也是有**局限性**的：

* 会忽略`undefined`
* 会忽略`symbol`
* 不能序列化函数
* 不能解决循环引用的对象

但是该函数是内置函数中处理深拷贝性能最快的。

如果数据中含有以上四种情况，可以尝试用一下深拷贝方法：

```javascript
function deepClone (obj) {
  // obj 是 null，或者不是对象和数组，直接返回
  if (typeof obj !== 'object' || obj == null) return obj
  // 初始化返回结果
  let result
  (obj instanceof Array) ? result = [] : result = {}
  for (let key in obj) {
    // 保证 key 不是原型的属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key])
    }
  }
  return result
}
```

#### 1.5 变量计算 - 类型转换

##### 1.5.1 类型转换

###### 转 Boolean

在条件判断时，除了`undeined`、`null`、`false`、`NaN`、`''`、`0`、`-0`，其它所有值都转为`true`，包括所有对象。

###### 对象转基本类型

对象在转换基本类型时，首先会调用`valueOf`，然后调用`toString`。并且这两个方法你是可以重写的。

```javascript
let a = {
  valueOf() {
    return 0
  }
}
```

###### 四则运算符

* 只有当**加法运算**时，其中一方是**字符串类型**，就会把另一个也转为**字符串类型**。

* **其它运算**只要其中一方是**数字类型**，那么另一方就转为数字类型。
* 并且加法运算会触发三种类型转换：将值转换为**原始值**，转换为**数字类型**，转换为**字符串类型**。

```javascript
1 + '1' // '11'
2 * '2' // 4
[1, 2] + [2, 1] // '1,22,1'
// [1, 2].toString() -> '1,2'
// [2, 1].toString() -> '2,1'
// '1,2' + '2,1' = '1,22,1'
```

```javascript
// 对于加号需要注意这个表达式 'a' + + 'b'

'a' + + 'b' // -> "aNaN"
// 因为 + 'b' -> NaN
// 你也许在一些代码中看到过 + '1' -> 1
```

##### 1.5.2 字符串拼接

```javascript
const a = 100 + 10	// 110
const b = 100 + '10'	// '10010'
const c = true + '10'	// 'true10'
```

##### 1.5.3 == 运算符

```javascript
100 == '100'			// true
0 == ''				// true
0 == false			// true
false == ''			// true
null == undefined		// true
```

除了 `== null` 之外，其它都一律用 `===` ，例如

```javascript
const obj = { x: 100 }
if (obj.a == null) {}
// 相当于：if (obj.a === null || obj.a === undefined) {}
```

##### 1.5.4 if 语句和逻辑运算

* truly 变量：!!a === true 的变量
* falsely 变量：!!a === false 的变量

```javascript
// 以下是 falsely 变量。除此之外都是 truly 变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!!undefined === false
!!false === false
```

#### 1.6 判断对象类型

* 可以通过`Object.prototype.toString.call(xxx)`，这样就可以获得类似`[object Type]`的字符串。
* `instanceof`可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的`prototype`。

### 2. 原型和原形链

#### 2.1 class 和继承

##### 2.1.1 class

* constructor
* 属性
* 方法

```javascript
class People {
  constructor(name) {
    this.name = name
  }
  eat() {
    console.log(`${this.name} eat something`)
  }
}
```

##### 2.1.2 继承

在 `ES5` 中，我们可以使用如下方式解决继承的问题。

```javascript
function Sub() {}
Sub.prototype.getNumber = function() {
  return 1
}

let s = new Sub()
Sub.prototype = Object.create(Sub.prototype, {
  constructor: {
    value: Sub,
    enumerable: false,
    writable: true,
    configurable: true
  }
})
```

在 `ES6` 中，我们可以通过 `class` 语法轻松解决这个问题

* extends
* super
* 扩展或重写方法

```javascript
class Student extends People {
  constructor(name, number) {
    super(name)
    this.number = number
  }
  sayHi() {
    console.log(`姓名 ${this.name} 学号 ${this.number}`)
  }
}
```

#### 2.2 类型判断 - instanceof

```javascript
[] instanceof Array		// true
[] instanceof Object		// true

{} instanceof Object		// true
```

> `instanceof`可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的`prototype`。

```javascript
// 实现一个 instanceof 方法
function instanceof(obj, type) {
	// 获得类型的显示原型
  const prototype = type.prototype
  // 获取对象的隐式原型
  let proto = obj.__proto__
  // 判断对象的类型是否等于类型的原型
  while(true) {
    if (proto == null) return false
    if (prototype === proto) return true
    proto = proto.__proto__
  }
}
```



#### 2.3 原型和原型链

![prototype](https://tva1.sinaimg.cn/large/008eGmZEgy1gn251ajuifj30kc09awex.jpg)

##### 2.3.1 原型关系：

* 每个 `class` 都有显示原型 `prototype`
* 每个实例都有隐式原型 `__proto__`
* 实例的`__proto__`指向对应`class`的`prototype`

```javascript
// class 实际上是函数，可见是语法糖
typeof People		// 'function'
typeof Student		// 'function'

// 隐式原型和显示原型
console.log(xialuo.__proto__)
console.log(Student.prototype)
console.log(xialuo.__proto__ === Student.prototype)
```

##### 2.3.2 基于原型的执行规则

* 获取属性 `xialuo.name`或执行方法`xiauo.sayhi()`时；
* 先在自身属性和方法寻找；
* 如果找不到则去 `__proto__`中寻找；

### 3. 作用域和闭包

#### 3.1 作用域和自由变量

##### 3.1.1 作用域

* 全局作用域
* 函数作用域
* 块级作用域（ES6 新增）

##### 3.1.2 自由变量

* 一个变量在当前作用域没有定义，但被使用了；
* 向上级作用域，一层一层依次寻找，直至找到为止；
* 如果到全局作用域都没找到，则报错 `xx is not defined`；

```javascript
let a = 0
function fn1() {
  let a1 = 100
  
  function fn2() {
    let a2 = 200
    
    function fn3() {
      let a3 = 300
      return a + a1 + a2 + a3
    }
    fn3()
  }
  fn2
}
fn1()
```

##### 3.1.3 变量提升和函数提升

当执行 JS 代码时，会生成**执行环境**，只要代码不是写在函数中的，就是在**全局执行环境中**的；函数中的代码会产生**函数执行环境**，只此两种执行环境。

```javascript
b()	// call b
console.log(a)	// undefined

var a = 'Hello World!'

function b() {
	console.log('call b')
}
```

> 函数和变量提升的原因：
>
> * 通常的解释是说：将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。
>
> * 更准确的解释应该是：在生成执行环境时，会有两个阶段。
>
>   第一个阶段，代码的创建阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为`undefined`。
>
>   第二个阶段，代码的执行阶段，我们可以直接提前使用。

在提升的过程中，**相同的函数会覆盖上一个函数**，并且**函数优先于变量提升**。

```javascript
b()	// call b second

function b() {
  console.log('call b first')
}

function b() {
  console.log('call b second')
}

var b = 'Hello World'
```

> `var`会产生很多错误，所以在 ES6 中引入`let`。`let`不能在声明前使用，但是这并不是常说的`let`不会提升，`let`提升了，在第一阶段内存中也已经为它开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用。

##### 3.1.4 立即执行函数（IIFE）

**IIFE**（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。

```javascript
(function() {
  statements
})
```

这是一个被称为 [自执行匿名函数](https://developer.mozilla.org/en-US/docs/Glossary/Self-Executing_Anonymous_Function) 的设计模式，主要包含两部分。

* 第一部分是包围在 [`圆括号运算符`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Grouping) `()` 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。

* 第二部分再一次使用 `()` 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。

```javascript
/* 当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。*/ 
(function () {
    var name = "Barry";
})();
// 无法从外部访问变量 name
name // 抛出错误："Uncaught ReferenceError: name is not defined"
```

```javascript
/* 将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。*/
var result = (function () {
    var name = "Barry";
    return name;
})();
// IIFE 执行后返回的结果：
result; // "Barry"
```


##### 3.1.5 非匿名立即执行函数

```javascript
var foo = 1
(function foo() {
  foo = 10
  console.log(foo)
}())
// > f foo() { foo = 10; console.log(foo) }
```

> 当`JS`解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到`foo`，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。

#### 3.2 闭包

闭包就是能够读取到其它函数内部变量的函数。

作用域应用的特殊情况，有两种表现：

* 函数作为参数被传递；
* 函数作为返回值被返回；

```javascript
// 函数作为参数
function print(fn) {
  let a = 200
  fn()
}
let a = 100
function fn() {
  console.log(a)
}
print(fn)	// 100
```

```javascript
// 函数作为返回值
function create() {
  let a = 100
  return function () {
    console.log(a)
  }
}

let fn = create()
let a = 200
fn()	// 100
```

**所有的自由变量的查找，是在函数定义的地方，向上级作用域查找，不是在执行的地方。**

* **闭包的好处**：
  * 可以读取函数内部的变量；
  * 让这些变量始终保持在内存中；
* **闭包的坏处**：消耗内存、不正当使用会造成内存溢出的问题

#### 3.3 this

* 作为普通函数  （this 的指向 window）
* 使用 call、apply、bind  （this 指向传入的参数）
* 作为对象方法被调用  （this 指向对象本身）
* 在 class 方法中调用  （this 指向当前实例化本身）
* 箭头函数 （取它上级作用域的 this）

`this` 取什么样的值，是在函数执行的时候确定的，不是在函数定义的时候确定的。

```javascript
// 1. 作为普通函数调用
function fn1() {
  console.log(this)
}
fn1()	// window

// 2. 使用 call、apply、bind 调用
fn1.call({ x: 100 })	// { x: 100 }

const fn2 = fn1.bind({ x: 200 })
fn2()	// { x: 200 }
```

```javascript
// 3. 作为对象方法被调用
const zhangsan = {
  name: '张三',
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  wait() {
    setTimeout(function() {
      // this === window
      console.log(this)
    })
  }
}
```

```javascript
// 4. 箭头函数
const zhangsan = {
  name: '张三',
  sayHi() {
    // this 即当前对象
    console.log(this)
  },
  waitAgain() {
    setTimeout(() => {
      // this 即当前对象
      console.log(this)
    })
  }
}
```

```javascript
// 在 class 方法中调用
class People {
  constructor(name) {
    this.name = name
    this.age = 20
  }
  sayHi() {
    console.log(this)
  }
}
const zhangsan = new People('张三')
zhangsan.sayHi()	// zhangsan 对象
```

#### 题目

* this 的不同应用场景，如何取值？

  > * 当做普通函数被调用    （this 指向 window）
  > * 使用 call、apply、bind    （this 指向取决于传入的参数）
  > * 作为对象方法调用    （this 指向是对象的本身）
  > * 在 class 的方法中调用    （this 指向是当前实例的本身）
  > * 箭头函数    （this 指向是箭头函数的上级作用域）

* call、apply、bind有什么不同？

  `call`和`apply`都是为了解决改变`this`的指向。作用都是相同的，只是传参的方式不同。除了一个参数外，`call`可以接收一个参数列表，`apply`只接受一个参数数组。

  `bind`和其它两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过`bind`实现柯里化（currying）。

  > * call 接收多个参数，第一个为函数上下文也就是 this，随后的参数为函数本身的参数。
  > * apply 接收两个参数，第一个参数为函数上下文 this，第二个参数为函数参数，只不过是通过一个数组的形式传入的。
  > * bind 接收多个参数，第一个是 bind 返回值，返回值是一个函数上下文 this，不会立即执行。

* 手写`call`函数

  ```javascript
  Function.prototype.maCall = function(context) {
    // 如果没有传值或传的值为空对象 context 指向 window
    context = context || window
    const fn = Symbol(context)
    context.fn = this	// 给 context 添加一个方法，指向 this
    // 将 arguments 类数组变成数组，并截取除第一参数以外的所有参数
    const args = [...arguments].slice(1)
    const result = context.fn(...args)	// 执行 fn
    delete context.fn
    return result
  }
  ```

* 手写`apply`函数

  ```javascript
  Function.prototype.myApply = function(context) {
    context = context || window
   	const fn = Symbol(context)
   	context.fn = this
   	const args = argument[1]
   	const result = args ? context.fn(...args) : context.fn()
   	delete context.fn
   	return result
  }
  ```

* 手写`bind`函数

  ```javascript
  Function.prototype.myBind = function(context) {
    if (typeof this !== 'function') throw new TypeError('Error')
    context = context || window
    // 将参数解析为数组
    // const args = Array.prototype.slice.call(arguments)
    const args = [...arguments].slice(1)
    // 获取 this（取出数组第一项，数组剩余的就是传递的参数）
    const self = this	// 当前函数
    // 返回一个函数
    return function() {
      // 执行原函数，并返回结果
      return self.apply(context, args.concat(...arguments))
    }
  }
  ```

* 实际开发中**闭包**的应用

  * 隐藏数据

    ```javascript
    // 闭包隐藏数据，只提供 API
    function createCache() {
      const data = {}
      return {
        get: function (key) {
          return data[key]
        },
        set: function (key, value) {
          data[key] = value
        }
      }
    }
    ```
  
* 简单说一下原型链？

  > * 每个函数都有`prototype`属性，除了`Function.prototype.bind()`，该属性指向原型。
  >
  > * 每个对象都有`__proto__`属性，指向了创建该对象的构造函数的原型。
  >
  >   > 其实这个属性指向了`[[prototype]]`，但是`[[prototype]]`是内部属性，我们并不能访问到，所以使用`__proto__`来访问。
  >
  > * 对象可以通过`__proto__`来寻找不属于该对象的属性，`__proto__`将对象连接起来组成了原型链。
  
* `new`运算符

  >`new`关键字会进行如下操作：
  >
  >1. 创建一个空的 JavaScript 对象（即`{}`）；
  >2. 链接该对象（设置该对象的`constructor`）到另一个对象；
  >3. 将步骤1 新创建的对象作为`this`的上下文；
  >4. 如果该函数没有返回对象，则返回`this`。
  >
  >简单的说就是这么三步：
  >
  >1. 新建一个内部对象；
  >2. 给这个对象指定一个原型链，对象的`__proto__`指向构造函数的`prototype`；
  >3. 并将这个对象作为`this`的上下文；
  >4. 最后返回这个内部对象。

  ```javascript
  function newFun(cont, ...args) {
  	// 新建一个对象
    let obj = {}
    
    // 给这个对象指定原型链，
    // 不要用 obj.__proto__ = cont.prototype
    // __proto__ 这种写法并不是很好
    Object.setPrototypeOf(obj, cont.prototype)
    // 或者用 obj = Object.create(cont.prototype)  
    
    let result = cont.apply(obj, args)	// 这一步挺神奇的，说一下自己的理解
    
    return result instanceof Object ? result : obj
  }
  ```

### 4. 异步和单线程

#### 4.1 单线程和异步

* JS 是单线程语言，只能同时做一件事；
* 浏览器和 nodejs 已支持 JS 启动**进程**，如 Web Worker；
* JS 和 DOM 渲染共用同一个**线程**，因为 JS 可修改 DOM 结构；
* 遇到等待（网络请求，定时任务）页面不能卡住，所以需要异步；异步是以回调 callback 函数形式调用；

```javascript
// 同步
console.log(100)
alert(200)
console.log(300)
```

```javascript
// 异步 (callback 回调函数)
console.log(100)
setTimeout(function() {
  console.log(200)
}, 1000)
console.log(300)
```

#### 4.2 异步和同步

* 基于 JS 是单线程语言
* 异步不会阻塞代码执行
* 同步会阻塞代码执行

#### 4.3 应用场景

* 网络请求，如 ajax 图片加载
* 定时任务，如 setTimeout

```javascript
// ajax
console.log('start')
$.get('./data1.json', function(data1) {
  console.log(data1)
})
console.log('end')
```

```javascript
// 图片加载
console.log('start')
let img = document.createElement('img')
img.onload = function() {
  console.log('loaded')
}
img.src = '/xxx.png'
console.log('end')
```

```javascript
// setTimeout
console.log(100)
setTimeout(function() {
  console.log(200)
}, 1000)
console.log(300)
```

```javascript
// setInterval
console.log(100)
setInterval(function() {
  console.log(200)
}, 1000)
console.log(300)
```

#### 4.4 callback hell 和 Promise

##### 4.4.1 callback hell

```javascript
// 获取第一份数据
$.get(url1, (data1) => {
  console.log(data1)
  
  // 获取第二份数据
  $.get(url2, (data2) => {
    console.log(data2)
    
    // 获取第三份数据
    $.get(url3, (data3) => {
      console.log(data3)
      
      // 还可能获取更多的数据
    })
  })
})
```

##### 4.4.2 promise

```javascript
function getData(url) {
  return new Promise((resolve, reject) => {
    $.ajax({
      url,
      success(data) {
        resolve(data)
      },
      error(err) {
        reject(err)
      }
    })
  })
}
```

#### 题目

* 同步和异步的区别是什么？

  >* 基于 JS 是单线程语言
  >* 异步不会阻塞代码执行
  >* 同步会阻塞代码执行

* 手写用 Promise 加载一张图片？

  ```javascript
  function loadImg(src) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img')
     	img.onload = () => { resolve(img) }
     	img.onerror = () => {
        const err = new Error(`图片加载失败 ${src}`)
       	reject(err)
      }
     	img.src = src
    })
  }
  ```

* 前端使用异步的场景有哪些？

  > 网络请求，如 ajax 图片加载
  >
  > 定时任务，如 setTimeout
  
  ```javascript
  // setTimeout 笔试题
  console.log(1)
  setTimeout(function() {
  	console.log(2)
  }, 1000)
  console.log(3)
  setTimeout(function() {
  	console.log(4)
  }, 0)
  console.log(5)
  
  // 1、3、5、4、2
  ```

### 5. JS 异步 - 进阶

#### 5.1 event loop（事件循环/事件轮询）

* JS 是单线程运行的
* 异步要基于回调来实现
* event loop 就是异步回调的实现原理

#### 5.2 JS 如何执行？

* 从前到后，一行一行执行
* 先把同步代码执行完，再执行异步代码
* 如果某一行执行报错，则停止下面代码的执行

#### 5.3 event loop 过程

![E4397F7E-41F6-4DA6-83E4-552EDF61FC7A_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm3w23pjj30wq0ij0tp.jpg)

1. 同步代码，一行一行放在 Call Stack 执行；
2. 遇到异步代码（定时、网络请求），会先“记录”下，等待时机；
3. 时机到了，就移动到 Callback Queue；
4. 如 Call Stack 为空（即同步代码执行完）Event Loop 开始工作；
5. 轮询查找 Callback Queue，如果不为空，则移动到 Call Stack 执行；
6. 然后继续轮询查找（永动机一样）；

#### 5.4 DOM 事件和 event loop

* JS 是单线程的
* 异步（setTimeout，ajax等）使用回调，基于 event loop；
* DOM 事件也使用回调，基于 event loop

#### 5.5 Promise

* 三种状态
  * pending resolved rejected
  * pending -> resolved  或  pending -> rejected
  * 变化不可逆
* 状态的表现和变化
  * pending 状态，不会触发 then 和 catch 方法；
  * resolved 状态，会触发后续的 then 回调函数；
  * reject 状态，会触发后续的 catch 回调函数；
* then 和 catch 对状态的影响
  * then 正常返回 resolved，里面有报错则返回 rejected；
  * catch 正常返回 resolved，里面有报错则返回 rejected；

#### 5.6 async / await

* 异步回调 callback hell；
* Promise then catch 链式调用，但也是基于回调函数；
* async / await 是同步语法，彻底消灭回调函数；

#### 5.7 async / await 和 Promise 的关系

async / await 是消灭异步回调的终极武器，但和 Promise 并不互斥，反而两者相辅相成。

* 执行 async 函数，返回的是 Promise 对象；
* await 相当于 Promise 的 then；
* try...catch 可捕获异常，代替了 Promise 的 catch；

#### 5.8 异步的本质

* async / await 是消灭异步回调的终极武器；
* JS 还是单线程，还得是有异步，还得是基于 event loop；
* async / await 只是一个语法糖，但这颗糖真香！

```javascript
async function async1 () {
  console.log('async1 start')	// 2
  await async2()
  /* 
    await 的后面，都可以看做是 callback 里的内容，即异步
    类似，event loop ，setTimeout(cb1)
    // setTimeout(function() { console.log('async1 end') })
    // Promise.resolve().then(()=>{console.log('async1 end')})
  */
  console.log('async1 end')	// 5
}

async function async2() {
  console.log('async2')	// 3
}

console.log('script start')	// 1
async1()
console.log('script end')	// 4
// 同步代码已经执行完（event loop）
```

```javascript
async function async1() {
  console.log('async1 start')	// 2
  await async2()
  // 下面三行都是异步回调 callback 的内容
  console.log('async1 end')	// 5
  await async3()
  // 下面一行是异步回调的内容
  console.log('async1 end 2')	// 7
}

async function async2() {
  console.log('async2')	// 3
}

async function async3() {
  console.log('async3')	// 6
}

console.log('script start')	// 1
async1()
console.log('script end')	// 4
// 同步代码执行完 event loop
```

#### 5.9 generator 原理

`Generator`是 `ES6`中新增的语法，和`Promise`一样，都可以用来异步编程。

```javascript
/**
* 使用 * 表示这是一个 Generator 函数
* 内部可以通过 yield 暂停代码
* 通过调用 next 恢复执行
*/
function* test() {
  let a = 1 + 2
  yield 2
  yield 3
}
let b = test()
console.log(b.next())	// > {value: 2, done: false}
console.log(b.next())	// > {value: 3, done: false}
console.log(b.next())	// > {value: undefined, done: true}
```

> 从以上代码可以发现，加上`*`的函数执行后拥有了`next`函数，也就是函数执行后返回了一个对象。每次调用`next`函数可以继续执行被暂停的代码。

#### 5.10 for ... of

* for ... in （以及 forEach 、for）是常规的同步遍历
* for ... of 常用于异步的遍历

```javascript
function muti(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num * num)
    }, 1000)
  })
}

const nums = [1, 2, 3]
nums.forEach(async(i) => {
  const res = await muti(i)
  console.log(res)	// 1，4，9 同时打印
})
```

```javascript
function muti(num) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(num * num)
    }, 1000)
  })
}

!(async function() {
  for (let i of nums) {
    const res = await muti(i)
    console.log(res)	// 1，4，9 依次打印
  }
})()
```

#### 5.11 微任务（microTask）和宏任务（macroTask）

```javascript
console.log(100)	// 1
// 宏任务
setTimeout(() => {
  console.log(200)	// 4
})
// 微任务
Promise.resolve().then(() => {
  console.log(300)	// 3
})
console.log(400)	// 2
```

* **微任务：** Promise、async / await；

* **宏任务：** script、setTimeout、setInterval、Ajax、DOM 、事件；

* *微任务执行时机比宏任务更早*。

  > 很多人有个误区，认为微任务块于宏任务，其实是错误的。因为宏任务中包括了`script`，浏览器会先执行一个宏任务，接下来有一步代码的话就先执行微任务。

#### 5.12 event loop 和 DOM 渲染

event loop 的过程：

* JS 是单线程的，而且和 DOM 渲染共用一个线程；
* JS 执行的时候，得留一些时机供 DOM 渲染；

每次 Call Stack 清空（即每次轮询结束），即同步任务执行完；都是 DOM 重新渲染的机会，DOM 结构如有改变则重新渲染，然后再去触发下一次 Event Loop。

**微任务和宏任务的区别：**

* **微任务**：DOM 渲染**前**触发，如 Promise

* **宏任务**：DOM 渲染**后**触发，如 setTimeout

```javascript
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container').append($p1).append($p2).append($p3)

// 微任务：DOM 渲染前触发
Promise.resolve().then(() => {
  console.log('length1', $('#container').children().length )	// 3
  alert('Promise then')	// DOM 渲染了吗？ —— NO
})

// 宏任务：DOM 渲染后触发
setTimeout(() => {
  console.log('length2', $('#container').children().length )	// 3
  alert('setTimeout')	// DOM 渲染了吗？ —— YES
})
```

从 event loop 解释，为何微任务执行更早：

* 微任务是 ES6 语法规定的；

* 宏任务是由浏览器规定的；


![81981A1D-302F-4155-B965-12516819731F_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm4p3slyj30w00iy0tv.jpg)

![1469979C-DB70-4391-9851-B6B661C210A2_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm4x2krej30w80it75c.jpg)

所以一次完整的 Event loop 顺序是这样的：

* 执行同步代码（这属于宏任务）；
* 执行栈为空，查询是否有微任务需要执行；
* 执行所有微任务；
* 必要的话渲染`UI`；
* 然后开始下一轮`Event Loop`，执行宏任务中异步代码。

> 通过上述的 `Event loop`顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作`DOM`的话，为了更快的界面响应，我们可以把操作`DOM`放入微任务中。

#### 题目：

* 请描述 event loop（事件循环/事件轮询）的机制，可画图

* 什么是宏任务和微任务，两者有什么区别？

  > 宏任务：setTimeout，setInterval，Ajax，DOM 事件；
  >
  > 微任务：Promise，async / await；
  >
  > 微任务执行时机比宏任务要早。

* Promise 有哪三种状态？如何变化？

  > * pending	resolved	rejected
  > * pending -> resolved  或 pending -> rejected
  > * 变化不可逆

* 场景题 - promise then 和 catch 的连接

  ```javascript
  // 第一题
  Promise.resolve().then(() => {
    console.log(1)	// 1
  }).catch(() => {
    console.log(2)
  }).then(() => {
    console.log(3)	// 3
  })
  // 1，3
  ```

  ```javascript
  // 第二题
  Promise.resolve().then(() => {
    console.log(1)	// 1
    throw new Error('error1')
  }).catch(() => {
    console.log(2)	// 2
  }).then(() => {
    console.log(3)	// 3
  })
  // 1，2，3
  ```

  ```javascript
  // 第三题
  Promise.resolve().then(() => {
    console.log(1)	// 1
    throw new Error('error1')
  }).catch(() => {
    console.log(2)	// 2
  }).catch(() => {
    console.log(3)
  })
  // 1，2
  ```

* 场景题 - async / await 语法

  ```javascript
  async function fn() {
    return 100
  }
  
  (async function() {
    const a = fn()	// Promise
    const b = await fn()	// 100
  })()
  ```

  ```javascript
  (async function() {
    console.log('start')	// start
    const a = await 100
    console.log('a', a)	// 100
    const b = await Promise.resolve(200)
    console.log('b', b)	// 200
    const c = await Promise.reject(300)
    console.log('c', c)
    console.log('end')
  })()
  // 执行完毕，打印出哪些内容？
  // start，100，200
  ```

* 场景题 promise 和 setTimeout 的顺序

  ```javascript
  console.log(100)
  setTimeout(() => {
    console.log(200)
  })
  Promise.resolve().then(() => {
    console.log(300)
  })
  console.log(400)
  // 100，400，300，200
  ```

* 场景题 - 外加 async / await 的顺序问题

  ```javascript
  async function async1() {
    console.log('async1 start')	// 2
    await async2()	// 微任务
    console.log('async1 end')	// 6
  }
  
  async function async2() {
    console.log('async2')	// 3
  }

  console.log('script start')	// 1
  
  setTimeout(function() {	// 宏任务
    console.log('setTimeout')	// 8
  }, 0)
  
  async1()
  
  // 初始化 promise 时，传入的函数会立刻执行
  new Promise(function(resolve) {
    console.log('promise1')	// 4
    resolve()
  }).then(function() {	// 微任务
    console.log('promise2')	// 7
  })
  
  console.log('script end')	// 5
  
  /* 
    同步代码执行完毕（event loop - call stack 被清空）
    执行完毕
    （尝试触发 DOM 渲染）
    触发 event loop，执行宏任务
  */
  ```


#### 总结：

event loop 过程：

* 同步代码，一行一行放在 Call Stack 执行；
* 遇到异步代码（定时、网络请求等），会先“记录”下，等待时机；
* 时机到了，就移动到 Callback Queue；
* 如 Call Stack 为空（即同步代码执行完）Event Loop 开始工作；
* 轮询查找 Callback Queue，如有则移动到 Call Stack 执行；
* 然后继续轮询查找（永动机一样）。

DOM 事件和 event loop：

* JS 是单线程的；
* 异步（setTimeout，ajax 等）使用回调，基于 event loop；
* DOM 事件也使用回调，基于 event loop；

### 6. 模块化

对于 `CommonJS` 和 `ES6` 中的模块化的两者区别是：

* 前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案,前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。
* 而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
* 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。
* 但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化。
* 后者会编译成 `require/exports` 来执行的。

### 真题

#### 1. defer 和 async 

* `defer`并行加载 `js` 文件，会按照页面上`script`标签的顺序执行；
* `async`并行加载 `js` 文件，下载完成立即执行，不会按照页面上`script`标签的顺序执行；

#### 2. attribute 和 property 的区别是什么？

* `attribute`是`dom`元素在文档中作为`html`标签拥有的属性；
* `property`是`dom`元素在 `js` 中作为对象拥有的属性；

> 对于 `html` 的标准属性来说，`attribute`和`property`是同步的，是会自动更新的；但是对于自定义的属性来说，它们是不同步的。

#### 3. 如何通过 JS 判断一个数组

* `instanceof`方法

  `instanceof`运算符使用来测试一个对象是否在其原型链原型构造函数的属性。

  ```javascript
  let arr = []
  arr instanceof Array	// true
  ```

* `constructor`方法

  `constructor`属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。

  ```javascript
  let arr = []
  arr.constructor === Array	// true
  ```

* `Object.prototype.toString.call(value)`

  ```javascript
  Object.prototype.toString.call(value) // > '[object, type]'
  function isType(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1)
  }
  ```

* `ES6` 新增的方法`isArray()`

  ```javascript
  const a = new Array(123)
  const b = new Date()
  console.log(Array.isArray(a))	// true
  console.log(Array.isArray(b))	// false
  ```
  

#### 4. 事件的各个阶段

* 1：捕获阶段 ---> 2：目标阶段 ---> 3：冒泡阶段
* `document` ---> `target`目标 ----> `document`
* 由此，`addEventListener`的第三个参数设置为`true`和`false`的区别已经非常清晰了
  * `true`表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件
  * `false`表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件

#### 5. `var`、`let`、`const`

**var：**

* 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的
* 由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明

**let：**

* 允许你声明一个作用域被限制在块级中的变量、语句或者表达式
* let绑定不受变量提升的约束，这意味着let声明不会被提升到当前
* 该变量处于从块开始到初始化处理的“暂存死区”

**const：**

* 声明创建一个值的只读引用 (即指针)
* 基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 `const`申明基本数据类型时
* 再将其值改变时，将会造成报错， 例如 `const a = 3; a = 5`时 将会报错
* 但是如果是复合类型时，如果只改变复合类型的其中某个`Value`项时， 将还是正常使用

#### 6. 快速的让一个数组乱序

```javascript
var arr = [1,2,3,4,5,6,7,8,9,10];
arr.sort(function(){
    return Math.random() - 0.5;
})
console.log(arr);
```

#### 7. 怎样添加、移除、移动、赋值、创建和查找节点

**创建新节点：**

```javascript
createDocumentFragment()	// 创建一个 DOM 片段
createElement()	// 创建一个具体的元素
createTextNode()	// 创建一个文本节点
```

**添加、移除、替换、插入：**

```javascript
appendChild()	// 添加
removeChild()	// 移除
replaceChild()	// 替换
insertBefore()	// 插入
```

**查找：**

```javascript
getElementsByTagName()	// 通过标签名称
getElementsByClassName()	// 通过元素的 className
getElementById()	// 通过元素ID，唯一性
document.querySelectorAll()
```

#### 8. JavaScript 全局函数和全局变量

**全局变量**

* `Infinity` 代表正的无穷大的数值。
* `NaN` 指示某个值是不是数字值。
* `undefined` 指示未定义的值。

**全局函数**

* `decodeURI()` 解码某个编码的 `URI`。
* `decodeURIComponent()` 解码一个编码的 `URI` 组件。
* `encodeURI()` 把字符串编码为 URI。
* `encodeURIComponent()` 把字符串编码为 `URI` 组件。
* `escape()` 对字符串进行编码。
* `eval()` 计算 `JavaScript` 字符串，并把它作为脚本代码来执行。
* `isFinite()` 检查某个值是否为有穷大的数。
* `isNaN()` 检查某个值是否是数字。
* `Number()` 把对象的值转换为数字。
* `parseFloat()` 解析一个字符串并返回一个浮点数。
* `parseInt()` 解析一个字符串并返回一个整数。
* `String()` 把对象的值转换为字符串。
* `unescape()` 对由`escape()` 编码的字符串进行解码

#### 9. 浏览器缓存

> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下

* 先根据这个资源的一些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
* 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
* 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
* 当协商缓存也没命中时，服务器就会将资源发送回客户端。
* 当 `ctrl+f5` 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
* 当 `f5`刷新网页时，跳过强缓存，但是会检查协商缓存；

**强缓存**

* `Expires`（该字段是 `http1.0` 时的规范，值为一个绝对时间的 `GMT` 格式的时间字符串，代表缓存资源的过期时间）
* `Cache-Control:max-age`（该字段是 `http1.1`的规范，强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期，它的值单位为秒）

**协商缓存**

* `Last-Modified`（值为资源最后更新时间，随服务器response返回）
* `If-Modified-Since`（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
* `ETag`（表示资源内容的唯一标识，随服务器`response`返回）
* `If-None-Match`（服务器通过比较请求头部的`If-None-Match`与当前资源的`ETag`是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

#### 10. WebSocket

由于 `http` 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 `WebSocket`被发明出来。

与`http`相比具有一下特点：

* 支持双向通信，实时性更强；
* 可以发送文本，也可以二进制文件；
* 协议标识符是 `ws`，加密后是 `wss` ；
* 较少的控制开销。连接创建后，`ws`客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有`2~10`字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而`HTTP`协议每次通信都需要携带完整的头部；
* 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）
* 无跨域问题。

> 实现比较简单，服务端库如 `socket.io`、`ws`，可以很好的帮助我们入门。而客户端也只需要参照 `api` 实现即可。

#### 11. JavaScript 为什么是单线程？

* 单线程 - 只有一个线程，只能做一件事

* 原因 - 避免`DOM`渲染的冲突

  * 浏览器需要渲染 `DOM`
  * `JS` 可以修改 `DOM` 结构
  * `JS` 执行的时候，浏览器 `DOM` 渲染会暂停
  * 两段 JS 也不能同时执行（都修改 `DOM` 就冲突了）
  * `webworker` 支持多线程，但是不能访问 `DOM`

#### 12. EventLoop

`JS` 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 `Task`（有多种 `task`） 队列中。一旦执行栈为空，`Event` `Loop` 就会从 `Task` 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 `JS` 中的异步还是同步行为。

![eventloop](https://tva1.sinaimg.cn/large/008eGmZEgy1gn4oz9vjj6j322g0u043q.jpg)

不同的任务源会被分配到不同的 `Task` 队列中，任务源可以分为 微任务（`microtask`） 和 宏任务（`macrotask`）。在 `ES6` 规范中，`microtask` 称为 `jobs`，`macrotask` 称为 `task`。

```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

new Promise((resolve) => {
    console.log('Promise')
    resolve()
}).then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
// script start => Promise => script end => promise1 => promise2 => setTimeout
```

> 以上代码虽然 `setTimeout` 写在 `Promise` 之前，但是因为 `Promise` 属于微任务而 `setTimeout` 属于宏任务。

**微任务**

* `process.nextTick`
* `promise`
* `Object.observe`
* `MutationObserver`

**宏任务**

* `script`
* `setTimeout`
* `setInterval`
* `setImmediate`
* `I/O`
* `UI rendering`

> 宏任务中包括了 `script` ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务

**所以正确的一次 Event loop 顺序是这样的**

* 执行同步代码，这属于宏任务
* 执行栈为空，查询是否有微任务需要执行
* 执行所有微任务
* 必要的话渲染 UI
* 然后开始下一轮 `Event loop`，执行宏任务中的异步代码

> 通过上述的 `Event loop` 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 `DOM` 的话，为了更快的响应界面响应，我们可以把操作 `DOM` 放入微任务中

#### 13. JavaScript 对象生命周期的理解

* 当创建一个对象时，`JavaScript` 会自动为该对象分配适当的内存
* 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量
* 如果被引用数量为 `0`，或惟一引用是循环的，那么该对象的内存即可回收

#### 14. 说说从输入URL到看到页面发生的全过程，越详细越好

* 首先浏览器主进程接管，开了一个下载线程。
* 然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。
* 将下载完的内容转交给Renderer进程管理。
* Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。
* 解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。
* css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。
* 绘制结束后，关闭TCP连接，过程有四次挥手

#### 15. 浏览器的缓存机制

浏览器缓存机制有两种，一种为**强缓存**，另种为**协商缓存**：

* 对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。
* 对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行比对，如果比对有效则使用缓存。

**协商缓存相关设置**

* `Exprires`：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。`Exprires`的缺陷是必须保证服务端时间和客户端时间严格同步。
* `Cache-control：max-age`：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，
* `If-None-Match/ETag`：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回`If-None-Match`标识是否表示匹配。
* `Last-modified/If-Modified-Since`：第一次请求的时候服务端返回`Last-modified`表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头`If-Modified-Since`，表示资源上次的修改时间，服务端拿到这两个字段进行对比

#### 16. `ajax`、`axios`、`fetch`区别

**jQuery ajax**

```js
$.ajax({
   type: 'POST',
   url: url,
   data: data,
   dataType: dataType,
   success: function () {},
   error: function () {}
});
```

优缺点：

* 本身是针对`MVC`的编程,不符合现在前端`MVVM`的浪潮
* 基于原生的`XHR`开发，`XHR`本身的架构不清晰，已经有了`fetch`的替代方案
* `JQuery`整个项目太大，单纯使用`ajax`却要引入整个`JQuery`非常的不合理（采取个性化打包的方案又不能享受CDN服务）

**axios**

```js
axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
.then(function (response) {
    console.log(response);
})
.catch(function (error) {
    console.log(error);
});
```

优缺点：

* 从浏览器中创建 `XMLHttpRequest`
* 从 `node.js` 发出 `http` 请求
* 支持 `Promise API`
* 拦截请求和响应
* 转换请求和响应数据
* 取消请求
* 自动转换`JSON`数据
* 客户端支持防止`CSRF/XSRF`

**fetch**

```js
try {
  let response = await fetch(url);
  let data = response.json();
  console.log(data);
} catch(e) {
  console.log("Oops, error", e);

}
```

优缺点：

* `fetcht`只对网络请求报错，对`400`，`500`都当做成功的请求，需要封装去处理
* `fetch`默认不会带`cookie`，需要添加配置项
* `fetch`不支持`abort`，不支持超时控制，使用`setTimeout`及`Promise.reject`的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费
* `fetch`没有办法原生监测请求的进度，而XHR可以

#### 17. JavaScript 的组成

JavaScript 由以下三部分组成：

* `ECMAScript`（核心）：JavaScript 语言基础；
* `DOM`（文档对象模型）：规定了访问`HTML`和`XML`的接口；
* `BOM`（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法；

#### 18. JavaScript 内置对象由哪些？

* 数据封装类对象：`Object`、`Array`、`Boolean`、`Number`、`String`
* 其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`
* ES6新增对象：`Symbol`、`Map`、`Set`、`Promises`、`Proxy`、`Reflect`

#### 19. JavaScript 的数据类型，及在内存中存储的位置

* 原始数据类型（`Undefined`，`Null`，`Boolean`，`Number`、`String`）-- 栈
* 引用数据类型（对象、数组和函数）-- 堆
* 两种类型的区别是：存储位置不同：
* 原始数据类型是直接存储在栈(`stack`)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；
* 引用数据类型存储在堆(`heap`)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；
* 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。
* 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

#### 20. JavaScript 垃圾回收方法

**标记清除（make and sweep）：**

> * 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
> * 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了

**引用计数（reference counting）：**

> 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间

#### 21. `this`指向

1. this 指向右哪几种：
   * 默认绑定：全局环境中，`this`默认绑定到`window`。
   * 隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，`this`隐式绑定到该直接对象。
   * 隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到`window`。显式绑定：通过`call()`、`apply()`、`bind()`方法把对象绑定到`this`上，叫做显式绑定。
   * `new`绑定：如果函数或者方法调用之前带有关键字`new`，它就构成构造函数调用。对于`this`绑定来说，称为`new`绑定。
     * 构造函数通常不使用`return`关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值
     * 如果构造函数使用`return`语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果
     * 如果构造函数显式地使用`return`语句返回一个对象，那么调用表达式的值就是这个对象
2. 改变函数内部 this 指针的指向函数（bind，apply，call 的区别）
   * `apply`：调用一个对象的一个方法，用另一个对象替换当前对象。例如：`B.apply(A, arguments)`;即A对象应用B对象的方法。
   * `call`：调用一个对象的一个方法，用另一个对象替换当前对象。例如：`B.call(A, args1,args2)`;即A对象调用B对象的方法。
   * `bind`除了返回是函数以外，它的参数和`call`一样。
3. 箭头函数
   * 箭头函数没有`this`，所以需要通过查找作用域链来确定`this`的值，这就意味着如果箭头函数被非箭头函数包含，`this`绑定的就是最近一层非箭头函数的`this`，
   * 箭头函数没有自己的`arguments`对象，但是可以访问外围函数的`arguments`对象
   * 不能通过`new`关键字调用，同样也没有`new.target`值和原型

#### 22. 判断是否是数组

* `Array.isArray(arr)`
* `Object.prototype.toString.call(arr) === '[Object Array]'`
* `arr instanceof Array`
* `array.constructor === Array`

#### 23. 加载

1. **异步加载 JS 方法**

   * `defer`：只支持 IE 如果您的脚本不会改变文档的内容，可将`defer`属性加入到`<script>`标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全的读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档显示给用户为止。
   * `async`：`HTML5`属性，仅适用于外部脚本；并且如果 IE 中，同时存在`defer`和`async`，那么`defer`的优先级比较高；脚本将在页面完成时执行。

2. **图片的懒加载和预加载**

   * 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。
   * 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

   > 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。



## 从 JS 基础知识到 JS Web API

* JS 基础知识，规定语法（ECMA 262 标准）
* JS Web API，网页操作的 API（W3C 标准）
* 前者是后者的基础，两者结合才能真正实际应用

JS 基础知识：

* 变量类型和计算
* 原型和原型链
* 作用域和闭包

JS Web API：

* DOM
* BOM
* 事件绑定
* Ajax
* 存储

### 1. DOM 操作（Document Object Model）

#### 1.1 DOM 本质

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
  </head>
  <body>
    <div>
      <p>this is p</p>
    </div>
  </body>
</html>
```

DOM 是 Document Object Module 的缩写。大概意思是浏览器给 Javascript 操作网页 Html 文档的一种树状数据结构，可以通过浏览器给 Javascript 设置的可以访问网页文档的全局变量如`document`、`window`来创建、获取、添加、删除浏览器 Html 文档上的节点。

#### 1.2 DOM 节点操作

```javascript
const div1 = document.getElementById('div1')	// 元素
const divList = document.getElementsByTagName('div')	// 集合
console.log(divList.length)
console.log(divList[0])

const containerList = document.getElementsByClassName('container')	// 集合
const pList = document.querySelectorAll('p')	// 集合
```
#### 1.3 DOM 结构操作

* 获取子元素列表，获取父元素

  ```javascript
  // 获取父元素
  const div1 = document.getElementById('div1')
  const parent = div1.parentNode
  
  // 获取子元素列表
  const div1 = document.getElementById('div1')
  const child = div1.childNodes
  ```

* 新增 / 插入节点

  ```javascript
  const div1 = document.getElementBuId('div1')
  // 添加新节点
  const p1 = document.createElement('p')
  p1.innerHTML = 'this is p1'
  div1.appendChild(p1)	// 添加新创建的元素
  // 移动已有节点。(注意是移动)
  const p2 = document.getElementById('p2')
  div1.appendChild(p2)
  ```

* 删除子元素

  ```javascript
  const div1 = document.getElementById('div1')
  const child = div1.childNodes
  div1.removeChild(child[0])
  ```

#### 1.4 property 和 attr 的区别

property 是浏览器提供给 JavaScript 的可以用来获取或修改节点的属性值，如 `className`。

```javascript
var div1 = docement.getElementById('div1')
div1.className = 'banner'
```

attr 是通过 `getAttribute` 和 `setAttribute`来获取或者修改 Html 文档标签上的任意属性值。

```javascript
var p1 = document.getElementById('p1')
p1.setAttribute('data-name', '123')
var attr = p1.getAttribute('data-name')
```

* property：修改对象属性，不会体现到 html 结构中；
* attribute：修改 html 属性，会改变 html 结构；
* 两者都有可能引起 DOM 重新渲染（建议优先考虑使用 property）；


#### 1.5 DOM 性能

DOM 操作非常“昂贵”，避免频繁的 DOM 操作：

* 对 DOM 查询做缓存；
* 将频繁操作改为一次性操作；

##### 1.5.1 DOM 查询做缓存

```javascript
// 不缓存 DOM 查询结果
for (let i = 0; i < document.getElementsByTagName('p').length; i++) {
  // 每次循环，都会计算 length，频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName('p')
const length = pList.length
for(let i = 0; i < length; i++) {
  // 缓存 length，只进行一次 DOM 查询
}
```

##### 1.5.2 将频繁操作改为一次性操作

```javascript
const listNode = document.getElementById('list')

// 创建一个文档片段，此时还没有插入到 DOM 树中
const frag = document.createDocumentFragment()

// 执行插入
for(let x = 0; x < 10; x++) {
  const li = document.createElement('li')
  li.innerHTML = 'List item' + x
  frag.appendChild(li)
}

// 都完成后，再插入到 DOM 树中
listNode.appendChild(frag)
```

#### 题目

* DOM 是哪种数据结构？

  > 树（DOM 树）

* DOM 操作的常用 API ？

  > DOM 节点操作
  >
  > DOM 结构操作

* attr 和 property 的区别？

  > property：修改对象属性，不会体现到 html 结构中；
  >
  > attribute：修改 html 属性，会改变 html 结构；
  >
  > 两者都有可能引起 DOM 重新渲染；

* 一次性插入多个 DOM 节点，考虑性能？

  ```javascript
  // 创建一个文档片段，此时还没有插入到 DOM 树中
  const frag = document.createDocumentFragment()
  ```
  
* offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别

  * `offsetWidth/offsetHeight`返回值包含 **content + padding + border**
  * `clientWidth/clientHeight`返回值只包含 **content + padding**，如果有滚动条，也**不包含滚动条**
  * `scrollWidth/scrollHeight`返回值包含 **content + padding + 溢出内容的尺寸**

### 2. BOM 操作（Browser Object Model）

#### 2.1 navigator

```javascript
// navigator
const ua = navigator.userAgent
const isChrome = ua.indexOf('Chrome')
console.log(isChrome)
```

#### 2.2 screen

```javascript
// screen
console.log(screen.width)
console.log(screen.height)
```

#### 2.3 location

```javascript
// location
console.log(location.href)
console.log(location.protocol)	// 'http:', 'https:'
console.log(location.pathname)	// '/learn/199'
console.log(location.search)
console.log(location.hash)
```

#### 2.4 history

```javascript
// history
history.back()
history.forwrad()
```

#### 2.5 Service Worker

`Service worker`本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其它之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。它们还允许访问推送通知和后台同步 API。

*目前该技术通常用来做缓存文件，提高首屏速度。*

```javascript
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register("sw.js")
    .then(function(registration) {
      console.log("service worker 注册成功");
    })
    .catch(function(err) {
      console.log("servcie worker 注册失败");
    });
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener("install", e => {
  e.waitUntil(
    caches.open("my-cache").then(function(cache) {
      return cache.addAll(["./index.html", "./index.js"]);
    })
  );
});

// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener("fetch", e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response;
      }
      console.log("fetch source");
    })
  );
});
```

### 3. 事件

#### 3.1 事件机制

事件触发三阶段：

* `document`往事件触发处传播，遇到注册的**捕获**事件会触发；
* 传播到事件触发处时触发注册的事件；
* 从事件触发处往`document`传播，遇到注册的**冒泡**事件会触发；

> 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。
>
> ```javascript
> // 以下会先打印冒泡然后是捕获
> node.addEventListener('click', (event) => {
>   console.log('冒泡')
> }, false)	// false 冒泡事件
> node.addEventListener('', (event) => {
>   console.log('捕获')
> }, true)	// true 捕获事件
> ```

注册事件：

* 通常我们使用`addEventListener`注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值`useCapture`参数来说，该参数默认值为`false`。`useCapture`决定了注册的事件是捕获事件还是冒泡事件。

* 一般来说，我们只希望事件只触发在目标上，这时候可以使用`stopPropagation`来阻止事件的进一步传播。`stopImmediatePropagation`同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。

  ```javascript
  node.addEventListener('click', (event) => {
    event.stopImmediatePropagation()
    console.log('冒泡')
  }, false)
  node.addEventListener('click', (event) => {
    console.log('捕获')
  }, true)
  ```

#### 3.2 事件绑定

```javascript
const btn = document.getElementById('btn1')
btn.addEventListener('click', event => {
  console.log('clicked')
})
```

```javascript
// 通用的绑定函数
function bindEvent(elem, type, fn) {
  elem.addEventListener(type, fn)
}

const a = document.getEmementById('link1')
bindEvent(a, 'click', e => {
  e.preventDefault()	// 阻止默认行为
  // console.log(event.target)	// 获取触发的元素
  alter('clicked')
})
```

#### 3.3 事件冒泡

```html
// html
<body>
  <div id="div1">
    <p id="p1">激活</p>
    <p id="p2">取消</p>
    <p id="p3">取消</p>
    <p id="p4">取消</p>
  </div>
  <div id="div2">
    <p id="p5">取消</p>
    <p id="p6">取消</p>
  </div>
</body>
```

```javascript
// javascript
const p1 = document.getElementById('p1')
const body = document.body
bindEvent(p1, 'click', e => {
  e.stopPropagation()	// 阻止事件冒泡
  alert('激活')
})
bindEvent(body, 'click', e => {
  alert('取消')
})
```

#### 3.4 事件代理

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。

```html
<div id="div1">
  <a href="#">a1</a>
  <a href="#">a2</a>
  <a href="#">a3</a>
  <a href="#">a4</a>
</div>
<button>
  点击增加一个 a 标签
</button>
```

```javascript
const div1 = document.getElementById('div1')
div1.addEventListener('click', e => {
  event.preventDefault()
  const target = e.target
  if (e.nodeName === 'A') {
    alert(target.innerHTML)
  }
})
```

> 优点：
>
> * 节省内存
> * 不需要给子节点注销事件
>
> 代码简洁；减少浏览器内存占用；但是，不要滥用。

通用的事件绑定函数：

```javascript
function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector
    selector = null
  }
  elem.addEventListener(type, event => {
    const target = event.target
    if (selector) {
      // 代理绑定
      if (target.matches(selector)) fn.call(target, event)
    } else {
      // 普通绑定
      fn.call(target, event)
    }
  })
}
```

#### 题目：

* 编写一个通用的事件监听函数？

* 描述事件冒泡的流程？

  > 基于 DOM 树形结构；
  >
  > 事件会顺着触发元素往上冒泡；
  >
  > 应用场景：代理

* 无限下拉的图片列表，如何监听每个图片的点击？

  > 事件代理；
  >
  > 用 e.target 获取触发元素；
  >
  > 用 matches 来判断是否是触发元素；



### 4. ajax

#### 4.1 XMLHttpRequest

```javascript
// get 请求
const xhr = new XMLHttpRequest()
xhr.open('GET', '/api', true)	// true 是异步的请求
xhr.onreadystatechange = function() {
  // 这里的函数异步执行，可参考之前 JS 基础中的异步模块
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      alert(xhr.responseText)
    }
  }
}
xhr.send(null)
```

```javascript
// post 请求
const xhr = new XMLHttpRequest()
xhr.open('POST', 'api', true)
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      alert(xhr.responseText)
    }
  }
}
const postData = {
  username: 'zhangsan',
  password: 'xxx'
}
xhr.send(JSON.stringify(postData))
```

#### 4.2 状态码

##### 4.2.1 xhr.readyState

* 0 - （为初始化）还没有调用 send() 方法；
* 1 - （载入）已调用 send() 方法，正在发送请求；
* 2 - （载入完成）send() 方法执行完成，已经接受到全部响应内容；
* 3 - （交互）正在解析响应内容；
* 4 - （完成）响应内容解析完成，可以在客户端调用；

##### 4.2.2 xhr.status

* 2xx - 表示成功处理请求，如 200
* 3xx - 需要重定向，浏览器直接跳转，如 301、302、304
* 4xx - 客户端请求错误，如 403、404
* 5xx - 服务器端错误

#### 4.3 跨域：同源策略，跨域解决方案

##### 4.3.1 什么是跨域（同源策略）

* ajax 请求时，浏览器要求当前网页和 server必须同源（安全）；
* 同源：协议、域名、端口，三者必须一致；
* 前端：http://a.com:8080 &nbsp; server：https://b.com/api/xxx

##### 4.3.2 加载图片 css  js 可无视同源策略

* `<img src=跨域的图片地址 />`
* `<link href=跨域的 css 地址 />`
* `<script src=跨域的 JS 地址></script>`

利用上述三种无视同源的策略，我们可以用来做什么：

* `<img />` 可用于统计打点，可使用第三方统计服务；
* `<link />`  可使用 CDN，CDN一般都是外域；
* `<script>` 可实现 JSONP ；

> 所有的跨域，都必须经过 server 端允许和配合；未经 server 端允许就实现跨域，说明浏览器有漏洞，危险信号。

##### 4.3.3 JSONP

访问 https://imooc.com ，服务端一定返回一个 html 文件吗？

服务器可以任意动态拼接数据返回，只要符合 html 格式要求；同理于 `<script src="https://imooc.com/getData.js">`

* `<script>` 可绕过跨域限制；
* 服务器可以任意动态拼接数据返回；
* 所以，`<script>`就可以获得跨域的数据，只要服务端愿意返回。

```html
<script>
window.callback = function(data) {
  // 这是我们跨域得到的信息
  console.log(data)
}
</script>
<script src="https://imooc.com/getData.js"></script>
<!-- 将返回 callback({ x: 100, y: 200 }) -->
```

jQuery 实现 jsonp ：

```javascript
$.ajax({
  url: 'http://localhost:8882/x-origin.json',
  dataType: 'jsonp',
  jsonpCallback: 'callback',
  success: function(data) {
    console.log(data)
  }
})
```

`JSONP` 使用简单且兼容性不错，但是只限于 `get` 请求。

##### 4.3.4 CORS（服务端支持）

* `CORS`需要浏览器和后端同时支持
* 浏览器会自动进行`CORS`通信，实现`CORS`通信的关键是后端。只要后端是下了`CORS`，就实现了跨域。
* 服务器设置`Access-Control-Allow-Origin`就可以开启`CORS`。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

CORS - 服务器设置 http header

```javascript
// 第二个参数填写允许跨域的域名称，不建议直接写 “*”
response.setHeader("Access-Control-Allow-Origin", "http://localhost:8011");
response.setHeader("Access-Control-Allow-Headers", "X-Requested-Width");
response.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");

// 接受跨域的 cookie
response.setHeader("Access-Control-Allow-Credentials", "true")
```

#### 题目：

* 手写一个简易的 ajax 

  ```javascript
  function ajax(url) {
    const p = new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest()
      xhr.open('GET', '/api', true)
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            resolve(JSON.parse(xhr.responseText))
          } else if (xhr.status === 404) {
            reject(new Error('404 not found'))
          }
        }
      }
      xhr.send(null)
    })
    return p
  }
  ```

* 跨域的常用实现方式？

  > * JSONP
  >
  > * CORS



### 5. 存储

#### 5.1 cookie

* 本身用于浏览器和 server 通讯
* 被“借用”到本地来存储
* 可用 document.cookie = ' ... ' 来修改

**cookie 的缺点：**

* 存储大小，最大 4KB；
* http 请求时需要发送到服务器，增加请求数量；
* 只能用 document.cookie = ' ... ' 来修改，太过简陋；

#### 5.2 localStorage 和 sessionStorage

* HTML5 专门为存储而设计，最大可存 5M；
* API 简单易用 `setItem`、`getItem`；
* 不会随着 http 请求被发送出去；

**区别：**

* localStorage 数据会永久存储，除非代码或手动删除；
* sessionStorage 数据只存在于当前会话，浏览器关闭则清空；
* 一般用 localStorage 会更多一些；

#### 题目

* 描述 cookie、localStorage、sessionStorage 区别？

  > 容量
  >
  > API 易用性
  >
  > 是否跟随 http 请求发送出去

### 6. http 

前端工程师开发界面，需要调用后端的接口，提交、获取数据 —— http 协议。

#### 6.1 http 状态码

##### 6.1.1 状态码分类

* 1xx 服务器收到请求
* 2xx 请求成功，如 200
* 3xx 重定向，如 302
* 4xx 客服端错误，如 404
* 5xx 服务端错误，如 500

##### 6.1.2 常见状态码

* 200 成功
* 301 永久重定向（配合 location，浏览器自动处理）
* 302 临时重定向（配合 location，浏览器自动处理）
* 304 资源未被修改
* 404 资源未找到
* 403 没有权限
* 500 服务器错误
* 504 网关超时

##### 6.1.3 关于协议和规范

就是一个约定，要求大家都跟着执行，不要违反规范，例如 IE 浏览器。

#### 6.2 http methods

##### 6.2.1 传统的 methods

* get 获取服务器的数据
* post 向服务器提交数据

简单的网页功能，就这两个操作。

##### 6.2.2 现在的 methods

* get 获取数据
* post 新建数据
* patch / put 更新数据
* delete 删除数据

##### 6.2.3 Restful API 

* 一种新的 API 设计方法（早已推广使用）
* 传统 API 设计：把每个 URL 当做一个功能；
* Restful API 设计：把每个 URL 当做一个唯一的资源标识；

如何设计成一个资源？

* 尽量不用 URL 参数；
  * 传统 API 设计：/api/list?pageIndex=2
  * Restful API 设计：/api/list/2
* 用 method 表示操作类型；
  * 传统 API 设计：
    * post 请求：/api/create-blog
    * post 请求：/api/update-blog?id=100
    * get 请求：/api/get-blog?id=100
  * Restful API  设计：
    * post 请求：/api/blog
    * patch 请求：/api/blog/100
    * get 请求：/api/blog/100

#### 6.3 http headers

##### 6.3.1 常见的 Request Headers

* Accept 浏览器可接收的数据格式；
* Accept-Encoding 浏览器可接收的压缩算法，如 gzip；
* Accept-Languange 浏览器可接收的语言，如 zh-CN；
* Connection：keep-alive 一次 TCP 连接重复使用；
* cookie
* Host
* User-Agent（简称 UA）浏览器信息
* Content-type 发送数据的格式，如 application/json

##### 6.3.2 常见的 Response Headers

* Content-type 返回数据的格式，如 application/json
* Content-length 返回数据的大小，多少字节
* Content-Encoding 返回数据的压缩算法，如 gzip
* Set-Cookie

##### 6.3.3 自定义 header

```javascript
/* axios-js.com/docs/#Request-Config */
// 'headers' are custome headers to be sent

headers: { 'X-Requested-Width': 'XMLHttpRequest' }
```

##### 6.3.4 缓存相关的 headers

* Cache-Control  &nbsp;  Expires
* Last-Modified  &nbsp; If-Modified-Since
* Etag  &nbsp;  If-None-match

#### 6.4 http 缓存

##### 6.4.1 关于缓存的介绍

* 什么是缓存？

  > http 缓存指的是：当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有要请求资源的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

* 为什么需要缓存？

  > 通过复用以前获取的资源，可以显著提高网站和应用程序的性能。Web 缓存减少了等待时间和网络流量，因此减少了显示资源表示形式所需的时间。通过使用 HTTP 缓存，变得更加响应性。

* 哪些资源可以被缓存？

  > 静态资源（js 、css、img）

##### 6.4.2 http 缓存策略（强制缓存 + 协商缓存）

###### 6.4.2.1 http 缓存 - 强制缓存

![64D0D05F-BF0E-4DB4-A3EE-A79CEAAE0475_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm5h82tfj30tv0kbta7.jpg)

**Cache-Control：**

Response Headers 中，控制强制缓存的逻辑。例如 Cache-Control：max-age=31536000 (单位秒) *最大时间一年*。

**Cache-control 的值：**

* max-age：设置缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒）。
* no-cache：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存验证）。
* no-store：缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。

* private：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。
* public：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。

**关于 Expires**

* 同在 Response Headers 中
* 同为控制缓存过期
* 已被 Cache-Control 代替

小结：

* 实现强缓存可以通过两种响应头实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 `200`。
* `Expires` 是 `HTTP / 1.0` 的产物，表示资源会在`Wed`,`22 Oct 2018 08:41:00 GMT` 后过期，需要再次请求。并且 `Expires` 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
* `Cache-Control` 出现于 `HTTP / 1.1`，优先级高于 `Expires` 。该属性表示资源会在 `30` 秒后过期，需要再次请求。

###### 6.4.2.2 http 缓存 - 协商缓存

* 服务器端缓存策略；
* 服务器判断客户端资源，是否和服务端资源一样；
* 一致则返回 304，否则返回 200 和最新的资源；

![F28D66EB-89C6-481F-A427-04BFBD2B1C7C_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm62adp1j30ti0kkwg0.jpg)

**资源标识：**

在 Response Headers 中，有两种：

* Last-Modified 资源的最后修改时间；

  ![1339B408-C40B-4BED-AD20-F38BB25087A9_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm69rlnkj30ux0jlabn.jpg)

* Etag 资源的唯一标识（一个字符串，类似人类的指纹）；

  ![79BF65DE-811B-4AFC-97CF-5BEEB94B11A1_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6fama8j30ug0jxjsu.jpg)

**Last-Modified 和 Etag**

* 会优先使用 Etag，
* Last-Modified 只能精确到秒级，
* 如果资源被重复生成，而内容不变，则 Etag 更精确；

![05B19ECF-F0EB-43C4-BC6B-D7A4AAB45F7E_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6kxrx8j313a0fgdhh.jpg)

![4BC90980-9603-452A-A429-5AC711C6ACE6_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6oq92pj30wz0iejsm.jpg)

小结：

协商缓存需要客户端和服务器共同实现，如果缓存有效会返回`304`。和强缓存一样，也有两种实现方式：

* Last-Modified 和 If-Modified-Since

  `Last-Modified`表示本地文件最后修改日期，`If-Modified-Since` 会将 `Last-Modified` 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

* Tag 和 If-None-Match

  `ETag` 类似于文件指纹，`If-None-Match` 会将当前 `ETag`发送给服务器，询问该资源 `ETag` 是否变动，有变动的话就将新的资源发送回来。并且 `ETag` 优先级比 `Last-Modified` 高。

怎样选择合适的缓存策略：

> 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

* 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
* 对于频繁变动的资源，可以使用 `Cache-Control: no-cache`并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
* 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

##### 6.4.3 刷新操作方式，对缓存的影响

三种刷新操作：

* 正常操作：地址栏输入 URL，跳转链接，前进后退等；

  > 正常操作：强制缓存有效，协商缓存有效

* 手动刷新：F5，点击刷新按钮，右击菜单刷新，`ctrl/command + r`；

  > 手动刷新：强制缓存失效，协商缓存有效

* 强制刷新：win: `ctrl + F5`  ， Mac：`shfit + command + r`;

  > 强制刷新：强制缓存失效，手动缓存失效

##### 6.4.4 http 缓存-综述

![24767724-5DDB-43B4-9FD5-B2E658E9D26D_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6shnl1j30se0lct9r.jpg)

#### 题目：

* http 常见的状态码有哪些？
* http 常见的 header 有哪些？
* 什么是 Restful API ？
* 描述一下 http 的缓存机制（重要）？

### 真题

####1. 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？

按照 W3C 标准的事件：首先是进入捕获阶段，直到达到目标阶段，再进入冒泡阶段。

事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数

* 注意1：前提是事件被确实触发
* 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”

事件执行顺序：判断的关键是否目标元素

* 非目标元素：根据W3C的标准执行：捕获->目标元素->冒泡（不依据事件绑定顺序）

* 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）

* 最终顺序：父元素捕获->目标元素事件1->目标元素事件2->子元素捕获->子元素冒泡->父元素冒泡

> 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系

#### 2. 一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？

* 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）
* 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获
* 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡

#### 3. 事件代理（委托）

事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件。

* 优点：

  * 可以减少事件注册，节省大量内存占用
  * 可以将事件应用于动态添加的子元素上

* 缺点： 使用不当会造成事件在不应该触发时触发

* 示例：

  ```javascript
  ele.addEventListener('click', function(e){
      var target = event.target || event.srcElement;
      if(!!target && target.nodeName.toUpperCase() === "LI"){
          console.log(target.innerHTML);
      }
  }, false);
  ```

#### 4. W3C 事件的 `target`与`currentTarget`的区别？

* `target`只会出现在事件流的目标阶段；
* `currentTarget` 可能出现在事件流的任何阶段；
* 当事件流处在目标阶段时，二者的指向相同；
* 当事件流处于捕获或冒泡阶段时：`currentTarget`指向当前时间活动的对象（一般为父级）；

#### 5. 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”

* 客户区坐标：鼠标指针在可视区中的水平坐标(`clientX`)和垂直坐标(`clientY`)
* 页面坐标：鼠标指针在页面布局中的水平坐标(`pageX`)和垂直坐标(`pageY`)
* 屏幕坐标：设备物理屏幕的水平坐标(`screenX`)和垂直坐标(`screenY`)

**如何获得一个DOM元素的绝对位置？**

* `elem.offsetLeft`：返回元素相对于其定位父级左侧的距离
* `elem.offsetTop`：返回元素相对于其定位父级顶部的距离
* `elem.getBoundingClientRect()`：返回一个`DOMRect`对象，包含一组描述边框的只读属性，单位像素

#### 6. 把`<script>`放在`</body>`之前和之后有什么区别？浏览器会如何解析它们？

* 按照HTML标准，在`</body>`结束后出现`<script>`或任何元素的开始标签，都是解析错误
* 虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在`</body>`之前没有区别
* 浏览器的容错机制会忽略`<script>`之前的`</body>`，视作`<script>`仍在 body 体内。省略`</body>`和`</html>`闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容



## 开发环境

### 1. git

* 最常用的代码版本管理工具；
* 大型项目需要多人协作开发，必须使用 git 对代码进行管理；

**常用 git 命令：**

* `git add .`
* `git commit -m "xxx"`
* `git push origin master`
* `git pull origin master`
* `git branch`
* `git checkout -b xxx`
* `git checkout xxx`
* `git merge xxx`
* `git stach`
* `git stach pop`


### 2. chrome 调试工具

* Elements
* Console
* debugger
* Network
* Application

### 3. 抓包

* 移动端 h5 页，查看网络请求，需要用工具抓包
* Windows 一般用 fiddler
* Mac OS 一般用 Charles

抓包过程：

* 手机和电脑连在同一个局域网
* 将手机代理到电脑上
* 手机浏览网页，即可抓包

### 4. webpack  babel

* ES6 模块化，浏览器暂不支持；
* ES6 语法，浏览器并不完全支持；
* 压缩代码，整合代码，以让网页加载更快；

```javascript
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  mode: 'development', 	// production
  entry: path.join(__dirname, 'src', 'index.js')
  output: {
    filename: 'bundle.js'
    path: path.join(__dirname, 'dist')
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: ['babel-loader'],
        include: path.join(__dirname, 'src'),
        exclude: /node_modules/
      }
    ]
  }
  plugins: [
    new HtmlWebpackPlugin({
      template: path.join(__dirname, 'src', 'index.html'),
      filename: 'index.html'
    })
  ],
  devServer: {
    port: 3000,
    contentBase: path.join(__dirname, 'dist')
  }
}
```

### 5. Linux 常用命令

* `ls` 查看文件及文件夹
* `ls -a` 查看隐藏的文件及文件夹
* `ll` 列表平铺文件及文件夹
* `clear` 清楚 shell
* `mkdir xxx` 新建文件夹
* `rm -rf xxx` 删除文件
* `cd xxx` 进入某个文件夹
* `mv xxx1 xxx2` 重命名文件
* `mv file ./dir` 移动文件
* `cp file1 file2` 拷贝文件
* `thouch xxx` 新建文件
* `cat xxx` 打印文件头
* `tail xxx`  打印文件头
* `grep 'xxx' file`  查找
* vim 编辑器
  * `vim d.js` 用 vim 打开文件
  * `i`  进入编辑模式
  * `ESC` 退出编辑模式
  * `:q` 保存文件并退出
  * `:q!` 强制退出，不保存文件



## 运行环境

运行环境及浏览器（server 端有 nodejs）。下载网页代码，渲染出页面，期间会执行若干 JS 。要保证代码在浏览器中：稳定且高效。

### 1. 网页加载过程

#### 1.1 加载资源的形式

* html 代码
* 媒体文件，如图片、视频等
* javascript、css

#### 1.2 加载资源的过程

* DNS 解析：域名 -> IP 地址
* 浏览器根据 IP 地址向服务器发起 http 请求
* 服务器处理 http 请求，并返回给浏览器

#### 1.3 渲染页面的过程

* 根据 HTML 代码生成 DOM Tree
* 根据 CSS 代码生成 CSSOM
* 将 DOM Tree 和 CSSOM 整合形成 Render Tree
* 根据 Render Tree 渲染页面
* 遇到 `<script>`则暂停渲染，优先加载并执行 JS 代码，完成再继续
* 直至把 Render Tree 渲染完成

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="test.css">
  </head>
  <body>
    <div>test</div>
  </body>
</html>
```

```css
div {
  width: 100%;
  height: 100%;
  font-size: 50px;
}
```

#### 1.4 window.onload 和 DOMContentLoaded

```javascript
window.addEventListener('load', function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})
document.addEventListener('DOMContentloaded', function() {
  // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

#### 1.5 重绘（Repaint）和回流（Reflow）

* 重绘是当节点需要更改外观而不会影响布局的，比如改变`color`就称为重绘；
* 回流是布局或者几何属性需要改变称为回流；

> 回流必定会发生重绘，重绘不一定会引起回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。

**以下几个动作可能会导致性能问题：**

* 改变 `window` 大小；
* 改变字体；
* 添加或删除样式；
* 文字改变；
* 定位或者浮动；
* 盒模型；

#### 题目：

* 从输入 URL 到渲染出页面的整个过程

  > 下载资源：各个资源类型，下载过程
  >
  > 渲染页面：结合 html、css、javascript 图片等

* window.onload 和 DOMContentLoaded 的区别

  > window.onload：资源全部加载完才能执行，包括图片；
  >
  > DOMContentLoaded：DOM 渲染完成即可，图片可能尚未下载

### 2. 性能优化

* 是一个综合性问题，没有标准答案，但要求尽量全面
* 某些细节问题可能会单独提问：手写防抖、节流

#### 2.1 性能优化原则

* 多使用内存、缓存或其他方法

* 减少 CPU 计算量，减少网络加载耗时

> 适用于所有编程的性能优化——空间换时间

#### 2.2 从何入手

##### 2.2.1 让加载更快

* 减少资源体积：压缩代码；
* 减少访问次数：合并代码，SSR 服务器端渲染，缓存；
* 使用更快的网络：CDN

##### 2.2.2 让渲染更快

* CSS 放在 head，JS 放在 body 最下面；
* 尽早开始执行 JS，用 DOMContentLoaded 触发；
* 懒加载（图片懒加载，上滑加载更多）；
* 对 DOM 查询进行缓存；
* 频繁 DOM 操作，合并到一起插入 DOM 结构；
* 节流 throttle，防抖 debounce；

##### 2.2.3 示例

###### 2.2.3.1 资源合并

```html
// 未合并
<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>

// 合并后
<script src="abc.js"></script>
```

###### 2.2.3.2 缓存

![ADB0C755-916F-4BD6-8EE0-07CCB5AD755E_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmvm6ziiz3j30sw0kzta1.jpg)

* 静态资源加 hash 后缀，根据文件内容计算 hash；
* 文件内容不变，则 hash 不变，则 URL 不变；
* URL 和文件不变，则会自动触发 http 缓存机制，返回 304；

###### 2.2.3.3 SSR

* 服务器端渲染：将网页和数据一起加载，一起渲染；
* 非 SSR（前后端分离）：先加载网页，再加载数据，在渲染数据；
* 早先的 JSP、ASP、PHP，现在的 Vue React SSR；

###### 2.2.3.4 懒加载

```html
<img src="img1" src="preview.png" data-realsrc="abc.png"/>
<script type="text/javascript">
  var img1 = document.getElementById('img1')
  img1.src = img1.getAttribute('data-realsrc')
</script>
```

###### 2.2.3.5 缓存 DOM 查询

```javascript
// 不缓存 DOM 查询结果
for (let = 0; i < document.getElementsByTagName('p').length; i++) {
  // 每次循环，都会计算 length，频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const pList = document.getElementsByTagName('p')
const length = pList.length
for (let i = 0; i < length; i++) {
  // 缓存 length，只进行一次 DOM 查询
}
```

###### 2.2.3.6 多个 DOM 操作一起插入到 DOM 结构

```javascript
const listNode = document.getElementById('list')

// 创建一个文档片段，此时还没有插入到 DOM 树中
const frag = document.createDocumentFragment()

// 执行插入
for(let x = 0; x < 10; x++) {
  const li = document.createElement('li')
  li.innerHTML = 'List item ' + x
  frag.appendChild(li)
}

// 都完成后，再插入到 DOM 树中
listNode.appendChild(frag)
```

###### 2.2.3.7 尽早开始 JS 执行

```javascript
window.addEventListener('load', function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})

document.addEventListener('DOMContentLoaded', function() {
  // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

#### 2.3 防抖 debounce

防抖动是将多次执行变为最后一次执行。

* 监听一个输入框的文字变化后触发 change 事件；
* 直接用 keyup 事件，则会频繁触发 change 事件；
* 防抖：用户输入结束或停止时，才会触发 change 事件；

```javascript
// 防抖
function debounce(fn, delay = 500) {
  // timer 是闭包中的
  let timer = null
  return function() {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}
```

#### 2.4 节流 throttle

节流是将多次执行变成每隔一段时间执行。

* 拖拽一个元素时，要随时拿到该元素被拖拽的位置；
* 直接用 drag 事件，则会频繁触发，很容易导致卡顿；
* 节流：无论推拽速度多快，都会每隔 100ms 触发一次；

```javascript
// 节流
function throttle(fn, delay = 100) {
  let timer = null
  return function() {
    if (timer) return
    timer = setTimeout(() => {
      fn.apply(this, arguments)
      timer = null
    }, delay)
  }
}
```

### 3. Web 安全

#### 3.1 XSS 跨站请求攻击

一个博客网站，我发表一篇博客，其中嵌入`<script>`脚本；脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）；发布这篇博客，有人查看它，我就能轻松收割访问者的 cookie。

**XSS 预防：**

* 替换特殊字符，如 `<`变成`&lt;`，`>`变成`&gt;`
* `<script>`变成 `&lt;script&gt;`，直接显示，而不会作为脚本执行；
* 前端要替换，后端也要替换。

#### 3.2 CSRF 跨站请求伪造

你正在购物，看中了某个商品，商品 id 是 100，付费接口是 `xxx.com/pay?id=100`，但没有任何验证；我向你发送一封电子邮件，邮件标题很吸引人；但邮件正文隐藏着 `<img src='xxx.com/pay?id=200'/>`，你一查看邮件，就帮我买了 id 是 200 的商品。

**CSRF 预防：**

* `get`请求不对数据进行修改；

* 使用 post 接口；
* 阻止第三方网站请求接口
* 增加验证，例如密码、短信验证码、指纹等；





## jQuery

### 1. jQuery 源码有哪些写的好的地方？

* `jQuery`源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入`window`对象参数，可以是`window`对象作为局部变量使用，好处是当从`jquery`中访问`window`对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问`window`对象。同样，传入`undefined`参数，可以缩短查找`undefined`时的作用域链。

  ```javascript
  (function(window, undefined) {
    // 用一个函数域包起来，就是所谓的沙箱；
    // 在这里面用 var 定义的变量，属于这个函数域内的局部变量，避免污染全局；
    // 把当前沙箱需要的外部变量通过函数参数引入进来；
    // 只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数；
    window.jQuery = window.$ = jQuery;
  })(window);
  ```

* `jQuery`将一些原型属性和方法封装在了 `jquery.prototype` 中，为了缩短名称，又赋值给了`jquery.fn`，这是很形象的写法。

* 有些数组或对象的方法经常能使用到，jQuery 将其保存为局部变量以提高访问速度。

* jQuery 实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。

### 2. jQuery 的实现原理

* `(function(window, undefined) {})(window)`
* `jQuery`利用 `JS` 函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题。
* `window.jQuery = window.$ = jQuery;`
* 在闭包当中将 `jQuery` 和 $ 绑定到 `window` 上，从而将`jQuery`和`$`暴露为全局变量。

### 3. `jQuery.fn`的 `init`方法返回的`this`指的是什么对象？

* `jQuery.fn`的`init`方法返回的`this`就是`jQuery`对象；
* 用户使用`jQuery()`或`$()`即可初始化`jQuery`对象，不需要动态的调用`init`方法；

### 4. `jQuery.extend`与`jQuery.fn.extend`的区别？

* `$.fn.extend()`和`$.extend()`是`jQuery`为扩展插件提供了两个方法。

* `$.extend(object)` 为 `jQuery` 添加“静态方法”（工具方法）。

  ```javascript
  $.extend({
    min: function(a, b) { return a < b ? a : b }
    max: function(a, b) { return a > b ? a : b }
  })
  $.min(2, 3)	// 2
  $.max(4, 5)	// 5
  ```

* `$.extend([true, ]targetObject, object1[, object2])` 对 target 对象进行扩展。

  ```javascript
  var settings = { validate: false, limit: 5 }
  var options = { validate: true, name: 'bar' }
  $.extend(settings, options)	// 注意：不支持第一个参数传 false
  
  // settings == { validate: true, limit: 5, name: 'bar' }
  ```

* `$.fn.extend(json)` 为 jQuery 添加“成员函数”（实例方法）

  ```javascript
  $.fn.extend({
    alertValue: function() {
      $(this).click(function() {
        alert($(this).val())
      })
    }
  })
  
  $("#email").alertValue()
  ```

### 5. jQuery 的属性拷贝（extend）的实现原理是什么，如何实现深拷贝？

* **浅拷贝**（只复制一份原始对象的引用）`var newObject = $.extend({}, oldObject)`
* **深拷贝**（对原始对象属性所引用的对象进行递归拷贝）`var newObject = $.extend(true, {}, oldObject)`

### 6. jQuery 的队列是如何实现的

* jQuery 核心中有一组队列控制方法，由 `queue()/dequeue()/clearQueue()` 三个方法组成。
* 主要应用于 `animate()`，`ajax`，其他要按时间顺序执行的事件中

```javascript
var func1 = function(){alert('事件1');}
var func2 = function(){alert('事件2');}
var func3 = function(){alert('事件3');}
var func4 = function(){alert('事件4');}

// 入栈队列事件
$('#box').queue("queue1", func1);  // push func1 to queue1
$('#box').queue("queue1", func2);  // push func2 to queue1

// 替换队列事件
$('#box').queue("queue1", []);  // delete queue1 with empty array
$('#box').queue("queue1", [func3, func4]);  // replace queue1

// 获取队列事件（返回一个函数数组）
$('#box').queue("queue1");  // [func3(), func4()]

// 出栈队列事件并执行
$('#box').dequeue("queue1"); // return func3 and do func3
$('#box').dequeue("queue1"); // return func4 and do func4

// 清空整个队列
$('#box').clearQueue("queue1"); // delete queue1 with clearQueue
```

### 7. jQuery 中的 bind(), live(), delegate(), on()的区别

* `bind()` 直接绑定在目标元素上
* `live()` 通过冒泡传播事件，默认`document`上，支持动态数据
* `delegate()` 更精确的小范围使用事件代理，性能优于 live
* `on()` 是最新的`1.9`版本整合了之前的三种方式的新事件绑定机制

### 8. jQuery 一个对象可以同时绑定多个事件，这是如何实现的

```javascript
  $("#btn").on("mouseover mouseout", func);

  $("#btn").on({
      mouseover: func1,
      mouseout: func2,
      click: func3
  });
```

## Bootstrap

### 1. 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？

* 使用`Bootstrap`时，需要使用 `HTML5` 文档类型（`Doctype`）。`<!DOCTYPE html>`
* 因为`Bootstrap`使用了一些 `HTML5` 元素和 `CSS` 属性，如果在 `Bootstrap`创建的网页开头不使用 `HTML5` 的文档类型（`Doctype`），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过 `W3C` 标准的验证

### 2. 什么是Bootstrap网格系统

> `Bootstrap` 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 `12` 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类

* 响应式网格系统随着屏幕或视口（`viewport`）尺寸的增加，系统会自动分为最多`12`列。

### 3. 对于各类尺寸的设备，Bootstrap设置的class前缀分别是什么

* 超小设备手机（`<768px`）：`.col-xs-*`
* 小型设备平板电脑（`>=768px`）：`.col-sm-*`
* 中型设备台式电脑（`>=992px`）：`.col-md-*`
* 大型设备台式电脑（`>=1200px`）：`.col-lg-*`

### 4. Bootstrap中有关元素浮动及清除浮动的class？

* `class="pull-left"` 元素浮动到左边
* `class="pull-right"` 元素浮动到右边
* `class="clearfix"` 清除浮动

## 微信小程序

### 1 微信小程序有几个文件

`WXSS (WeiXin Style Sheets)`是一套样式语言，用于描述 `WXML` 的组件样式， `js` 逻辑处理，网络请求`json`小程序设置，如页面注册，页面标题及 `tabBar`。

* `app.json` 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的`window` 背景色，配置导航条样式，配置默认标题。
* `app.js` 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。
* `app.wxss` 配置全局 `css`

###  2 微信小程序怎样跟事件传值

给 `HTML` 元素添加 `data-*`属性来传递我们需要的值，然后通过 `e.currentTarget.dataset` 或`onload`的`param`参数获取。但 `data -` 名称不能有大写字母和不可以存放对象。

### 3 小程序的 wxss 和 css 有哪些不一样的地方？

* `wxss`的图片引入需使用外链地址
* 没有 `Body`；样式可直接使用 `import` 导入

###  4 小程序关联微信公众号如何确定用户的唯一性

> 使用 `wx.getUserInfo` 方法 `withCredentials` 为 `true` 时 可获取 `encryptedData`，里面有 `union_id`。后端需要进行对称解密。

### 5 微信小程序与vue区别

* 生命周期不一样，微信小程序生命周期比较简单
* 数据绑定也不同，微信小程序数据绑定需要使用`{{}}`，`vue` 直接`:`就可以
* 显示与隐藏元素，`vue`中，使用 `v-if` 和 `v-show` 控制元素的显示和隐藏，小程序中，使用`wx-if` 和`hidden` 控制元素的显示和隐藏
* 事件处理不同，小程序中，全用 `bindtap(bind+event)`，或者 `catchtap(catch+event)` 绑定事件,`vue：`使用 `v-on:event` 绑定事件，或者使用`@event` 绑定事件
* 数据双向绑定也不也不一样在 `vue`中,只需要再表单元素上加上 `v-model`,然后再绑定 `data`中对应的一个值，当表单元素内容发生变化时，`data`中对应的值也会相应改变，这是 `vue`非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 `data`中声明的变量。





## 真题

### 1. var 和 let、const 的区别

* var 是 ES5 语法，let、const 是 ES6 语法；var 有变量提升
* var 和 let 是变量，可修改；const 是常量，不可修改
* let、const 有块级作用域，var 没有

### 2. typeof 能判断哪些类型

* undefined、string、number、boolean、symbol
* object（注意，typeof null === ‘object’）
* function

### 3. 列举强制类型转换和隐式类型转换

* 强制：parseInt、parseFloat、toString 等
* 隐式：if、逻辑运算、==、+ 拼接字符串

### 4. 手写深度比较 lodash.isEqual

```javascript
// 实现如下效果
const obj1 = {a: 10, b: {x: 100, y: 200}}
const obj2 = {a: 10, b: {x: 100, y: 200}}
isEqual(obj1, obj2) === true

// 判断是否是 object 类型
function isObject(obj) {
  return typeof obj === 'object' && obj !== null
}

// 手写深度比较
function isEqual(obj1, obj2) {
  if (!isObject(obj1) || !isObject(obj2)) return obj1 === obj2
  // 两个都是对象或数组，且都不相等
  const obj1Keys = Object.keys(obj1)
  const obj2Keys = Object.keys(obj2)
  if (obj1Keys.length !== obj2Keys.length) return false
  for (let key in obj1) {
    const res = isEqual(obj1[key], obj2[key])
    if (!res) return false
  }
  return true
}
```

### 5. split() 和 join() 的区别

```javascript
'1-2-3'.split('-')	// [1, 2, 3]
[1, 2, 3].join('-')	// '1-2-3'
```

### 6. 数组的 pop、push、unshift、shift 分别是什么？

> 思考：
>
> * 功能是什么？
> * 返回值是什么？
> * 是否会对原数组造成影响？

```javascript
const arr = [10, 20, 30, 40]

// pop
const popRes = arr.pop()	// 删除数组的最后一项的值，并返回删除该项的值
// push
const pushRes = arr.push(50)	// 从数组的最后追加一项值，并返回变化后数组的 length
// unshift
const unshiftRes = arr.unshift(5)	// 从数组的最前端插入一项值，并返回变化后数组的 length
// shift
const shift = arr.shift()	// 删除数组的第一项的值，并返回删除该项的值


//【扩展】数组的 API，有哪些是纯函数？
// 纯函数：1.不改变原数组（没有副作用）；2.返回一个数组；

// concat
const arr1 = arr.concat([50, 60, 70])
// map
const arr2 = arr.map(num => num * 10)
// filter
const arr3 = arr.filter(num => num > 25)
// slice
const arr4 = arr.slice()

// 非存函数：
// push、pop、shift、unshift、forEach、some、every、reduce

```

### 7. 数组 slice 和 splice 的区别？

> 思考：
>
> * 功能区别（slice - 切片，splice - 剪接）
>
> * 参数和返回值
> * 是否是纯函数？

```javascript
// slice 纯函数
const arr = [10, 20, 30, 40, 50]

// slice 纯函数
const arr1 = arr.slice()
const arr2 = arr.slice(1, 4)
const arr3 = arr.slice(2)
const arr4 = arr.slice(-3)

// splice 非纯函数
const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
const spliceRes1 = arr.splice(1, 2)
const spliceRes2 = arr.splice(1, 0, 'a', 'b', 'c')
```

### 8. [10,  20,  30].map(parseInt) 返回结果是什么？

> 思考：
>
> * map 的参数和返回值
> * parseInt 参数和返回值

```javascript
// 拆解
[10, 20, 30].map((num, index) => {
  return parseInt(num, index)
})
// 10, NaN, NaN
```

### 9. Ajax 请求 get 和 post 的区别？

* get 一般用于查询操作，post 一般用于提交数据；
* get 参数拼接在 URL 上，post 放在请求体内（数据体积更大）；
* 安全性：post 易于防止 CSRF

### 10. 函数 call 和 apply 的区别？

```javascript
fn.call(this, p1, p2, p3)
fn.apply(this, arguments)
```

### 11. 事件代理（委托）是什么？

```javascript
const p1 = document.getElementById('p1')
const body = document.body
bindEvent(p1, 'click', e => {
  // e.stopPropagation()	// 阻止捕获和冒泡阶段中当前事件的进一步传播
  alert('激活')
})
bindEvent(body, 'click', e => {
  alert('取消')
})
```

### 12. 闭包是什么，有什么特性？有什么负面影响？

> 思考：
>
> * 回顾作用域和闭包
> * 回顾闭包应用场景：作为参数被传入，作为返回值被返回
> * 回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）

影响： 变量会常驻内存，得不到释放。闭包不要乱用。

```javascript
// 闭包 函数作为返回值 —— 内存不会被释放
function create() {
  let a = 100
  return function() {
    console.log(a)
  }
}
let fn = create()
let a = 200
fn()	// 100

// 闭包 函数作为参数被传入
function print(fn) {
  let a = 200
  fn()
}
let a = 100
function fn() {
  console.log(a)
}
print(fn)	// 100
```

### 13. 如何阻止事件冒泡和默认行为？

* event.stopPropagation()	// 阻止事件冒泡
* Event.preventDefault()	// 阻止默认行为

### 14. 查找、添加、删除、移动 DOM 节点的方法？

```javascript
document.getElementById()
document.getElementsByClassName()
document.getElementsBuTagName()
document.querySelectorAll()
```

### 15. 如何减少 DOM 操作？

* 缓存 DOM 查询结果；
* 多次 DOM 操作，合并到一次插入；

```javascript
const list = document.getElementById('list')
// 创建一个文档片段，此时还没有插入到 DOM 结构中
const frag = document.createDocumentFragment()
for (let i = 0; i < 20; i++) {
  const li = document.createElement('li')
  li.innerHTML = `List item ${i}`
  // 先插入到文档片段中
  frag.appendChild(li)
}
// 都完成之后，再统一插入到 DOM 结构中
list.appendChild(frag)
```

### 16. 解释 jsonp 的原理，为何它不是真正的 ajax ？

* 浏览器的同源策略（服务端没有同源策略）和跨域

* 哪些 html 标签能绕过跨域？

  > link、img、script

* jsonp 的原理

  ![A7F1B3CE-E035-4772-94D3-3D98C2F781B7_1_105_c](https://tva1.sinaimg.cn/large/008eGmZEgy1gmwb0pe21rj310a0gqjte.jpg)

### 17. document load 和 ready 的区别？

```javascript
window.addEventListener('load', function() {
  // 页面的全部资源加载完才会执行，包括图片、视频等
})

window.addEventListener('DOMContentLoaded', function() {
  // DOM 渲染完即可执行，此时图片、视频还可能没有加载完
})
```

### 18. == 和 === 的不同？

* == 会尝试类型转换
* === 严格相等
* 只有一个场景下使用 == ：判断是否是 undefined 或 null 时，等价于 == null

### 19. 函数声明和函数表达式的区别？

* 函数声明：`function fn() {...}`
* 函数表达式：`const fn = function() {...}`
* 函数声明会在代码执行前预加载，而函数表达式不会。

### 20. New Object() 和 Object.create() 的区别？

* `{}`等同于`new Object()`，原型 `Object.prototype`；
* `Object.create(null)`没有原型；
* `Object.create({...})`可指定原型；

### 21. 关于 this 的场景题

```javascript
const User = {
  count: 1,
  getCount: function() {
    return this.count
  }
}
console.log(User.getCount)	// 1
const func = User.getCount
console.log(func())	// undefined
```

### 22. 关于作用域和自由变量的场景题

```javascript
let i
for(i = 1; i <= 3; i++) {
  setTimeout(function() {
    console.log(i)
  }, 0)
}
// 4
```

```javascript
let a = 100
function test() {
  alert(a)	// 100
  a = 10
  alert(a)	//10
}
test()
alert(a)	// 10
```

### 23. 判断字符串以字母开头，后面字母数字下划线，长度 6-30

```javascript
const reg = /^[a-zA-Z]\w[5,29]$/
```

### 24. 手写字符串 trim  方法，保证浏览器兼容性？

```javascript
String.prototype.trim = function() {
  return this.replace(/^\s+/, '').replace(/\s+$/, '')
}
```

### 25. 如何获取多个数字中的最大值？

```javascript
function max() {
  const nums = Array.prototype.slice.call(arguments)	// 变为数组
  let max = 0
  nums.forEach(n => {
    if (n > max) max = n
  })
  return max
}

// Math 方法
Math.max(10, 30, 20, 40)
```

### 26. 如何用 JS 实现继承？

> class 继承
>
> prototype 继承

### 27. 如何捕获 JS 程序中的异常？

```javascript
// 手动捕获异常
try {
  // todo
} catch (ex) {
  console.log(ex)	// 手动捕获
} finally {
  // todo
}
```

```javascript
// 自动捕获
window.onerror = function(message, source, lineNum, colNum, error) {
  // 第一，对跨域的 js，如 CDN 的，不会有详细的报错信息
  // 第二，对于压缩的 js，还要配合 sourceMap 反查到未压缩的行、列
}
```

### 28. 什么是 JSON ？

* json 是一种数据格式，本质是一段字符串。
* json 格式和 JS 对象结构一致，对 JS 语言更友好。
* `window.JSON`是一个全局对象：`JSON.stringifg`、`JSON.parse`。

```json
// json
{
  "name": "张三",
  "info": {
    "single": true,
    "age": 30,
    "city": "北京"
  },
  "like": ["篮球", "音乐"]
}
```

### 29. 获取当前页面 URL 参数？

```javascript
// 传统方法
function query(name) {
  const search = location.search.substr(1)
  const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
  const res = search.match(reg)
  if (res === null) return null
  return res[2]
}
```

```javascript
// URLSearchParams
function query(name) {
  const search = location.search
  const p = new URLSearchParams(search)
  return p.get(name)
}
```

### 30. 将 URL 参数解释为 JS 对象

```javascript
// 传统方式，分析 search
function queryToObj() {
  const res = {}
  const search = location.search.substr(1)	// 去掉前面的 ‘?’
  search.split('&').forEach(paramStr => {
    const arr = paramStr.split('=')
    const key = arr[0]
    const value = arr[1]
    res[key] = val
  })
  return res
}
```

```javascript
// 使用 URLSearchParams
function queryToObj() {
  const res = {}
  const pList = new URLSearchParams(location.search)
  pList.forEach((val, key) => {
    res[key] = val
  })
  return res
}
```

### 31. 手写 flatern 考虑多层级

```javascript
function flat(arr) {
  const isDeep = arr.some(item => item instanceof Array)
  if (!isDeep) return arr
  const res = Array.prototype.concat.apply([], arr)
  return flat(res)
}
```

### 32. 数组去重

> 思考：
>
> * 传统方式，遍历元素挨个比较、去重
> * 使用 set
> * 考虑计算效率

```javascript
// 传统方式
function unique(arr) {
  const res = []
  arr.forEach(item => {
    if (res.indexOf(item) < 0) res.push(item)
  })
}
```

```javascript
// 使用 Set（无序，不能重复）
function unqiue(arr) {
  const set = new Set(arr)
  return [...set]
}
```

### 33. 手写深拷贝

```javascript
function deepClone(obj = {}) {
  if (typeof obj !== 'object' || obj == null) return obj
  let result
  if (obj instanceof Array) result []
  else result {}
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) result[key] === deepClone(obj[key])
  }
  return result
}
```

### 34. 介绍一下 RAF（requestAnimationFrame）

* 要想动画流畅，更新频率要 60 帧/s，即 16.67 ms 更新一次视图；
* setTimeout 要手动控制频率，而 RAF 浏览器会自动控制；
* 后台标签或隐藏 iframe 中，RAF 会暂停，而 setTimeout 依然执行；

### 35. 前端性能如何优化？一般从哪几个方面考虑？

* 原则：多使用内存、缓存，减少计算、减少网络请求
* 方向：加载页面，页面渲染，页面操作流畅度

### 36. 冒泡排序

> 比较相邻的两个数，如果后一个比前一个小，换位置。

```javascript
const arr = [3, 1, 4, 6, 5, 7, 2]

function bubbleSort(arr) {
  const len = arr.length
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i; j++) {
      if (arr[j + 1] < arr[j]) {
        let temp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = temp
      }
    }
  }
  return arr
}
```

### 37. 快速排序















